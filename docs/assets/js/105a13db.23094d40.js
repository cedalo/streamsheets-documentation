(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[86961],{83166:(e,n,t)=>{"use strict";var i=t(64836);n.Z=void 0;var a=i(t(64938)),o=t(85893),r=(0,a.default)((0,o.jsx)("path",{d:"M12 2 4 5v6.09c0 5.05 3.41 9.76 8 10.91 4.59-1.15 8-5.86 8-10.91V5l-8-3zm-1.06 13.54L7.4 12l1.41-1.41 2.12 2.12 4.24-4.24 1.41 1.41-5.64 5.66z"}),"GppGood");n.Z=r},2548:(e,n,t)=>{"use strict";var i=t(64836);n.Z=void 0;var a=i(t(64938)),o=t(85893),r=(0,a.default)((0,o.jsx)("path",{d:"M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"}),"InfoOutlined");n.Z=r},64938:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),Object.defineProperty(n,"default",{enumerable:!0,get:function(){return i.createSvgIcon}});var i=t(22236)},22236:(e,n,t)=>{"use strict";t.r(n),t.d(n,{capitalize:()=>a.Z,createChainedFunction:()=>o,createSvgIcon:()=>r.Z,debounce:()=>l,deprecatedPropType:()=>s,isMuiElement:()=>u,ownerDocument:()=>c,ownerWindow:()=>f,requirePropFactory:()=>h,setRef:()=>g,unstable_ClassNameGenerator:()=>I,unstable_useEnhancedEffect:()=>k,unstable_useId:()=>y,unsupportedProp:()=>C,useControlled:()=>v,useEventCallback:()=>x.Z,useForkRef:()=>w.Z,useIsFocusVisible:()=>T.Z});var i=t(37078),a=t(36622);const o=function(...e){return e.reduce(((e,n)=>null==n?e:function(...t){e.apply(this,t),n.apply(this,t)}),(()=>{}))};var r=t(58175);const l=function(e,n=166){let t;function i(...i){clearTimeout(t),t=setTimeout((()=>{e.apply(this,i)}),n)}return i.clear=()=>{clearTimeout(t)},i};const s=function(e,n){return()=>null};var p=t(67294),d=t.t(p,2);const u=function(e,n){return p.isValidElement(e)&&-1!==n.indexOf(e.type.muiName)};function m(e){return e&&e.ownerDocument||document}const c=m;const f=function(e){return m(e).defaultView||window};t(87462);const h=function(e,n){return()=>null};const g=t(7960).Z;const k=t(16600).Z;let b=0;const N=d.useId;const y=function(e){if(void 0!==N){const n=N();return null!=e?e:n}return function(e){const[n,t]=p.useState(e),i=e||n;return p.useEffect((()=>{null==n&&(b+=1,t(`mui-${b}`))}),[n]),i}(e)};const C=function(e,n,t,i,a){return null};const v=function({controlled:e,default:n,name:t,state:i="value"}){const{current:a}=p.useRef(void 0!==e),[o,r]=p.useState(n);return[a?e:o,p.useCallback((e=>{a||r(e)}),[])]};var x=t(66875),w=t(78155),T=t(51625);const I={configure:e=>{console.warn(["MUI: `ClassNameGenerator` import from `@mui/material/utils` is outdated and might cause unexpected issues.","","You should use `import { unstable_ClassNameGenerator } from '@mui/material/className'` instead","","The detail of the issue: https://github.com/mui/material-ui/issues/30011#issuecomment-1024993401","","The updated documentation: https://mui.com/guides/classname-generator/"].join("\n")),i.Z.configure(e)}}},90237:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>k,contentTitle:()=>h,default:()=>y,frontMatter:()=>f,metadata:()=>g,toc:()=>b});var i=t(3905),a=t(49044),o=t(87961),r=Object.defineProperty,l=Object.defineProperties,s=Object.getOwnPropertyDescriptors,p=Object.getOwnPropertySymbols,d=Object.prototype.hasOwnProperty,u=Object.prototype.propertyIsEnumerable,m=(e,n,t)=>n in e?r(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,c=(e,n)=>{for(var t in n||(n={}))d.call(n,t)&&m(e,t,n[t]);if(p)for(var t of p(n))u.call(n,t)&&m(e,t,n[t]);return e};const f={id:"influxdb-bridge",title:"InfluxDB Bridge",sidebar_label:"InfluxDB Bridge"},h=void 0,g={unversionedId:"bridges/influxdb-bridge",id:"version-3.1/bridges/influxdb-bridge",title:"InfluxDB Bridge",description:"This plugin is configurable via the Cedalo MQTT platform UI, which simplifies the process of updating config values without the need to restart the broker. Additionally, config updates are synchronized accross cluster nodes, reducing the administrative overhead in clustered environments. Find more information about this here.",source:"@site/mosquitto_versioned_docs/version-3.1/bridges/influxdb-bridge.md",sourceDirName:"bridges",slug:"/bridges/influxdb-bridge",permalink:"/mosquitto/bridges/influxdb-bridge",draft:!1,tags:[],version:"3.1",frontMatter:{id:"influxdb-bridge",title:"InfluxDB Bridge",sidebar_label:"InfluxDB Bridge"},sidebar:"someSidebar",previous:{title:"HTTP Bridge",permalink:"/mosquitto/bridges/http-bridge"},next:{title:"Kafka Bridge",permalink:"/mosquitto/bridges/kafka-bridge"}},k={},b=[{value:"Plugin activation",id:"plugin-activation",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Configuration File Format",id:"configuration-file-format",level:2},{value:"Mapping MQTT packets to InfluxDB",id:"mapping-mqtt-packets-to-influxdb",level:2},{value:"Data type casting",id:"data-type-casting",level:2},{value:"Line Protocol",id:"line-protocol",level:2},{value:"Extractor options",id:"extractor-options",level:2},{value:"Choosing InfluxDB version",id:"choosing-influxdb-version",level:2},{value:"SSL connection options",id:"ssl-connection-options",level:2},{value:"Compression",id:"compression",level:2},{value:"Configuration example",id:"configuration-example",level:2},{value:"Error handling",id:"error-handling",level:2},{value:"Debugging",id:"debugging",level:2},{value:"Notes on data insertions and data format",id:"notes-on-data-insertions-and-data-format",level:2},{value:"Buffering",id:"buffering",level:2},{value:"Retry queue",id:"retry-queue",level:2},{value:"JSON schema",id:"json-schema",level:2}],N={toc:b};function y(e){var n,t=e,{components:r}=t,m=((e,n)=>{var t={};for(var i in e)d.call(e,i)&&n.indexOf(i)<0&&(t[i]=e[i]);if(null!=e&&p)for(var i of p(e))n.indexOf(i)<0&&u.call(e,i)&&(t[i]=e[i]);return t})(t,["components"]);return(0,i.kt)("wrapper",(n=c(c({},N),m),l(n,s({components:r,mdxType:"MDXLayout"}))),(0,i.kt)(a.Z,{mdxType:"PremiumFeature"}),(0,i.kt)(o.Z,{version:"3.1",mdxType:"SinceVersion3"}),(0,i.kt)("admonition",c({},{type:"info"}),(0,i.kt)("p",{parentName:"admonition"},"This plugin is configurable via the Cedalo MQTT platform UI, which simplifies the process of updating config values without the need to restart the broker. Additionally, config updates are synchronized accross cluster nodes, reducing the administrative overhead in clustered environments. Find more information about this ",(0,i.kt)("a",c({parentName:"p"},{href:"/mosquitto/bridges/bridges-index"}),"here"),".")),(0,i.kt)("p",null,"The InfluxDB Bridge plugin can be used to forward data published to the Mosquitto broker to InfluxDB time-series\ndatabases.\nThe plugin can handle multiple database connections. For each connection, a mapping between certain MQTT topics and\nInfluxDB measurements can be defined (see ",(0,i.kt)("a",c({parentName:"p"},{href:"#configuration-example"}),"example configuration"),")."),(0,i.kt)("p",null,"The list of currently supported InfluxDB versions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InfluxDB v1.x")," (using the ",(0,i.kt)("inlineCode",{parentName:"li"},"influx/v1")," driver)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InfluxDB v2.x")," (using the ",(0,i.kt)("inlineCode",{parentName:"li"},"influx/v2")," driver)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InfluxDB v3.x")," (using the ",(0,i.kt)("inlineCode",{parentName:"li"},"influx/v2")," driver (same as ",(0,i.kt)("inlineCode",{parentName:"li"},"InfluxDB v2.x"),"))")),(0,i.kt)("p",null,"InfluxDB Bridge supports both basic (username, password) authentication for v1 and token-based authentication for v2."),(0,i.kt)("p",null,"The plugin manages incoming MQTT messages in a buffer to perform batching and improve performance when writing to\nInfluxDB. The size properties of the buffer can be controlled via the configuration in the ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," section,\nwith ",(0,i.kt)("inlineCode",{parentName:"p"},"bufferSize")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"timeoutMs")," (refer to ",(0,i.kt)("a",c({parentName:"p"},{href:"#configuration-file-format"}),"Configuration File Format"),")."),(0,i.kt)("h2",c({},{id:"plugin-activation"}),"Plugin activation"),(0,i.kt)("p",null,"To enable the InfluxDB Bridge plugin in the broker, add the following to the ",(0,i.kt)("inlineCode",{parentName:"p"},"mosquitto.conf")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{}),"plugin /usr/lib/cedalo_influxdb_bridge.so\n\npersistence_location /mosquitto/data\n")),(0,i.kt)("p",null,"This is an example configuration snippet, which applies to the docker container setup. For installation not running in a\ncontainer, the above configuration needs to be adjusted accordingly (namely the location of ",(0,i.kt)("inlineCode",{parentName:"p"},"cedalo_influxdb_bridge.so"),"\ndynamic library and ",(0,i.kt)("inlineCode",{parentName:"p"},"persistence_location")," may differ)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"persistence_location")," is used as the search path for the plugin's config file in the context of a single node broker.\nThe file must be called ",(0,i.kt)("inlineCode",{parentName:"p"},"Influxdb-Bridge.json"),". This file must be created to allow the plugin to start, but it may be\nleft empty. The ownership of this file should be given to the ",(0,i.kt)("inlineCode",{parentName:"p"},"mosquitto")," user.\nIn the context of an HA cluster, configuration is fully managed by the Cedalo Platform or manually via a respective\ncontrol topic (see the section below)."),(0,i.kt)("p",null,"In addition to modifying ",(0,i.kt)("inlineCode",{parentName:"p"},"mosquitto.conf"),", ensure that you have the appropriate license to use the plugin."),(0,i.kt)("h2",c({},{id:"configuration"}),"Configuration"),(0,i.kt)("p",null,"The configuration of the bridge is achieved by providing a configuration file following the JSON schema below.\nYou can modify the configuration file using the MQTT API for the Mongo Bridge. This is described in detail ",(0,i.kt)("a",c({parentName:"p"},{href:"/mosquitto/api/mqttapis/influxdb-bridge"}),"here"),".\nAnother option is to use the user interface provided with the Cedalo Mosquitto Platform, which provides a\nwebpage to modify and update the configuration. This option is described below in the ",(0,i.kt)("a",c({parentName:"p"},{href:"/mosquitto/bridges/bridges-ui"}),"Bridges Platform UI section")),(0,i.kt)("h2",c({},{id:"configuration-file-format"}),"Configuration File Format"),(0,i.kt)("p",null,"The configuration is managed by the control topic with the latest update being stored to disk with a filename\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"Influxdb-Bridge.json")," under the persistence location (as defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"mosquitto.conf"),")."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that in the single node setting, the plugin will not be able to start unless the ",(0,i.kt)("inlineCode",{parentName:"p"},"Influxdb-Bridge.json")," file\nexists under the persistence location. When first starting the plugin this file should be created but may be left empty.\nThe owner of this file should be the ",(0,i.kt)("inlineCode",{parentName:"p"},"mosquitto")," user.")),(0,i.kt)("p",null,'The configuration of the plugin is a JSON object consisting of an array of connection objects as well as an array of\nso-called "schema mappings". Each connection object defines its own InfluxDB connection and MQTT topics to listen to. It\nalso references a mapping of the MQTT message properties to InfluxDB fields and tags (or an entire line protocol record\nif the MQTT message is a line protocol string). Such mappings are called schema mappings and are described in a\ndifferent array within the same file under ',(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings")," field. This is to allow multiple InfluxDB connections to\nreuse the same mappings."),(0,i.kt)("p",null,"The fields of the configuration object are described below. To see an example of the config file refer to\nthe ",(0,i.kt)("a",c({parentName:"p"},{href:"#configuration-example"}),"configuration example section"),".\nRefer to the ",(0,i.kt)("a",c({parentName:"p"},{href:"#json-schema"}),"configuration schema")),(0,i.kt)("p",null,"The following fields of the config are mandatory:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"connections")," (path: ",(0,i.kt)("inlineCode",{parentName:"p"},"$.connections"),"): ",(0,i.kt)("br",null)," An array of InfluxDB connection objects. Apart from database connection\nsettings, each connection object also contains MQTT topic mapping information (type: ",(0,i.kt)("inlineCode",{parentName:"p"},"array"),")."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].name"),"): ",(0,i.kt)("br",null)," Unique identifier of the InfluxDB Bridge connection object. A\nconvenience name for the database connection used in the plugin's logs (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"connection")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection"),"): ",(0,i.kt)("br",null)," Object holding the actual database connection\ninformation (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),").",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"driver")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.driver"),"): ",(0,i.kt)("br",null)," Name of the driver to be used with the database\nconnection. (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),", one of: ",(0,i.kt)("inlineCode",{parentName:"li"},"influxdbv1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"influxdbv2"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hostname")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.hostname"),"): ",(0,i.kt)("br",null)," Hostname or IP address of the InfluxDB\nserver (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"port")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.port"),"): ",(0,i.kt)("br",null)," Port that the InfluxDB server listens for client\nconnections on (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"database")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.database"),"): ",(0,i.kt)("br",null)," Name of the database for InfluxDB v1 or bucket\nfor InfluxDB v2 to connect to (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"credentials")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials"),"): ",(0,i.kt)("br",null)," Object holding authentication\ninformation. (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),")",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For InfluxDB v1:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"username")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials.username"),"): ",(0,i.kt)("br",null)," Username used for\nauthenticating against the database (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"password")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials.password"),"): ",(0,i.kt)("br",null)," Password of the user used\nfor authenticating against the database. (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"))),(0,i.kt)("li",{parentName:"ul"},"For InfluxDB v2:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"token")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials.token"),"): ",(0,i.kt)("br",null)," Authentication token for\nInfluxDB v2 connection (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"organization")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.organization"),"): ",(0,i.kt)("br",null)," Organization that a bucket belongs to\nin InfluxDB v2. This field is only required by InfluxDB v2 itself. But it's not a required field in the JSON\nschema of the plugin (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"topicMappings")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings"),"): ",(0,i.kt)("br",null)," List of mappings specifying a mapping between MQTT\ntopics and InfluxDB measurements to forward data to (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),").",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.name"),"): ",(0,i.kt)("br",null)," Unique identifier of the current topic mapping (\ntype: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.target"),"): ",(0,i.kt)("br",null)," Name of the InfluxDB measurement into which\nMQTT data needs to be inserted. If your MQTT messages are line protocol strings already, this field should be\nset to an empty string (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mqttTopics")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.mqttTopics"),"): ",(0,i.kt)("br",null)," An array of MQTT topics that should be\nforwarded to InfluxDB. MQTT wildcards (",(0,i.kt)("inlineCode",{parentName:"li"},"+")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"#"),") can also be used (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"schemaMapping")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.schemaMapping"),"): ",(0,i.kt)("br",null)," Name of a particular schema\nmapping from ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings")," array to be used as a mapping between ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," measurement and ",(0,i.kt)("inlineCode",{parentName:"li"},"mqttTopics"),"."))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings")," (path: ",(0,i.kt)("inlineCode",{parentName:"p"},"$.schemaMappings"),"): ",(0,i.kt)("br",null)," An array of schema mappings. Each element of the array specifies a\nmapping between MQTT message properties and InfluxDB fields and tags (type: ",(0,i.kt)("inlineCode",{parentName:"p"},"array")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"object"),")."))),(0,i.kt)("p",null,"Optional fields:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"connections")," (path: ",(0,i.kt)("inlineCode",{parentName:"p"},"$.connections"),")"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"connection")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection"),")",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"compression")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.compression"),"): ",(0,i.kt)("br",null)," Properties related to data compression\nfor InfluxDB v2. Not applicable for v1 (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),")",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"enable")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.compression.enable"),"): ",(0,i.kt)("br",null)," Whether to compress data before\nsending to InfluxDB. Less bandwidth required but inflicts more strain on the server (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),",\ndefaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),")"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ssl")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl"),"): ",(0,i.kt)("br",null)," SSL options. SSL connection with the database will not\nbe established if this option is not defined (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),")",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rejectUnauthorized")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.rejectUnauthorized"),"): ",(0,i.kt)("br",null)," Whether to refuse\nunauthorized certificates from the InfluxDB server. (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"caPath")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.caPath"),"): ",(0,i.kt)("br",null)," Path to CA that signed InfluxDB server\ncertificate (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ca")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.ca"),"): ",(0,i.kt)("br",null)," String with CA that signed InfluxDB server\ncertificate. Use either this property or ",(0,i.kt)("inlineCode",{parentName:"li"},"caPath")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"debug")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.debug"),"): ",(0,i.kt)("br",null)," Whether to log debug information about queries\nperformed by the plugin. This option is currently not in use by the plugin. It's reserved for the future\nversions (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lazyConnect")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.lazyConnect"),"): ",(0,i.kt)("br",null)," Whether to allow the plugin to continue\nif the connection to the database cannot be established (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),")."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"options")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options"),"): ",(0,i.kt)("br",null)," Object holding additional plugin settings (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),").",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bufferSize")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options.bufferSize"),"): ",(0,i.kt)("br",null)," Defines the size of the buffer, which is used\nto batch multiple MQTT messages together before inserting them into InfluxDB. For more information,\nsee ",(0,i.kt)("a",c({parentName:"li"},{href:"#buffering"}),"the section on buffering")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"1000"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"timeoutMs")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options.timeoutMs"),"): ",(0,i.kt)("br",null)," Interval in milliseconds after which buffer is\nforcefully released if it is not empty. In other words, it specifies a maximum latency of the buffer release (\ntype: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"5000"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"queueMaxSize")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options.queueMaxSize"),"): ",(0,i.kt)("br",null)," Defines the max size of a retry queue\nused in case a database insert fails due to connection problems. If set to ",(0,i.kt)("inlineCode",{parentName:"li"},"-1"),", the size of the queue is not\nlimited. For more information see ",(0,i.kt)("a",c({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", defaults\nto: ",(0,i.kt)("inlineCode",{parentName:"li"},"-1"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"maxRetries")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options.maxRetries"),"): ",(0,i.kt)("br",null)," Defines a number of retries to be performed\nby a retry queue before dropping the message. For more information,\nsee ",(0,i.kt)("a",c({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"10"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"retryDelayMs")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options.retryDelayMs"),"): ",(0,i.kt)("br",null)," Defines a delay in milliseconds between\nthe retry attempts of the queue. For more information, see ",(0,i.kt)("a",c({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (\ntype: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"1000"),")."))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings")," (path: ",(0,i.kt)("inlineCode",{parentName:"p"},"$.schemaMappings"),"): ",(0,i.kt)("br",null)," An array of schema mappings. Each element of the array specifies a\nmapping between MQTT message properties and InfluxDB fields and tags (type: ",(0,i.kt)("inlineCode",{parentName:"p"},"array")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"object"),")."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].name"),"): ",(0,i.kt)("br",null)," Unique identifier of the current schema mapping. This name is\nmatched against ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.schemaMapping")," to determine which schema mapping to use for\nparticular measurement (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mapping")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping"),"): ",(0,i.kt)("br",null)," An array holding source-to-target mapper object with\ninformation about which properties or metadata to pick out from your MQTT messages as well as which InfluxDB\nfields or tags those properties should be inserted into (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),").",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].source"),"): ",(0,i.kt)("br",null)," Source of the data to be inserted. This can be a\nproperty of the MQTT message payload (in case the payload is a JSON object) or some metadata property (e.g.\nclient_id, timestamp, etc). This field follows a particular unpacking syntax. For more information,\nsee ",(0,i.kt)("a",c({parentName:"li"},{href:"#mapping-mqtt-packets-to-influxdb"}),"below")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].target"),"): ",(0,i.kt)("br",null)," InfluxDB target field or tag name into which\ndata from the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," field will be inserted. For the MQTT messages which are already line protocol strings\nthis field should be an empty string (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"targetType")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].targetType"),"): ",(0,i.kt)("br",null)," Whether the target is a tag, field, or a\nline protocol string (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),", one of: ",(0,i.kt)("inlineCode",{parentName:"li"},"tag"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"field"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"lineProtocol"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"type")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].type"),"): ",(0,i.kt)("br",null)," Optional type casting of the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," field before\nit gets inserted into InfluxDB. See more information about typecasting ",(0,i.kt)("a",c({parentName:"li"},{href:"#data-type-casting"}),"here")," (\ntype: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"options")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options"),"): ",(0,i.kt)("br",null)," Object holding information about additional\ntransformations to be performed on ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," before it is inserted into InfluxDB.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isConst"),"(path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.isConst"),"): ",(0,i.kt)("br",null)," Used to indicate that the field\nin ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," is a constant that should be inserted into InfluxDB as is without trying to unpack it. This is\nrelevant in case the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," field is a string that follows the unpacking syntax but should be treated as\na constant. Otherwise (i.e. for constants that don't follow the unpacking syntax), this field is not\nrequired and therefore can be omitted or only added for clarity and additional context (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replace")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.replace"),"): ",(0,i.kt)("br",null)," Specifies an array of two strings.\nReplaces all occurrences of the first string with the second one before inserting the data into the\ndatabase (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"array")," consisting of two elements of type ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceNullWith")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.replaceNullWith"),"): ",(0,i.kt)("br",null)," Specifies a value\nthat null values on the source will be replaced with (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"any"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceUndefinedWith")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.replaceUndefinedWith"),"): ",(0,i.kt)("br",null)," In case\nthat a property specified in source is missing on the MQTT message, it will be replaced with the value\nspecified in this option (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"any"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"format")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.format"),"): ",(0,i.kt)("br",null)," Used when casting into datetime\ndatatype (i.e. strings representing date and time). Specifies a datetime format string that values from\nsource are formatted as. See ",(0,i.kt)("a",c({parentName:"li"},{href:"https://date-fns.org/v3.3.1/docs/format"}),"format string documentation")," for\nmore information on available format strings. Defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},"yyyy-MM-ddTHH:mm:ss.sssZ")," (with an optional\ntimezone information). However, by default if an integer value representing a unix timestamp in\nmilliseconds is encountered in source, it will also be accepted and appropriately converted to the\ndatetime datatype (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dbFormat")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.dbFormat"),"): ",(0,i.kt)("br",null)," Used when casting into datetime\ndatatype. Specifies a format string that datetime values should be converted to before they are inserted\ninto the table (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceDelimiter")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.replaceDelimiter"),"): ",(0,i.kt)("br",null)," Used when\ncasting into datetime datatype. The format of the datetime values inserted into the database will\ntypically be an ISO format as in the following example: 2017-01-29T14:07:00. InfluxDB can understand and\nparse this format but if you would like to change the delimiter to something else like a space, you can\nstill do it with this option. For more complex changes use the ",(0,i.kt)("inlineCode",{parentName:"li"},"dbFormat")," field (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),").")))))))),(0,i.kt)("h2",c({},{id:"mapping-mqtt-packets-to-influxdb"}),"Mapping MQTT packets to InfluxDB"),(0,i.kt)("p",null,"The plugin configuration specifies the mapping between MQTT packets and InfluxDB fields/tags in the ",(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings"),"\nfield. Elements of the ",(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings")," array must have unique names that will be matched against the ",(0,i.kt)("inlineCode",{parentName:"p"},"schemaMapping"),"\nfield of the respective connection object."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"mapping")," specifies an array of extractor objects (you may also see them being referred to as selectors in other\ndocumentation on bridges) between sources and targets. The ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," field represents the source of the data. It comes\nfrom the MQTT message or its metadata. The ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," field is the name of the field or tag that ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," will be inserted\ninto in InfluxDB. ",(0,i.kt)("inlineCode",{parentName:"p"},"targetType")," specifies whether the target is a field or tag in InfluxDB, or a line protocol string."),(0,i.kt)("p",null,"To be more precise, the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," field can be a constant, a path to a particular metadata property of an MQTT message,\nor a data property within its payload. The latter is relevant for JSON MQTT payloads: in case the MQTT payload is a\nJSON, the path to some data property of such payload can be specified as a source."),(0,i.kt)("p",null,"Below are some examples with clarifications to put the above-mentioned into context:"),(0,i.kt)("p",null,"It is possible to unpack MQTT payload in case it is a JSON and extract (pick out) certain properties from it. This can\nbe achieved by specifying a JSON path to such property in the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," field. However, the properties in this path\nshould be separated not by dots, but rather by square brackets (e.g.: not ",(0,i.kt)("inlineCode",{parentName:"p"},"payload.property1.innerProperty"),"\nbut ",(0,i.kt)("inlineCode",{parentName:"p"},"[payload][property1][innerProperty]"),")."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that currently the only supported characters for the JSON payload properties are ",(0,i.kt)("inlineCode",{parentName:"p"},"[a-zA-Z0-9_-]")," (alphanumeric\ncharacters as well as ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," (underscore) and ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," (dash))")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  ...\n  "name": "mapping1",\n  "mapping": [\n    {\n      "source": "[payload][temperature]",\n      "target": "temp",\n      "targetType": "field"\n    }\n  ],\n  ...\n}\n')),(0,i.kt)("p",null,"In the above example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"temperature")," property from the payload is selected as a field named ",(0,i.kt)("inlineCode",{parentName:"p"},"temp")," in InfluxDB."),(0,i.kt)("p",null,"This means that if the MQTT payload looks like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  "temperature": 21.5,\n  "humidity": 45,\n  "status": "normal"\n}\n')),(0,i.kt)("p",null,"then the value ",(0,i.kt)("inlineCode",{parentName:"p"},"21.5")," will be inserted as a field called ",(0,i.kt)("inlineCode",{parentName:"p"},"temp")," in the InfluxDB measurement."),(0,i.kt)("p",null,"Another example:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  ...\n  "name": "mapping1",\n  "mapping": [\n    {\n      "source": "[payload][sensor][id]",\n      "target": "sensorId",\n      "targetType": "tag"\n    }\n  ],\n  ...\n}\n')),(0,i.kt)("p",null,"The extractor object above expects an MQTT message payload to be in JSON format. It extracts a property ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," from\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"sensor")," object in this payload and inserts (maps) it into ",(0,i.kt)("inlineCode",{parentName:"p"},"sensorId")," tag in InfluxDB."),(0,i.kt)("p",null,"Apart from extracting data from payloads it's also possible to insert constant values, which may be useful for InfluxDB\ntags.\nHere is another example which maps a constant value instead of the one taken from an MQTT message:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  ...\n  "name": "mapping1",\n  "mapping": [\n    {\n      "source": "sensor-reading",\n      "target": "sensorType",\n      "targetType": "tag",\n      "options": {\n        "isConst": true\n      }\n    }\n  ],\n  ...\n}\n')),(0,i.kt)("p",null,"This extractor maps a constant string (",(0,i.kt)("inlineCode",{parentName:"p"},'"sensor-reading"'),") to the tag ",(0,i.kt)("inlineCode",{parentName:"p"},"sensorType")," in InfluxDB. This means that for\nevery MQTT message for which this mapping is invoked, the tag ",(0,i.kt)("inlineCode",{parentName:"p"},"sensorType")," with value ",(0,i.kt)("inlineCode",{parentName:"p"},'"sensor-reading"')," will be added\nto the InfluxDB measurement."),(0,i.kt)("p",null,"To insert the entire MQTT payload (useful when the payload is of a primitive type like a string or a number), the\nextractor would look similar to the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  ...\n  "name": "mapping1",\n  "mapping": [\n    {\n      "source": "[payload]",\n      "target": "status",\n      "targetType": "field"\n    }\n  ],\n  ...\n}\n')),(0,i.kt)("p",null,"Note that apart from ",(0,i.kt)("inlineCode",{parentName:"p"},"[payload]"),", various special metadata properties of the MQTT message may be selected. Here is the\nentire list of special (meta)data properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hostname"),": Hostname of the broker. Note that the ",(0,i.kt)("inlineCode",{parentName:"li"},"HOSTNAME")," environment variable must be specified for the broker, or\nthe default value will be used (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"<Unknown>"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"topic"),": Name of the topic to which the MQTT message was published (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"payload"),": Payload of the MQTT message. Can be used to further unpack (pick out) child properties of the payload\nobject if the latter is a JSON. See below for more information. If the payload was originally a string or a number, it\nwill be treated as such, and no typecasting is necessary (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"any"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"qos"),": QoS level of the MQTT message (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", one of: ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"2"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"retain")," - Retain flag of the MQTT message (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"timestamp")," - Unix timestamp representing the time when the MQTT message arrived at the broker (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"datetime")," - Datetime string representing the time when the MQTT message arrived at the broker (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),"\nrepresenting the date in ISO format)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"uuid")," - unique identifier (UUID) of the message. Note that it is a convenience property. This ID is internally\ngenerated by the InfluxDB Bridge plugin and is not coming from the original message's metadata (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"client_id")," - client_id of the device that published the MQTT message (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),").")),(0,i.kt)("p",null,"To select one of the above-mentioned properties, it should be enclosed in square brackets (",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),") and specified in\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," field of the configuration file."),(0,i.kt)("p",null,"For example, to use the client ID of the device that published the message as a tag in InfluxDB, the following selector\ncan be defined:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  ...\n  "name": "mapping1",\n  "mapping": [\n    {\n      "source": "[client_id]",\n      "target": "deviceId",\n      "targetType": "tag"\n    }\n  ],\n  ...\n}\n')),(0,i.kt)("h2",c({},{id:"data-type-casting"}),"Data type casting"),(0,i.kt)("p",null,"InfluxDB Bridge provides a feature to typecast properties of the MQTT messages before they are inserted into\nmeasurements."),(0,i.kt)("p",null,"In order to cast a certain property to a certain type, the following configuration must be specified:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  ...\n  "name": "<your mapping name here>",\n  "mapping": [\n    {\n      "source": "<your source mqtt message property>",\n      "target": "<your target influxdb field/tag name>",\n      "targetType": "<field or tag>",\n      "type": "<specify type to cast \'source\' into>"\n    }\n  ],\n  ...\n}\n')),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  ...\n  "name": "mapping1",\n  "mapping": [\n    {\n      "source": "[payload][temperature_str]",\n      "target": "temperature",\n      "targetType": "field",\n      "type": "float"\n    }\n  ],\n  ...\n}\n')),(0,i.kt)("p",null,"Appropriate type casting depends on whether the target is a field or a tag in InfluxDB:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For tags: Tags are always stored as strings in InfluxDB.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For fields: InfluxDB supports the following field types:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"float")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"double"),": for floating point values"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"integer"),": for integer values"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"string"),": for text values"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"boolean"),": for true/false values")))),(0,i.kt)("p",null,"Keeping the above in mind, in InfluxDB bridge the following typecasting is provided and makes sense:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For tags: Tags are automatically converted to strings from any type. Therefore the only typecasting that makes sense\nhere is a ",(0,i.kt)("inlineCode",{parentName:"p"},"datetime")," if you are using a date as a tag and want to change it's format. See below for more information\non ",(0,i.kt)("inlineCode",{parentName:"p"},"datetime")," casting.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For fields:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"datetime"),":  casts integers or strings into a datetime (",(0,i.kt)("inlineCode",{parentName:"li"},"format"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"dbFormat")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"replaceDelimiter")," might need to\nbe specified. See ",(0,i.kt)("a",c({parentName:"li"},{href:"#config-format"}),"config options section")," for details). There is no need to typecast datetime\nstrings if they follow ISO format (note that the timezone portion is not required here since many databases don't\nhandle timezones)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number"),": casts strings into either a float or integer (supports float numbers separated by both dots or commas (\ne.g. both ",(0,i.kt)("inlineCode",{parentName:"li"},"1.5")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"1,5")," are handled))."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"integer"),": casts string into an integer truncating the fractional part."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"boolean"),": casts strings or numbers into a boolean value (note that string ",(0,i.kt)("inlineCode",{parentName:"li"},'"false"')," is cast to the ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),"boolean\nvalue, as is number ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),", empty string, or a missing property. Everything else is cast to ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"string"),": can cast numbers into strings. There is typically no need to typecast JSON objects to strings as this is\ndone automatically.")))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that while it might be tempting to explicitly specify typecasting for all the ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"s, this is not recommended\nas typecasting is often associated with additional overhead. The rule of thumb would be to cast only what is necessary.")),(0,i.kt)("h2",c({},{id:"line-protocol"}),"Line Protocol"),(0,i.kt)("p",null,"InfluxDB natively understands\nthe ",(0,i.kt)("a",c({parentName:"p"},{href:"https://docs.influxdata.com/influxdb/v2.6/reference/syntax/line-protocol/"}),"Line Protocol")," format. If your MQTT\npayload already contains data in Line Protocol format, you can use the special ",(0,i.kt)("inlineCode",{parentName:"p"},"lineProtocol")," target type to directly\ninsert it:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  ...\n  "name": "mapping1",\n  "mapping": [\n    {\n      "source": "[payload]",\n      "target": "",\n      "targetType": "lineProtocol"\n    }\n  ],\n  ...\n}\n')),(0,i.kt)("p",null,"Note that the target is empty. This is because line protocol strings already include all the required data (which\nmeasurements, tags, and fields to insert). Apart from setting target of the mapping to an empty string, you will also\nhave to set a ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," field of the ",(0,i.kt)("inlineCode",{parentName:"p"},"topicMappings")," to an empty string. This is again because the name of the\nmeasurement has to be included as part of the line protocol string itself."),(0,i.kt)("p",null,"With the configuration above, if your MQTT payload contains valid Line Protocol data like:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{}),"weather,location=us-midwest temperature=82.0,humidity=54 1465839830100400200\n")),(0,i.kt)("p",null,"It will be directly parsed and inserted by InfluxDB."),(0,i.kt)("p",null,"Also note that the timestamp at the end is in nanoseconds. The timestamp may also be omitted, in which case the current\ntime of message reception by the InfluxDB will be used instead."),(0,i.kt)("h2",c({},{id:"extractor-options"}),"Extractor options"),(0,i.kt)("p",null,"Each extractor under the ",(0,i.kt)("inlineCode",{parentName:"p"},"mapping")," section of the configuration file can have additional options that define\ntransformations to be performed on the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," data before it is inserted into ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),". For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  ...\n  "name": "mapping1",\n  "mapping": [\n    {\n      "source": "[payload][property1]",\n      "target": "column_a",\n      "options": {\n        "replaceNullWith": "<null>"\n      }\n    }\n  ],\n  ...\n}\n')),(0,i.kt)("p",null,"The above specifies an extractor that maps ",(0,i.kt)("inlineCode",{parentName:"p"},"property1")," of the MQTT message to the ",(0,i.kt)("inlineCode",{parentName:"p"},"column_a")," in the InfluxDB\nmeasurement. Once the ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," value is encountered in the ",(0,i.kt)("inlineCode",{parentName:"p"},"property1")," property of the MQTT message's payload, it will be\nconverted to ",(0,i.kt)("inlineCode",{parentName:"p"},'"<null>"')," string before being inserted into the database."),(0,i.kt)("p",null,"Note that some options can only be used with certain (or when typecasting to certain) datatypes, while others can be\nused with any type."),(0,i.kt)("p",null,"Options which can only be used when typecasting to ",(0,i.kt)("inlineCode",{parentName:"p"},"datetime"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"format")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dbFormat")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceDelimiter"))),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  ...\n  "name": "mapping1",\n  "mapping": [\n    {\n      "source": "[payload][property1]",\n      "target": "column_a",\n      "type": "datetime",\n      "options": {\n        "nullValue": "<null>",\n        "format": "yyyy-MM-dd HH:mm:ss",\n        "dbFormat": "dd-MMM-yy hh:mm:ss",\n        "replaceDelimiter": " "\n      }\n    }\n  ],\n  ...\n}\n')),(0,i.kt)("p",null,"Options which can be used as long as the underlying value is a ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replace"))),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  ...\n  "name": "mapping1",\n  "mapping": [\n    {\n      "source": "[payload][property1]",\n      "target": "column_a",\n      "options": {\n        "replace": [\n          "hello world",\n          "hello SQL"\n        ]\n      }\n    }\n  ],\n  ...\n}\n')),(0,i.kt)("p",null,"Options which can be used regardless of types and typecasting:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceNullWith")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceUndefinedWith")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isConst"))),(0,i.kt)("p",null,"See ",(0,i.kt)("a",c({parentName:"p"},{href:"#config-format"}),"configuration options")," for more information on the listed options (their descriptions, datatypes,\nallowed values)."),(0,i.kt)("h2",c({},{id:"choosing-influxdb-version"}),"Choosing InfluxDB version"),(0,i.kt)("p",null,"To work with different InfluxDB versions you have to change the ",(0,i.kt)("inlineCode",{parentName:"p"},"driver")," field under ",(0,i.kt)("inlineCode",{parentName:"p"},"connection")," in a respective\nconnection object of the configuration. The allowed values are ",(0,i.kt)("inlineCode",{parentName:"p"},"influxdbv1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"influxdbv2"),". To work with InfluxDB v3\nchoose ",(0,i.kt)("inlineCode",{parentName:"p"},"influxdbv2")," driver as the REST API for v2 and v3 is the same."),(0,i.kt)("p",null,"There are also some additional properties specific to the InfluxDB version. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"username")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"password"),"\nproperties under ",(0,i.kt)("inlineCode",{parentName:"p"},"credentials")," are only relevant to InfluxDB v1, while ",(0,i.kt)("inlineCode",{parentName:"p"},"token")," property is only used for v2."),(0,i.kt)("p",null,"Apart from that, there is a ",(0,i.kt)("inlineCode",{parentName:"p"},"compression")," object under ",(0,i.kt)("inlineCode",{parentName:"p"},"connection"),", which is applicable only to InfluxDB v2."),(0,i.kt)("h2",c({},{id:"ssl-connection-options"}),"SSL connection options"),(0,i.kt)("p",null,"As InfluxDB (both v1 and v2) supports custom server certificates, you can specify TLS/SSL options under ",(0,i.kt)("inlineCode",{parentName:"p"},"ssl")," field to\nallow Mosquitto to connect to such an InfluxDB instance."),(0,i.kt)("p",null,"As InfluxDB does not support mTLS you can only specify a CA certificate that signed the custom certificate of your\nInfluxDB under SSL options. To that end, there are two fields: ",(0,i.kt)("inlineCode",{parentName:"p"},"ca")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"caPath"),". The first one specifies a certificate\nas a PEM-formatted string, while the other field specifies a path to a certificate file on the filesystem."),(0,i.kt)("p",null,"Another field under SSL options is ",(0,i.kt)("inlineCode",{parentName:"p"},"rejectUnauthorized")," which is a boolean specifying whether to reject unknown\ncertificates. This option must not be specified in production as it opens your connection up to Man-in-the-Middle (MITM)\nattacks. The default for this setting is ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,i.kt)("p",null,"If instead of custom certificates your InfluxDB instance is using a certificate signed by a well-known certificate\nauthority (one of the CAs whose certificates are shipped together with major browsers like Firefox), you may set\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"ssl")," field to an empty object. This is the same as specifying an ",(0,i.kt)("inlineCode",{parentName:"p"},"ssl")," object with a single\nproperty ",(0,i.kt)("inlineCode",{parentName:"p"},"rejectUnauthorized")," set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". This way a TLS connection will still be initiated by the broker."),(0,i.kt)("h2",c({},{id:"compression"}),"Compression"),(0,i.kt)("p",null,"InfluxDB v2 supports data compression of incoming records with ",(0,i.kt)("inlineCode",{parentName:"p"},"gzip"),"\nas ",(0,i.kt)("a",c({parentName:"p"},{href:"https://docs.influxdata.com/influxdb/v2/write-data/developer-tools/api/#use-gzip-compression-with-the-influxdb-api"}),"noted in the InfluxDB documentation"),"\nCompression in InfluxDB is one of the techniques\nto ",(0,i.kt)("a",c({parentName:"p"},{href:"https://docs.influxdata.com/influxdb/cloud/write-data/best-practices/optimize-writes/?t=InfluxDB+API#use-gzip-compression"}),"optimize writes to the database"),"\nHowever, be aware that while compression reduces network bandwidth, it increases the load on the server as it has to\nperform compression every time before sending the data over. This means that careful benchmarking needs to be performed\nbefore deciding if compression helps your use case."),(0,i.kt)("p",null,"To enable compression set an ",(0,i.kt)("inlineCode",{parentName:"p"},"enable")," field under ",(0,i.kt)("inlineCode",{parentName:"p"},"compression")," object in ",(0,i.kt)("inlineCode",{parentName:"p"},"connection")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". The default value\nis ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),". This feature only works for InfluxDB v2 and higher."),(0,i.kt)("h2",c({},{id:"configuration-example"}),"Configuration example"),(0,i.kt)("p",null,"An example of the configuration with two database connections is shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  "version": "1",\n  "connections": [\n    {\n      "name": "InfluxDB v1 Connection",\n      "connection": {\n        "driver": "influxdbv1",\n        "hostname": "influxdb-v1.example.com",\n        "port": 8086,\n        "database": "mqtt_data",\n        "credentials": {\n          "username": "admin",\n          "password": "password123"\n        }\n      },\n      "options": {\n        "bufferSize": 5000,\n        "timeoutMs": 3000,\n        "queueMaxSize": 10000,\n        "maxRetries": 15,\n        "retryDelayMs": 1000\n      },\n      "topicMappings": [\n        {\n          "name": "topic-mapping-to-weather-measurement",\n          "schemaMapping": "weather-schema-mapping",\n          "target": "weather_data",\n          "mqttTopics": [\n            "sensors/weather/#"\n          ]\n        }\n      ]\n    },\n    {\n      "name": "InfluxDB v2 Connection",\n      "connection": {\n        "driver": "influxdbv2",\n        "hostname": "influxdb-v2.example.com",\n        "port": 8086,\n        "database": "mqtt_metrics",\n        "organization": "my-org",\n        "credentials": {\n          "token": "your-influxdb-v2-token"\n        },\n        "compression": {\n          "enable": true\n        }\n      },\n      "options": {\n        "bufferSize": 1000,\n        "timeoutMs": 4000,\n        "queueMaxSize": 5000,\n        "maxRetries": 10,\n        "retryDelayMs": 2000\n      },\n      "topicMappings": [\n        {\n          "name": "topic-mapping-to-system-measurement",\n          "schemaMapping": "system-schema-mapping",\n          "target": "system_metrics",\n          "mqttTopics": [\n            "system/metrics/#"\n          ]\n        }\n      ]\n    }\n  ],\n  "schemaMappings": [\n    {\n      "name": "weather-schema-mapping",\n      "mapping": [\n        {\n          "source": "[client_id]",\n          "target": "device_id",\n          "targetType": "tag"\n        },\n        {\n          "source": "[payload][temperature]",\n          "target": "temperature",\n          "targetType": "field"\n        },\n        {\n          "source": "[payload][humidity]",\n          "target": "humidity",\n          "targetType": "field"\n        },\n        {\n          "source": "[payload][location]",\n          "target": "location",\n          "targetType": "tag"\n        },\n        {\n          "source": "[timestamp]",\n          "target": "recorded_at",\n          "targetType": "field"\n        }\n      ]\n    },\n    {\n      "name": "system-schema-mapping",\n      "mapping": [\n        {\n          "source": "[client_id]",\n          "target": "host",\n          "targetType": "tag"\n        },\n        {\n          "source": "[payload][cpu]",\n          "target": "cpu_usage",\n          "targetType": "field"\n        },\n        {\n          "source": "[payload][memory]",\n          "target": "memory_usage",\n          "targetType": "field"\n        },\n        {\n          "source": "[payload][disk]",\n          "target": "disk_usage",\n          "targetType": "field"\n        },\n        {\n          "source": "system",\n          "target": "data_type",\n          "targetType": "tag",\n          "options": {\n            "isConst": true\n          }\n        }\n      ]\n    }\n  ]\n}\n')),(0,i.kt)("p",null,"As per the example config above, InfluxDB bridge will connect to two databases: an InfluxDB v1 instance\nat ",(0,i.kt)("inlineCode",{parentName:"p"},"influxdb-v1.example.com:8086")," and an InfluxDB v2 instance at ",(0,i.kt)("inlineCode",{parentName:"p"},"influxdb-v2.example.com:8086"),". It will use a database\ncalled ",(0,i.kt)("inlineCode",{parentName:"p"},"mqtt_data")," for v1 and a bucket called ",(0,i.kt)("inlineCode",{parentName:"p"},"mqtt_metrics")," in the organization ",(0,i.kt)("inlineCode",{parentName:"p"},"my-org")," for v2."),(0,i.kt)("p",null,"The optional ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," field is specified and overrides some defaults of the plugin's buffering. For the v1 connection,\nit sets ",(0,i.kt)("inlineCode",{parentName:"p"},"bufferSize")," to 5000 and ",(0,i.kt)("inlineCode",{parentName:"p"},"timeoutMs")," to 3000 milliseconds, while for the v2 connection, it sets ",(0,i.kt)("inlineCode",{parentName:"p"},"bufferSize")," to\n1000 and ",(0,i.kt)("inlineCode",{parentName:"p"},"timeoutMs")," to 4000 milliseconds. This illustrates that you can set different queue options per database\nconnection, making it adjustable to different traffic loads."),(0,i.kt)("p",null,"Also see ",(0,i.kt)("a",c({parentName:"p"},{href:"#buffering"}),"section about buffering")," for more information."),(0,i.kt)("p",null,"The retry queue parameters are in this case also configured differently depending on the database connection.\nSee ",(0,i.kt)("a",c({parentName:"p"},{href:"#retry-queue"}),"section about retry queue")," for more information."),(0,i.kt)("p",null,"Notice that InfluxDB v2 connection has ",(0,i.kt)("inlineCode",{parentName:"p"},"compression")," enabled, which will compress data before sending it to the\ndatabase, reducing bandwidth at the cost of increased server load. This option is only available for InfluxDB v2."),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"topicMappings")," section, we define which MQTT topics should be forwarded to which InfluxDB measurements. The v1\nconnection maps topics matching ",(0,i.kt)("inlineCode",{parentName:"p"},"sensors/weather/#")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"weather_data")," measurement, while the v2 connection maps\ntopics matching ",(0,i.kt)("inlineCode",{parentName:"p"},"system/metrics/#")," to the measurement called ",(0,i.kt)("inlineCode",{parentName:"p"},"system_metrics"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings")," section defines how the MQTT message data should be mapped to InfluxDB fields and tags. For\nexample, in the ",(0,i.kt)("inlineCode",{parentName:"p"},"weather-schema-mapping"),", we extract:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The client ID as a tag called ",(0,i.kt)("inlineCode",{parentName:"li"},"device_id")),(0,i.kt)("li",{parentName:"ul"},"The temperature, humidity, and timestamp from the payload as fields"),(0,i.kt)("li",{parentName:"ul"},"The location from the payload as a tag")),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"system-schema-mapping"),", we extract:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The client ID as a tag called ",(0,i.kt)("inlineCode",{parentName:"li"},"host")),(0,i.kt)("li",{parentName:"ul"},"CPU, memory, and disk usage from the payload as fields"),(0,i.kt)("li",{parentName:"ul"},"We also add a constant tag called ",(0,i.kt)("inlineCode",{parentName:"li"},"data_type")," with the value ",(0,i.kt)("inlineCode",{parentName:"li"},"system"),". This value will stay the same for all records")),(0,i.kt)("h2",c({},{id:"error-handling"}),"Error handling"),(0,i.kt)("p",null,"Any configuration or license errors will prevent the plugin from being loaded, and respective messages will appear in\nstderr and stdout."),(0,i.kt)("p",null,"If recoverable errors occur during the operation of the plugin, it will generate respective error messages in its stderr\nand prefix them with an ",(0,i.kt)("inlineCode",{parentName:"p"},"ERR:")," prefix. This includes: encountering errors when converting MQTT messages to InfluxDB\nformat as well as failures during data insertion."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that while error messages generated by the plugin will be preceded by ",(0,i.kt)("inlineCode",{parentName:"p"},"ERR:"),", warning messages will get a ",(0,i.kt)("inlineCode",{parentName:"p"},"WARN:"),"\nprefix, while debug messages - a respective ",(0,i.kt)("inlineCode",{parentName:"p"},"DEBUG:"),".")),(0,i.kt)("h2",c({},{id:"debugging"}),"Debugging"),(0,i.kt)("p",null,"To print detailed information about operations being performed against the InfluxDB database to the stdout, define\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"DEBUG")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"DEBUG_INFLUXDB_BRIDGE")," environment variables on the broker."),(0,i.kt)("p",null,"In future versions the functionality of debug environment variables will move to the ",(0,i.kt)("inlineCode",{parentName:"p"},"debug")," property in the\nconfiguration file under ",(0,i.kt)("inlineCode",{parentName:"p"},"connection")," section."),(0,i.kt)("h2",c({},{id:"notes-on-data-insertions-and-data-format"}),"Notes on data insertions and data format"),(0,i.kt)("p",null,"Under the hood the plugin converts all the data to InfluxDB line protocol records, which are then inserted using\nInfluxDB REST API endpoint.\nWhile converting data to line protocol, InfluxDB bridge takes care of escaping spaces and special characters in\nmeasurement names and field names, so you don't have to worry about escaping when writing plugin's configuration."),(0,i.kt)("h2",c({},{id:"buffering"}),"Buffering"),(0,i.kt)("p",null,"Buffers are created per measurement for every InfluxDB connection. The size of the buffer is controlled\nwith ",(0,i.kt)("inlineCode",{parentName:"p"},"bufferSize")," field under ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," (",(0,i.kt)("inlineCode",{parentName:"p"},"$.connections[].options"),") and indicates the capacity of the buffer. The\ndefault size of the buffer is 1000. Buffer holds records representing unpacked MQTT messages (or line protocol strings\nif this is the configured format of your MQTT messages) which are to be inserted to the respective measurement once the\nbuffer is saturated."),(0,i.kt)("p",null,"Once the buffer fills up, its flushing is triggered, and a batch write is issued against the measurement, inserting the\nbuffer contents. The condition for buffer flush is ",(0,i.kt)("inlineCode",{parentName:"p"},"bufferSize + 1"),". Once this number of records is reached, the buffer\nis released."),(0,i.kt)("p",null,"Another parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"timeoutMs")," - indicates the time interval (in milliseconds) after which all the non-empty buffers will\nbe forcefully released triggering the batch writes of the buffers' contents. The default value is 5000 ms."),(0,i.kt)("p",null,"However, even though it might seem that buffer is only released after saturation or a timeout, it also has a mechanism\nto account for infrequent MQTT messages and decrease the latency of database inserts for such records."),(0,i.kt)("p",null,'The idea is that the time interval between consecutive MQTT messages is kept track of. If this interval is long enough,\nthe record will be inserted instantly. However, if the interval between the messages is short, the plugin will keep\nbuffering the messages anticipating a possible influx. The definition of "long enough" might change when updates to the\nplugin are made, but currently, it\'s a fraction of the ',(0,i.kt)("inlineCode",{parentName:"p"},"timeoutMs.")),(0,i.kt)("p",null,"Note that this leads to the first MQTT message never being buffered."),(0,i.kt)("p",null,"Also, notice that buffer options can be defined per database connection, allowing for more flexibility and fine-tuning\nwhen needed."),(0,i.kt)("h2",c({},{id:"retry-queue"}),"Retry queue"),(0,i.kt)("p",null,"The InfluxDB bridge plugin provides a retry mechanism for failed writes to ensure data is not lost in case of temporary\nconnection issues. To prevent data loss, InfluxDB bridge has a retry queue that is responsible for retrying message\nwrites in case of connection problems."),(0,i.kt)("p",null,"Each retry queue can be configured with the following settings (under ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," field of the\nconfiguration (",(0,i.kt)("inlineCode",{parentName:"p"},"$.connections[].options"),")):"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"queueMaxSize")," option is used to set the maximum amount of messages that the queue is able to accommodate before it\nstarts to drop them. This limit can be set to infinity using the value ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),", which is the default. Note that if this\nvalue is not set to ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),", then careful considerations and testing should be performed to ensure that the queue will not\noverfill too quickly."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"maxRetries")," is used to specify the maximum number of retry attempts the queue will make before dropping a message. The\ndefault is 10."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"retryDelayMs")," is a minimum amount of time in milliseconds that must pass between the retry queue attempts. The default\nis 1000 ms (1 second)."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that the elements in a retry queue can be both single MQTT messages as well as entire buffers of MQTT messages\nthat are ready to be batch-written to InfluxDB.")),(0,i.kt)("p",null,"An important point is that retries happen only in case of connection errors. In case of invalid data the error is logged\nout but no retries are performed. If a batch of messages is being inserted and only some of these messages are invalid,\nthen the filtering of invalid records from valid ones will happen on the side of the InfluxDB itself using its native\nmechanisms to handle invalid data."),(0,i.kt)("h2",c({},{id:"json-schema"}),"JSON schema"),(0,i.kt)("p",null,"InfluxDB bridge plugin uses the following JSON schema for its configuration:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  "title": "InfluxDB-Bridge Plugin Config",\n  "type": "object",\n  "properties": {\n    "version": {\n      "type": [\n        "string",\n        "integer"\n      ],\n      "nullable": true,\n      "description": "Version of the configuration file"\n    },\n    "connections": {\n      "type": "array",\n      "description": "List of sub-configurations per InfluxDB connection",\n      "items": {\n        "type": "object",\n        "description": "Configuration per InfluxDB connection",\n        "properties": {\n          "name": {\n            "type": "string",\n            "nullable": false,\n            "description": "Unique textual identifier of the configuration"\n          },\n          "connection": {\n            "type": "object",\n            "description": "InfluxDB connection specific configuration",\n            "properties": {\n              "driver": {\n                "type": "string",\n                "enum": [\n                  "influxdbv1",\n                  "influxdbv2"\n                ],\n                "nullable": false,\n                "description": "Name of the InfluxDB driver to use (for InfluxDB v1 or InfluxDB v2/v3)"\n              },\n              "hostname": {\n                "type": "string",\n                "nullable": false,\n                "description": "Hostname or IP of the InfluxDB server to connect to"\n              },\n              "port": {\n                "type": "integer",\n                "nullable": false,\n                "description": "Port of the InfluxDB server to connect to"\n              },\n              "database": {\n                "type": "string",\n                "nullable": false,\n                "description": "Name of the database (or bucket for influxdb v2) to connect to"\n              },\n              "organization": {\n                "type": "string",\n                "nullable": true,\n                "description": "Organization that a bucket belongs to in InfluxDB v2"\n              },\n              "compression": {\n                "type": "object",\n                "nullable": true,\n                "description": "Properties related to data compression happening before sending it over to InfluxDB",\n                "properties": {\n                  "enable": {\n                    "type": "boolean",\n                    "nullable": true,\n                    "default": false,\n                    "description": "Whether to compress data before influxdb. Less bandwidth required but inflicts more strain on the server"\n                  }\n                }\n              },\n              "credentials": {\n                "type": "object",\n                "nullable": false,\n                "description": "Credentials to authenticate to InfluxDB. Combine both v1 credentials (username and password) and v2 credentials (tokens). Only one of the two which corresponds to the InfluxDB version in use must be selected",\n                "properties": {\n                  "token": {\n                    "type": "string",\n                    "nullable": true,\n                    "description": "Authentication token for InfluxDB v2 connection"\n                  },\n                  "username": {\n                    "type": "string",\n                    "nullable": true,\n                    "description": "Username for InfluxDB v1"\n                  },\n                  "password": {\n                    "type": "string",\n                    "nullable": true,\n                    "description": "Password for InfluxDB v1"\n                  }\n                }\n              },\n              "ssl": {\n                "type": "object",\n                "nullable": true,\n                "description": "SSL configuration for the connection",\n                "properties": {\n                  "ca": {\n                    "type": "string",\n                    "nullable": true,\n                    "description": "CA certificate file to use for the connection"\n                  },\n                  "caPath": {\n                    "type": "string",\n                    "nullable": true,\n                    "description": "CA certificate path to use for the connection"\n                  },\n                  "rejectUnauthorized": {\n                    "type": "boolean",\n                    "nullable": true,\n                    "description": "Whether to reject unauthorized connections or not"\n                  }\n                }\n              },\n              "debug": {\n                "type": "boolean",\n                "nullable": true,\n                "description": "Whether to enable debug query logging for connection"\n              },\n              "lazyConnect": {\n                "type": "boolean",\n                "nullable": true,\n                "default": false,\n                "description": "Whether to allow the plugin to continue if the connection to the database cannot be established"\n              }\n            },\n            "nullable": false,\n            "required": [\n              "driver"\n            ]\n          },\n          "topicMappings": {\n            "type": "array",\n            "description": "List of topic mapping objects to forward MQTT messages to InfluxDB",\n            "items": {\n              "type": "object",\n              "properties": {\n                "name": {\n                  "type": "string",\n                  "nullable": false,\n                  "description": "Unique identifier of this mapping"\n                },\n                "schemaMapping": {\n                  "type": "string",\n                  "nullable": false,\n                  "description": "Name of the schema mapping which should be applied here"\n                },\n                "target": {\n                  "type": "string",\n                  "description": "InfluxDB measurement to forward MQTT messages to"\n                },\n                "options": {\n                  "type": "object",\n                  "nullable": true,\n                  "description": "Optional options for the measurement"\n                },\n                "mqttTopics": {\n                  "type": "array",\n                  "items": {\n                    "type": "string",\n                    "description": "List of MQTT topics to forward messages from",\n                    "pattern": "^((\\\\+?|[\\\\w-]+)((\\\\/[\\\\w-]+)?(\\\\/\\\\+)?(\\\\/[\\\\w-]+)?((?<!\\\\+)\\\\/)?)*(\\\\/#)?|(\\\\/)?#)$"\n                  }\n                }\n              },\n              "required": [\n                "name",\n                "target",\n                "mqttTopics"\n              ]\n            }\n          },\n          "options": {\n            "type": "object",\n            "nullable": true,\n            "description": "Plugin options for configuring internal queues and buffers",\n            "properties": {\n              "bufferSize": {\n                "type": "integer",\n                "nullable": true,\n                "minimum": 1,\n                "description": "Maximum number of messages to buffer before flushing to the database"\n              },\n              "timeoutMs": {\n                "type": "integer",\n                "nullable": true,\n                "minimum": 0,\n                "description": "Maximum time in milliseconds to buffer messages before flushing to the database"\n              },\n              "queueMaxSize": {\n                "type": "integer",\n                "nullable": true,\n                "minimum": -1,\n                "description": "Maximum number of messages in retry queue"\n              },\n              "maxRetries": {\n                "type": "integer",\n                "nullable": true,\n                "minimum": 0,\n                "description": "Maximum number of retries for failed inserts due to lost connection"\n              },\n              "retryDelayMs": {\n                "type": "integer",\n                "nullable": true,\n                "minimum": 0,\n                "description": "Delay in milliseconds before retrying inserts failed due to lost connection"\n              }\n            }\n          }\n        },\n        "required": [\n          "name",\n          "connection",\n          "topicMappings"\n        ]\n      }\n    },\n    "schemaMappings": {\n      "type": "array",\n      "items": {\n        "type": "object",\n        "properties": {\n          "name": {\n            "type": "string",\n            "nullable": false,\n            "description": "Unique identifier of the mapping"\n          },\n          "mapping": {\n            "type": "array",\n            "description": "List of mappings to apply to InfluxDB. Each schema contains a mapping of InfluxDB fields/tags to MQTT message properties",\n            "items": {\n              "type": "object",\n              "description": "Properties to select from the MQTT message and insert into InfluxDB",\n              "properties": {\n                "source": {\n                  "oneOf": [\n                    {\n                      "type": "string"\n                    },\n                    {\n                      "type": "number"\n                    },\n                    {\n                      "type": "null",\n                      "nullable": true\n                    }\n                  ],\n                  "description": "JSON path to the value to insert or constant value"\n                },\n                "target": {\n                  "type": "string",\n                  "description": "Name of the field or tag to insert data from \\"source\\" into"\n                },\n                "targetType": {\n                  "type": "string",\n                  "enum": [\n                    "tag",\n                    "field",\n                    "lineProtocol"\n                  ],\n                  "description": "Whether the target is a tag or a field in InfluxDB"\n                },\n                "type": {\n                  "type": "string",\n                  "nullable": true,\n                  "description": "Data type of the value to cast source to before inserting"\n                },\n                "options": {\n                  "type": "object",\n                  "nullable": true,\n                  "description": "Optional options for the field or tag",\n                  "properties": {\n                    "isConst": {\n                      "type": "boolean",\n                      "nullable": true,\n                      "description": "Whether the source is a constant value"\n                    }\n                  }\n                }\n              },\n              "required": [\n                "source",\n                "target",\n                "targetType"\n              ]\n            }\n          }\n        },\n        "required": [\n          "name",\n          "mapping"\n        ]\n      }\n    }\n  },\n  "required": [\n    "connections",\n    "schemaMappings"\n  ]\n}\n')))}y.isMDXComponent=!0},49044:(e,n,t)=>{"use strict";t.d(n,{Z:()=>l});var i=t(67294),a=t(39082),o=t(62659),r=t(83166);function l({inline:e}){return i.createElement(a.Z,{sx:{margin:e?"0px 5px":"0px 5px 5px 10px",height:e?"22px":void 0,color:"#ffffff",backgroundColor:o.Z[500]},size:"small",icon:i.createElement(r.Z,{style:{color:"white"},size:"small"}),label:"Premium"})}},87961:(e,n,t)=>{"use strict";t.d(n,{Z:()=>r});var i=t(67294),a=t(39082),o=t(2548);function r({version:e}){return e?i.createElement(a.Z,{sx:{margin:"0px 5px 5px 10px",bgcolor:"#FD602E"},color:"info",size:"small",icon:i.createElement(o.Z,{size:"small"}),label:`Version ${e}`}):i.createElement(i.Fragment,null)}},64836:e=>{e.exports=function(e){return e&&e.__esModule?e:{default:e}},e.exports.__esModule=!0,e.exports.default=e.exports}}]);