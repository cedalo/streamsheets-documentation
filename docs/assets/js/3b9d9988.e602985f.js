"use strict";(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[59890],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=i,f=d["".concat(l,".").concat(m)]||d[m]||c[m]||r;return n?a.createElement(f,o(o({ref:t},p),{},{components:n})):a.createElement(f,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},79e3:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>m,default:()=>y,frontMatter:()=>d,metadata:()=>f,toc:()=>b});var a=n(3905),i=Object.defineProperty,r=Object.defineProperties,o=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,u=Object.prototype.propertyIsEnumerable,p=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,c=(e,t)=>{for(var n in t||(t={}))l.call(t,n)&&p(e,n,t[n]);if(s)for(var n of s(t))u.call(t,n)&&p(e,n,t[n]);return e};const d={id:"introduction-kubernetes",title:"Kubernetes Introduction",sidebar_label:"Introduction"},m=void 0,f={unversionedId:"deployment/on-premises/deployment/installation/kubernetes/introduction-kubernetes",id:"version-3.0/deployment/on-premises/deployment/installation/kubernetes/introduction-kubernetes",title:"Kubernetes Introduction",description:"Cedalo offers different Mosquitto broker configurations that you can deploy starting from single-node solutions to High Availability Cluster using docker. We also now introduce the kubernetes support for Mosquitto. Kubernetes simplifies Mosquitto broker deployment by providing automated scaling, and easy updates. Our main objective is to offer Kubernetes support for Mosquitto to add support for manual scaling, automated scaling, easier deployment and orchestration of Mosquitto resources and of course reaching a wider audience by giving access to various tech stacks. Its container orchestration streamlines management and ensures high availability, making it ideal for IoT and real-time messaging applications. Kubernetes abstracts infrastructure complexities, allowing you to focus on building robust MQTT services efficiently.",source:"@site/mosquitto_versioned_docs/version-3.0/deployment/on-premises/deployment/installation/kubernetes/introduction-kubernetes.md",sourceDirName:"deployment/on-premises/deployment/installation/kubernetes",slug:"/deployment/on-premises/deployment/installation/kubernetes/introduction-kubernetes",permalink:"/mosquitto/deployment/on-premises/deployment/installation/kubernetes/introduction-kubernetes",draft:!1,tags:[],version:"3.0",frontMatter:{id:"introduction-kubernetes",title:"Kubernetes Introduction",sidebar_label:"Introduction"},sidebar:"someSidebar",previous:{title:"RPM Cedalo MQTT Platform",permalink:"/mosquitto/deployment/on-premises/deployment/installation/rpm/platform-rpm"},next:{title:"Single Node",permalink:"/mosquitto/deployment/on-premises/deployment/installation/kubernetes/single-node"}},h={},b=[{value:"Helm Charts",id:"helm-charts",level:3},{value:"Further common kubernetes concepts that we would using in this setup:",id:"further-common-kubernetes-concepts-that-we-would-using-in-this-setup",level:3},{value:"Deployments:",id:"deployments",level:3},{value:"StatefulSets:",id:"statefulsets",level:3},{value:"Services",id:"services",level:3}],g={toc:b};function y(e){var t,n=e,{components:i}=n,p=((e,t)=>{var n={};for(var a in e)l.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&s)for(var a of s(e))t.indexOf(a)<0&&u.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=c(c({},g),p),r(t,o({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Cedalo offers different Mosquitto broker configurations that you can deploy starting from single-node solutions to High Availability Cluster using docker. We also now introduce the kubernetes support for Mosquitto. Kubernetes simplifies Mosquitto broker deployment by providing automated scaling, and easy updates. Our main objective is to offer Kubernetes support for Mosquitto to add support for manual scaling, automated scaling, easier deployment and orchestration of Mosquitto resources and of course reaching a wider audience by giving access to various tech stacks. Its container orchestration streamlines management and ensures high availability, making it ideal for IoT and real-time messaging applications. Kubernetes abstracts infrastructure complexities, allowing you to focus on building robust MQTT services efficiently.\nKubernetes, the go-to solution for container orchestration, offers a streamlined approach to deploying and managing applications. In this article, we'll explore some of the tools that we would be using to deploy Kubernetes setup in different versions of Mosquitto deployment."),(0,a.kt)("p",null,"Different Versions of Mosquitto Configuration deployment:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Single Node Deployment (Platform portal and 1 Mosquitto broker)"),(0,a.kt)("li",{parentName:"ul"},"HA  - High Availability (3 -Mosquitto broker and Platform portal)"),(0,a.kt)("li",{parentName:"ul"},"HA  - High Availability Dynsec cluster with autoscaling ( Platform portal and 3 default Mosquitto brokers with an option of automated scaling based on demand)."),(0,a.kt)("li",{parentName:"ul"},"Tools we would be discussing here are as follows:"),(0,a.kt)("li",{parentName:"ul"},"Helm Charts (For all versions)")),(0,a.kt)("h3",c({},{id:"helm-charts"}),"Helm Charts"),(0,a.kt)("p",null,"Helm is a package manager for Kubernetes that simplifies application deployment, management, and scaling. Helm charts are predefined packages that encapsulate an application's configuration, dependencies, and runtime requirements. These charts allow you to deploy complex applications like the Mosquitto broker effortlessly. You can refer to further details about helm charts on the official documentation page. A simple helm charts deployment could like this:\n",(0,a.kt)("inlineCode",{parentName:"p"},"helm install my-mosquitto ./mosquitto-chart")),(0,a.kt)("h3",c({},{id:"further-common-kubernetes-concepts-that-we-would-using-in-this-setup"}),"Further common kubernetes concepts that we would using in this setup:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Deployments (Platform and HA)"),(0,a.kt)("li",{parentName:"ul"},"Statefulsets (Mosquitto)"),(0,a.kt)("li",{parentName:"ul"},"Services (Mosquitto, Platform and HA)")),(0,a.kt)("h3",c({},{id:"deployments"}),"Deployments:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Use Case"),": Deployments are primarily used for managing stateless applications, where instances of the application can be easily replaced or scaled up/down without regard to their identity."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Scaling"),": Deployments provide easy scaling of applications horizontally by creating or removing replicas."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Rolling Updates"),": Deployments support rolling updates and rollbacks, making it easy to update the application to a new version or configuration while ensuring zero downtime."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pod Identity"),": Pods managed by Deployments do not have stable network identities or storage. They are disposable, and Kubernetes may reschedule them to different nodes.")),(0,a.kt)("h3",c({},{id:"statefulsets"}),"StatefulSets:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Use Case"),": StatefulSets are designed for managing stateful applications, such as databases, where each pod has a stable and unique identity and may require ordered, sequential scaling or rolling updates."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pod Identity"),": Pods managed by StatefulSets are assigned a stable hostname and storage identity. They are often used for distributed systems where pod identity is critical for operations like failover, sharding, and replication."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Scaling"),": StatefulSets support ordered scaling. You can specify how many replicas you want, and they are created in order, ensuring predictable naming and network identities."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Rolling Updates"),": StatefulSets also support rolling updates, but they are designed to handle the complexity of updating stateful applications while maintaining their unique identities.")),(0,a.kt)("p",null,"In summary, Deployments are suitable for stateless applications, offering easy scaling and rolling updates. StatefulSets, on the other hand, are designed for stateful applications that require stable identities and predictable, ordered scaling. The choice between the two depends on the specific requirements of your application. StatefulSets are essential for scenarios like running databases in Kubernetes, while Deployments are more suitable for typical web services and microservices."),(0,a.kt)("h3",c({},{id:"services"}),"Services"),(0,a.kt)("p",null,'In Kubernetes, a "Service" is an abstraction that defines a logical set of pods and a policy by which to access them. It acts as a stable endpoint for communication, allowing other services or external users to interact with applications running within a Kubernetes cluster without needing to be aware of the specific details of how those applications are deployed or scaled.'),(0,a.kt)("p",null,"Here are the key aspects of Kubernetes Services:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Load Balancing"),": Services provide load balancing across a set of pods. They ensure that network traffic is distributed fairly and efficiently among the pods that belong to the service. This load balancing is crucial for high availability and scalability.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Stable Endpoint"),": Each service is assigned a stable IP address or DNS name, which doesn't change even if pods come and go due to scaling or failures. This stable endpoint simplifies the process of connecting to the application.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Label-Based Selection"),": Services select pods based on labels and label selectors, making it easy to specify which pods should be part of the service. This label-based selection allows dynamic membership management."),(0,a.kt)("h4",c({parentName:"li"},{id:"types-of-services"}),"Types of Services:")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"ClusterIP"),": The default service type, accessible only within the cluster.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"NodePort"),": Exposes the service on each node's IP at a static port on the node. This makes the service accessible externally at the specified port.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"LoadBalancer"),": Provides an external IP address that routes traffic to the service. This is primarily used when running Kubernetes in a cloud environment that supports load balancers.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"ExternalName"),": Maps the service to a DNS name. It doesn't create a cluster IP or load balancer. It's used to make services accessible as external names, often pointing to resources outside the cluster.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Service Discovery"),": Services enable easy service discovery within the Kubernetes cluster. Other pods or services can discover and connect to the service using its DNS name or IP address.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Headless Service"),': You can create a "headless" service, which doesn\'t provide a cluster IP but instead allows direct DNS-based communication with individual pods, useful for certain specialized use cases like StatefulSets.'))),(0,a.kt)("p",null,"Kubernetes Services are a fundamental component for building scalable and resilient applications within a cluster. They abstract the network and routing complexities, allowing developers and operators to focus on the application logic while ensuring reliable communication and load distribution.\nWe would be using different services for different types of applications:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Headless Service (Mosquitto)"),(0,a.kt)("li",{parentName:"ul"},"Load balancer: (Platform portal and HA)")))}y.isMDXComponent=!0}}]);