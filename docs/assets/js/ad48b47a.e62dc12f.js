"use strict";(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[53814],{3905:(t,e,a)=>{a.d(e,{Zo:()=>s,kt:()=>m});var n=a(67294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function o(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function i(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var u=n.createContext({}),p=function(t){var e=n.useContext(u),a=e;return t&&(a="function"==typeof t?t(e):o(o({},e),t)),a},s=function(t){var e=p(t.components);return n.createElement(u.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},c=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,u=t.parentName,s=i(t,["components","mdxType","originalType","parentName"]),c=p(a),m=r,g=c["".concat(u,".").concat(m)]||c[m]||d[m]||l;return a?n.createElement(g,o(o({ref:e},s),{},{components:a})):n.createElement(g,o({ref:e},s))}));function m(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,o=new Array(l);o[0]=c;var i={};for(var u in e)hasOwnProperty.call(e,u)&&(i[u]=e[u]);i.originalType=t,i.mdxType="string"==typeof t?t:r,o[1]=i;for(var p=2;p<l;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},83549:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>k,contentTitle:()=>m,default:()=>b,frontMatter:()=>c,metadata:()=>g,toc:()=>h});var n=a(3905),r=Object.defineProperty,l=Object.defineProperties,o=Object.getOwnPropertyDescriptors,i=Object.getOwnPropertySymbols,u=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,s=(t,e,a)=>e in t?r(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a,d=(t,e)=>{for(var a in e||(e={}))u.call(e,a)&&s(t,a,e[a]);if(i)for(var a of i(e))p.call(e,a)&&s(t,a,e[a]);return t};const c={id:"stackupsert",title:"STACK.UPSERT",hide_title:!0},m=void 0,g={unversionedId:"functions/Stack/stackupsert",id:"version-3.0/functions/Stack/stackupsert",title:"STACK.UPSERT",description:"STACK.UPSERT",source:"@site/streamsheets_versioned_docs/version-3.0/functions/Stack/stackupsert.md",sourceDirName:"functions/Stack",slug:"/functions/Stack/stackupsert",permalink:"/streamsheets/functions/Stack/stackupsert",draft:!1,tags:[],version:"3.0",frontMatter:{id:"stackupsert",title:"STACK.UPSERT",hide_title:!0},sidebar:"someSidebar",previous:{title:"STACK.SORT",permalink:"/streamsheets/functions/Stack/stacksort"},next:{title:"AVERAGE",permalink:"/streamsheets/functions/Statistical/average"}},k={},h=[],f={toc:h};function b(t){var e,a=t,{components:r}=a,s=((t,e)=>{var a={};for(var n in t)u.call(t,n)&&e.indexOf(n)<0&&(a[n]=t[n]);if(null!=t&&i)for(var n of i(t))e.indexOf(n)<0&&p.call(t,n)&&(a[n]=t[n]);return a})(a,["components"]);return(0,n.kt)("wrapper",(e=d(d({},f),s),l(e,o({components:r,mdxType:"MDXLayout"}))),(0,n.kt)("h1",null,"STACK.UPSERT"),(0,n.kt)("p",null,'The STACK.UPSERT function is like a combination of STACK.ADD and STACK.FIND, i.e. it can add and update matching cell values from a given SourceRange. Like STACK.ADD cell values are copied from SourceRange to a specified StackRange if they are not already contained, otherwise they are updated. Analog to STACK.FIND, a CriteriaRange is used to determine the cell values to copy and update. That means the criteria is applied to both ranges to determine the cells to use and to update. Updating is done either by replacing the cell value or by using a simple text based arithmetic rule, like "+1" or by specifying an arbitrary formula.'),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Syntax")),(0,n.kt)("p",null,"=STACK.UPSERT(StackRange, SourceRange, CriteriaRange, ","[","AddIfNotFound","]",", ","[","Direction","]",", ","[","Unique","]",", ","[","TargetRange","]",")"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Arguments")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",d({parentName:"tr"},{align:null}),"Name"),(0,n.kt)("th",d({parentName:"tr"},{align:null}),"Type"),(0,n.kt)("th",d({parentName:"tr"},{align:null}),"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),"StackRange"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Range"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Cell range, to copy SourceRange cells to or to update matching cells. The first row of the StackRange always contains the cell labels and remains unchanged. Which cells are updated is determined by the CriteriaRange.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),"SourceRange"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Range"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Cell range, where the source data or update rules are taken from. Analog to StackRange the first row contains the cell labels and remains unchanged. Which cells are used is determined by the CriteriaRange.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),"CriteriaRange"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Range"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"The CriteriaRange has at least 2 rows, the first one is the labels row with labels also found in StackRange and SourceRange (not necessarily all and maybe not in the same order!), the second to nth row contain filter settings. Note: criteria values can start with a comparison-operator like, ",(0,n.kt)("inlineCode",{parentName:"td"},">, >=, <, <=, = or <>"),". Settings in the same row are combined using AND, multiple rows are OR.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),"AddIfNotFound (optional)"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Boolean"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"If a matching source row is not found in StackRange it will be added. Specify FALSE to prevent this behaviour. ",(0,n.kt)("br",null),(0,n.kt)("br",null),"Default value: TRUE")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Direction (optional)"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Boolean"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"If you set Direction to TRUE the new data is added behind the last empty row on the StackRange. If the StackRange is full, the first row (after the columns row) is dropped from the stack and all rows move up to make room for the new data in the last row. Analog, if Direction is set to FALSE rows are added at top of the stack and dropped from the bottom. ",(0,n.kt)("br",null),(0,n.kt)("br",null),"Default value: TRUE")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Unique (optional)"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Boolean"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"If set to TRUE equal rows are updated or added only once to StackRange. Two rows are equal if they have same value in each column. ",(0,n.kt)("br",null),(0,n.kt)("br",null),"Default value: FALSE")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),"TargetRange (optional)"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Range"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"If TargetRange is specified and if a row has to be dropped, the row is copied to the TargetRange. TargetRange must have two rows, the first row has labels also found in StackRange (not necessarily all and maybe not in the same order!). The dropped values are copied to the matching columns in the TargetRange. If no row is dropped, the values in the second row of TargetRange are blanked out. Important: Before copying to the TargetRange all existing values in TargetRange are deleted (not the labels row!)")))),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Return")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",d({parentName:"tr"},{align:null}),"Type"),(0,n.kt)("th",d({parentName:"tr"},{align:null}),"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Boolean or Error"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"TRUE, if no error occurred, otherwise an ",(0,n.kt)("a",d({parentName:"td"},{href:"../../other/errorcodes"}),"error")," value.")))),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Examples")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",d({parentName:"tr"},{align:null})),(0,n.kt)("th",d({parentName:"tr"},{align:null}),"A"),(0,n.kt)("th",d({parentName:"tr"},{align:null}),"B"),(0,n.kt)("th",d({parentName:"tr"},{align:null}),"C"),(0,n.kt)("th",d({parentName:"tr"},{align:null}),"D"),(0,n.kt)("th",d({parentName:"tr"},{align:null}),"E"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),"4"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"ItemNumber"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Quantity"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Price"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"VAT"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Total")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),"5"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"1234"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"+1"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"=23"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"0.19"),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"=B5 ","*"," C5 ","*"," (1 + D5)")))),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",d({parentName:"tr"},{align:null}),"Formula"),(0,n.kt)("th",d({parentName:"tr"},{align:null}),"Result"),(0,n.kt)("th",d({parentName:"tr"},{align:null}),"Comment"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),(0,n.kt)("pre",null,(0,n.kt)("code",null,"=STACK.UPSERT(A1:E3,A5:E5,A4:A5)"))),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"After calling STACK.UPSERT the first time the row in A1 will contains following values: 1234, 1, 23, 0.19, 27.37 i.e. Quantity is initialized with 1  and Price with 23 and the Total value is 27.37 which was calculated by specified formula."),(0,n.kt)("td",d({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",d({parentName:"tr"},{align:null}),(0,n.kt)("pre",null,(0,n.kt)("code",null,"=STACK.UPSERT(A1:E3,A5:E5,A4:A5)"))),(0,n.kt)("td",d({parentName:"tr"},{align:null}),"Calling STACK.UPSERT again will update the row in A1 to following values: 1234, 2, 23, 0.19, 54.74 i.e. +1 is used to update Quantity. The Price remains unchanged since it already exists. And again the Total value is calculated by a formula and results to 54.74."),(0,n.kt)("td",d({parentName:"tr"},{align:null}))))))}b.isMDXComponent=!0}}]);