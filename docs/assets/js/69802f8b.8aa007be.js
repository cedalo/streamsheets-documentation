"use strict";(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[61812],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,f=d["".concat(l,".").concat(m)]||d[m]||c[m]||o;return n?a.createElement(f,r(r({ref:t},u),{},{components:n})):a.createElement(f,r({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},61366:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>m,default:()=>y,frontMatter:()=>d,metadata:()=>f,toc:()=>g});var a=n(3905),i=Object.defineProperty,o=Object.defineProperties,r=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,u=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,c=(e,t)=>{for(var n in t||(t={}))l.call(t,n)&&u(e,n,t[n]);if(s)for(var n of s(t))p.call(t,n)&&u(e,n,t[n]);return e};const d={id:"introduction",title:"Introduction",sidebar_label:"Introduction"},m=void 0,f={unversionedId:"openshift/introduction",id:"version-2.9/openshift/introduction",title:"Introduction",description:"Cedalo offers different Mosquitto broker configurations that you can deploy starting from single-node solutions to High Availability Cluster using docker. We also now introduce the Openshift support for Mosquitto. Openshift support for Mosquitto is an extension to Kubernetes support for mosquitto and hence most of deployment strategies would be quite similar to what we had in Kubernetes setup.",source:"@site/mosquitto_versioned_docs/version-2.9/openshift/introduction.md",sourceDirName:"openshift",slug:"/openshift/introduction",permalink:"/mosquitto/openshift/introduction",draft:!1,tags:[],version:"2.9",frontMatter:{id:"introduction",title:"Introduction",sidebar_label:"Introduction"},sidebar:"someSidebar",previous:{title:"High Availability Autoscaling",permalink:"/mosquitto/kubernetes/high-availability-autoscaling"},next:{title:"HA Openshift",permalink:"/mosquitto/openshift/high-availability-openshift"}},h={},g=[{value:"Openshift",id:"openshift",level:2},{value:"Helm Charts",id:"helm-charts",level:3},{value:"Openshift OKD",id:"openshift-okd",level:3},{value:"Further common Kubernetes concepts that we would using in this setup:",id:"further-common-kubernetes-concepts-that-we-would-using-in-this-setup",level:3},{value:"Deployments:",id:"deployments",level:3},{value:"StatefulSets:",id:"statefulsets",level:3},{value:"Services",id:"services",level:3}],b={toc:g};function y(e){var t,n=e,{components:i}=n,u=((e,t)=>{var n={};for(var a in e)l.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&s)for(var a of s(e))t.indexOf(a)<0&&p.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=c(c({},b),u),o(t,r({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Cedalo offers different Mosquitto broker configurations that you can deploy starting from single-node solutions to High Availability Cluster using docker. We also now introduce the Openshift support for Mosquitto. Openshift support for Mosquitto is an extension to Kubernetes support for mosquitto and hence most of deployment strategies would be quite similar to what we had in Kubernetes setup."),(0,a.kt)("h2",c({},{id:"openshift"}),"Openshift"),(0,a.kt)("p",null,"OpenShift is a cloud-based Kubernetes container platform that offers automated installation, upgrades, and lifecycle management throughout the container stack\u2014the operating system, Kubernetes and cluster services, and applications\u2014on any cloud. Developed by Red Hat, it provides a powerful environment for deploying applications in containers, enabling developers to automate the provisioning, management, and scaling of applications. OpenShift extends Kubernetes with additional features like integrated developer tools, a web console, monitoring, and additional security features, making it easier for developers and operations teams to develop, deploy, and manage applications consistently across various environments. It supports multiple languages and frameworks, streamlining the development process and facilitating DevOps practices.\nAs Openshift is build on top of Kubernetes, lets discuss Kubernetes briefly as well. Kubernetes simplifies Mosquitto broker deployment by providing automated scaling, and easy updates. Our main objective to offer Kubernetes support for Mosquitto to add support for manual scaling, automated scaling, easier deployment and orchestration of Mosquitto resources and of course reaching a wider audience by giving access to various tech stacks. Its container orchestration streamlines management and ensures high availability, making it ideal for IoT and real-time messaging applications. Kubernetes abstracts infrastructure complexities, allowing you to focus on building robust MQTT services efficiently.\nKubernetes, the go-to solution for container orchestration, offers a streamlined approach to deploying and managing applications. In this article, we'll explore some of the tools that we would be using to deploy Kubernetes setup in different versions of Mosquitto deployment."),(0,a.kt)("p",null,"Different Versions of Mosquitto Configuration deployment for Openshift:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"High Availability (3 -Mosquitto broker, 1 Management-Center and support to add further brokers manually)"),(0,a.kt)("li",{parentName:"ul"},"High Availability with Autoscaling (1 Management Center and on-demand Mosquitto brokers)")),(0,a.kt)("p",null,"Tools we would be discussing here are as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Helm Charts (For all versions)"),(0,a.kt)("li",{parentName:"ul"},"Openshift OKD")),(0,a.kt)("h3",c({},{id:"helm-charts"}),"Helm Charts"),(0,a.kt)("p",null,"Helm is a package manager for Kubernetes that simplifies application deployment, management, and scaling. Helm charts are predefined packages that encapsulate an application's configuration, dependencies, and runtime requirements. These charts allow you to deploy complex applications like the Mosquitto broker effortlessly. You can refer to further details about helm charts on the official documentation page. A simple helm charts deployment could be something like this:\n",(0,a.kt)("inlineCode",{parentName:"p"},"helm install my-mosquitto ./mosquitto-chart")),(0,a.kt)("h3",c({},{id:"openshift-okd"}),"Openshift OKD"),(0,a.kt)("p",null,"OKD is the Community Distribution of Kubernetes that powers Red Hat OpenShift. Essentially, it's the open-source version of OpenShift, providing a similar container platform built around Docker containers orchestrated and managed by Kubernetes on a foundation of Red Hat Enterprise Linux. OKD integrates the innovations of the Kubernetes community with additional features and tools to create a more comprehensive, enterprise-ready platform for building, deploying, and managing containerized applications. It offers developers and operators a secure and scalable cloud application platform, including a rich set of command-line tools, a web console, and multi-tenancy support, without tying them to a specific cloud provider. OKD aims to simplify the DevOps process by providing a unified platform that accelerates the development lifecycle while maintaining security and stability."),(0,a.kt)("h3",c({},{id:"further-common-kubernetes-concepts-that-we-would-using-in-this-setup"}),"Further common Kubernetes concepts that we would using in this setup:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Deployments (MMC and HA)"),(0,a.kt)("li",{parentName:"ul"},"Statefulsets (Mosquitto)"),(0,a.kt)("li",{parentName:"ul"},"Services (Mosquitto, MMC and HA)")),(0,a.kt)("h3",c({},{id:"deployments"}),"Deployments:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Use Case"),": Deployments are primarily used for managing stateless applications, where instances of the application can be easily replaced or scaled up/down without regard to their identity."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Scaling"),": Deployments provide easy scaling of applications horizontally by creating or removing replicas."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Rolling Updates"),": Deployments support rolling updates and rollbacks, making it easy to update the application to a new version or configuration while ensuring zero downtime."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pod Identity"),": Pods managed by Deployments do not have stable network identities or storage. They are disposable, and Kubernetes may reschedule them to different nodes.")),(0,a.kt)("h3",c({},{id:"statefulsets"}),"StatefulSets:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Use Case"),": StatefulSets are designed for managing stateful applications, such as databases, where each pod has a stable and unique identity and may require ordered, sequential scaling or rolling updates."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pod Identity"),": Pods managed by StatefulSets are assigned a stable hostname and storage identity. They are often used for distributed systems where pod identity is critical for operations like failover, sharding, and replication."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Scaling"),": StatefulSets support ordered scaling. You can specify how many replicas you want, and they are created in order, ensuring predictable naming and network identities."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Rolling Updates"),": StatefulSets also support rolling updates, but they are designed to handle the complexity of updating stateful applications while maintaining their unique identities.")),(0,a.kt)("p",null,"In summary, Deployments are suitable for stateless applications, offering easy scaling and rolling updates. StatefulSets, on the other hand, are designed for stateful applications that require stable identities and predictable, ordered scaling. The choice between the two depends on the specific requirements of your application. StatefulSets are essential for scenarios like running databases in Kubernetes, while Deployments are more suitable for typical web services and microservices."),(0,a.kt)("h3",c({},{id:"services"}),"Services"),(0,a.kt)("p",null,'In Kubernetes, a "Service" is an abstraction that defines a logical set of pods and a policy by which to access them. It acts as a stable endpoint for communication, allowing other services or external users to interact with applications running within a Kubernetes cluster without needing to be aware of the specific details of how those applications are deployed or scaled.'),(0,a.kt)("p",null,"Here are the key aspects of Kubernetes Services:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Load Balancing"),": Services provide load balancing across a set of pods. They ensure that network traffic is distributed fairly and efficiently among the pods that belong to the service. This load balancing is crucial for high availability and scalability.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Stable Endpoint"),": Each service is assigned a stable IP address or DNS name, which doesn't change even if pods come and go due to scaling or failures. This stable endpoint simplifies the process of connecting to the application.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Label-Based Selection"),": Services select pods based on labels and label selectors, making it easy to specify which pods should be part of the service. This label-based selection allows dynamic membership management."),(0,a.kt)("h4",c({parentName:"li"},{id:"types-of-services"}),"Types of Services:")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"ClusterIP"),": The default service type, accessible only within the cluster.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"NodePort"),": Exposes the service on each node's IP at a static port on the node. This makes the service accessible externally at the specified port.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"LoadBalancer"),": Provides an external IP address that routes traffic to the service. This is primarily used when running Kubernetes in a cloud environment that supports load balancers.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"ExternalName"),": Maps the service to a DNS name. It doesn't create a cluster IP or load balancer. It's used to make services accessible as external names, often pointing to resources outside the cluster.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Service Discovery"),": Services enable easy service discovery within the Kubernetes cluster. Other pods or services can discover and connect to the service using its DNS name or IP address.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Headless Service"),': You can create a "headless" service, which doesn\'t provide a cluster IP but instead allows direct DNS-based communication with individual pods, useful for certain specialized use cases like StatefulSets.'))),(0,a.kt)("p",null,"Kubernetes Services are a fundamental component for building scalable and resilient applications within a cluster. They abstract the network and routing complexities, allowing developers and operators to focus on the application logic while ensuring reliable communication and load distribution.\nWe would be using different services for different types of applications:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Headless Service (Mosquitto)"),(0,a.kt)("li",{parentName:"ul"},"NodePort: (MMC and HA)")))}y.isMDXComponent=!0}}]);