"use strict";(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[89599],{3905:(e,t,s)=>{s.d(t,{Zo:()=>h,kt:()=>p});var a=s(67294);function l(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}function i(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,a)}return s}function n(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?i(Object(s),!0).forEach((function(t){l(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):i(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}function o(e,t){if(null==e)return{};var s,a,l=function(e,t){if(null==e)return{};var s,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)s=i[a],t.indexOf(s)>=0||(l[s]=e[s]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)s=i[a],t.indexOf(s)>=0||Object.prototype.propertyIsEnumerable.call(e,s)&&(l[s]=e[s])}return l}var r=a.createContext({}),c=function(e){var t=a.useContext(r),s=t;return e&&(s="function"==typeof e?e(t):n(n({},t),e)),s},h=function(e){var t=c(e.components);return a.createElement(r.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var s=e.components,l=e.mdxType,i=e.originalType,r=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),d=c(s),p=l,k=d["".concat(r,".").concat(p)]||d[p]||u[p]||i;return s?a.createElement(k,n(n({ref:t},h),{},{components:s})):a.createElement(k,n({ref:t},h))}));function p(e,t){var s=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=s.length,n=new Array(i);n[0]=d;var o={};for(var r in t)hasOwnProperty.call(t,r)&&(o[r]=t[r]);o.originalType=e,o.mdxType="string"==typeof e?e:l,n[1]=o;for(var c=2;c<i;c++)n[c]=s[c];return a.createElement.apply(null,n)}return a.createElement.apply(null,s)}d.displayName="MDXCreateElement"},52594:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>m,contentTitle:()=>p,default:()=>f,frontMatter:()=>d,metadata:()=>k,toc:()=>v});var a=s(3905),l=Object.defineProperty,i=Object.defineProperties,n=Object.getOwnPropertyDescriptors,o=Object.getOwnPropertySymbols,r=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,h=(e,t,s)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,u=(e,t)=>{for(var s in t||(t={}))r.call(t,s)&&h(e,s,t[s]);if(o)for(var s of o(t))c.call(t,s)&&h(e,s,t[s]);return e};const d={id:"mqtt-packets-overview",title:"MQTT Packets",sidebar_label:"MQTT Packets"},p="CONNECT",k={unversionedId:"mqtt-packets-overview",id:"version-2.1/mqtt-packets-overview",title:"MQTT Packets",description:"CONNECT PACKAGE",source:"@site/mosquitto_versioned_docs/version-2.1/mqtt-packets-overview.md",sourceDirName:".",slug:"/mqtt-packets-overview",permalink:"/mosquitto/mqtt-packets-overview",draft:!1,tags:[],version:"2.1",frontMatter:{id:"mqtt-packets-overview",title:"MQTT Packets",sidebar_label:"MQTT Packets"},sidebar:"someSidebar",previous:{title:"Release Notes",permalink:"/mosquitto/release-notes"},next:{title:"MQTT Vocabulary",permalink:"/mosquitto/mqtt-vocabulary"}},m={},v=[{value:"clientId:",id:"clientid",level:3},{value:"v.3.1.1:",id:"v311",level:2},{value:"cleanSession:",id:"cleansession",level:3},{value:"All subscriptions.",id:"all-subscriptions",level:4},{value:"cleanSession + persistentSession:",id:"cleansession--persistentsession",level:3},{value:"persistentSession:",id:"persistentsession",level:3},{value:"lastWill:",id:"lastwill",level:3},{value:"lastWillMessage:",id:"lastwillmessage",level:4},{value:"lastWillTopic:",id:"lastwilltopic",level:4},{value:"lastWillQoS:",id:"lastwillqos",level:4},{value:"lastWillRetain:",id:"lastwillretain",level:4},{value:"keepAlive:",id:"keepalive",level:3},{value:"v.5.0:",id:"v50",level:2},{value:"sessionExpiryInterval:",id:"sessionexpiryinterval",level:3},{value:"cleanStart:",id:"cleanstart",level:3},{value:"All subscriptions.",id:"all-subscriptions-1",level:4},{value:"cleanStart + persistentSession:",id:"cleanstart--persistentsession",level:3},{value:"persistentSession:",id:"persistentsession-1",level:3},{value:"username / password:",id:"username--password",level:3},{value:"lastWill:",id:"lastwill-1",level:3},{value:"lastWillMessage:",id:"lastwillmessage-1",level:4},{value:"lastWillTopic:",id:"lastwilltopic-1",level:4},{value:"lastWillQoS:",id:"lastwillqos-1",level:4},{value:"lastWillRetain:",id:"lastwillretain-1",level:4},{value:"keepAlive:",id:"keepalive-1",level:3},{value:"v.3.1.1",id:"v311-1",level:2},{value:"packetId:",id:"packetid",level:3},{value:"topicName:",id:"topicname",level:3},{value:"QoS:",id:"qos",level:3},{value:"QoS0 is the minimum QoS level:",id:"qos0-is-the-minimum-qos-level",level:4},{value:"Level 1 QoS guarantees the delivery of a message to the receiver at least once.",id:"level-1-qos-guarantees-the-delivery-of-a-message-to-the-receiver-at-least-once",level:4},{value:"How the acknowledgment works",id:"how-the-acknowledgment-works",level:5},{value:"QoS level 2 guarantees each message is received exactly once.",id:"qos-level-2-guarantees-each-message-is-received-exactly-once",level:3},{value:"v.3.1.:",id:"v31",level:2},{value:"retainFlag:",id:"retainflag",level:3},{value:"Payload:",id:"payload",level:3},{value:"dupFlag:",id:"dupflag",level:3},{value:"v.5.0:",id:"v50-1",level:2},{value:"messageExpiryInterval:",id:"messageexpiryinterval",level:3},{value:"retainFlag:",id:"retainflag-1",level:3},{value:"Payload:",id:"payload-1",level:3},{value:"dupFlag:",id:"dupflag-1",level:3},{value:"packetId:",id:"packetid-1",level:2},{value:"subscriptions:",id:"subscriptions",level:2},{value:"packetId:",id:"packetid-2",level:2},{value:"packetId:",id:"packetid-3",level:2},{value:"List of topics:",id:"list-of-topics",level:2}],b={toc:v};function f(e){var t,l=e,{components:h}=l,d=((e,t)=>{var s={};for(var a in e)r.call(e,a)&&t.indexOf(a)<0&&(s[a]=e[a]);if(null!=e&&o)for(var a of o(e))t.indexOf(a)<0&&c.call(e,a)&&(s[a]=e[a]);return s})(l,["components"]);return(0,a.kt)("wrapper",(t=u(u({},b),d),i(t,n({components:h,mdxType:"MDXLayout"}))),(0,a.kt)("h1",u({},{id:"connect"}),"CONNECT"),(0,a.kt)("p",null,"CONNECT PACKAGE"),(0,a.kt)("p",null,"Except clientId there are differences between v.3.1.1 and .v.5.0 except clientId:"),(0,a.kt)("h3",u({},{id:"clientid"}),"clientId:"),(0,a.kt)("p",null,"The clientId identifies each MQTT client that is connecting to an MQTT broker."),(0,a.kt)("h2",u({},{id:"v311"}),"v.3.1.1:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(11816).Z,width:"600",height:"400"})),(0,a.kt)("h3",u({},{id:"cleansession"}),"cleanSession:"),(0,a.kt)("p",null,"cleanSession = 0\nIn this case the server resumes communication with the client based on the state of the current session (the session is identified by the clientId)."),(0,a.kt)("p",null,"If there is no earlier session, the broker must create a new session."),(0,a.kt)("p",null,"In case of a connection disconnectiong, the broker must store:"),(0,a.kt)("p",null,"Whether the session exists. Even though a topic has no subscriptions and therefore the session would be without real use."),(0,a.kt)("h4",u({},{id:"all-subscriptions"}),"All subscriptions."),(0,a.kt)("p",null,"All QoS1 or QoS2 messages that haven't been confirmed by the client yet."),(0,a.kt)("p",null,"cleanSession = 1"),(0,a.kt)("p",null,"In this case the broker discards any previous sessions and opens a new one."),(0,a.kt)("h3",u({},{id:"cleansession--persistentsession"}),"cleanSession + persistentSession:"),(0,a.kt)("p",null,"To enable a persistent session, the client must set the cleanSession=false."),(0,a.kt)("h3",u({},{id:"persistentsession"}),"persistentSession:"),(0,a.kt)("p",null,"All information a client has not been received from the broker since the last connection will be saved on the broker to ensure the client does not miss out on any messages whilst without connection. If the persistent session is active."),(0,a.kt)("p",null,"Read more about cleanSession and persistentSession ",(0,a.kt)("a",u({parentName:"p"},{href:"./mqtt#connect"}),"here"),"."),(0,a.kt)("h3",u({},{id:"lastwill"}),"lastWill:"),(0,a.kt)("p",null,"The lastWill message is sent by the broker on behalf of the client when a disconnect occurs without a DISCONNECT packet before the actual break-off."),(0,a.kt)("p",null,"Even though there is no lastWill command part of the packet, we speak about lastWill in general as there are various commands that define and specify how the lastWillMessage will be sent."),(0,a.kt)("h4",u({},{id:"lastwillmessage"}),"lastWillMessage:"),(0,a.kt)("p",null,"The lastWill message is sent by the broker on behalf of the client when a disconnect occurs without a DISCONNECT packet before the actual break-off. So it\u2019s a connection break-off without an earlier announcement."),(0,a.kt)("p",null,"The lastWill notifies connected clients when this happens."),(0,a.kt)("h4",u({},{id:"lastwilltopic"}),"lastWillTopic:"),(0,a.kt)("p",null,"The MQTT topic that clients subscribed to, who will receive the lastWill message."),(0,a.kt)("h4",u({},{id:"lastwillqos"}),"lastWillQoS:"),(0,a.kt)("p",null,"If the lastWillQoS is set to 1 or 2, the message will be sent with this QoS level."),(0,a.kt)("h4",u({},{id:"lastwillretain"}),"lastWillRetain:"),(0,a.kt)("p",null,"Whenever the connection disconnects, the lastWillMessage will be sent within the keepAlive interval (+ half of the interval - see keepAlive) to all subscribers. But also to subscribers that are newly assigned to the topic."),(0,a.kt)("p",null,"As the client reconnects and publishes a message all subscribers will know that the client is connected again."),(0,a.kt)("h3",u({},{id:"keepalive"}),"keepAlive:"),(0,a.kt)("p",null,"A maximum length of the time interval is defined for each client request to connect with the broker (e.g. 120 seconds). Within the interval, it's ok that the client and broker do not transmit messages. After this interval, the client must send a so-called PING Request packet."),(0,a.kt)("h2",u({},{id:"v50"}),"v.5.0:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(45818).Z,width:"6614",height:"4409"})),(0,a.kt)("h3",u({},{id:"sessionexpiryinterval"}),"sessionExpiryInterval:"),(0,a.kt)("p",null,"Whenever a session ExpiryInterval is set (e.g. 60) a cleanStart is automatically set to \u201c0\u201d."),(0,a.kt)("p",null,"With a sessionExpiryInterval active the sessionState will be saved immediately after the keepAlive runs out (e.g. 120 plus half of the keepAlive - that would be 60 seconds in this case).The sessionState is safed for the amount of time set (in this case 60 seconds)."),(0,a.kt)("p",null,"sessionExpiryInterval is solving the problem that you don\u2019t need to send anther CONNECT packet including cleanSession=1 (MQTT v.3.1.1) to discard the session after set it retained."),(0,a.kt)("h3",u({},{id:"cleanstart"}),"cleanStart:"),(0,a.kt)("p",null,"cleanStart = 0"),(0,a.kt)("p",null,"In this case the server resumes communication with the client based on the state of the current session (the session is identified by the clientId)."),(0,a.kt)("p",null,"If there is no earlier session, the broker must create a new session."),(0,a.kt)("p",null,"In case of a connection disconnectiong, the broker must store:"),(0,a.kt)("p",null,"Whether the session exists. Even though a topic has no subscriptions and therefore the session would be without real use."),(0,a.kt)("h4",u({},{id:"all-subscriptions-1"}),"All subscriptions."),(0,a.kt)("p",null,"All QoS1 or QoS2 messages that haven't been confirmed by the client yet."),(0,a.kt)("p",null,"cleanStart = 1"),(0,a.kt)("p",null,"In this case the broker discards any previous sessions and opens a new one."),(0,a.kt)("h3",u({},{id:"cleanstart--persistentsession"}),"cleanStart + persistentSession:"),(0,a.kt)("p",null,"To enable a persistent session, the client must set the cleanSession=false."),(0,a.kt)("h3",u({},{id:"persistentsession-1"}),"persistentSession:"),(0,a.kt)("p",null,"All information a client has not been received from the broker since the last connection will be saved on the broker to ensure the client does not miss out on any messages whilst without connection. If the persistent session is active."),(0,a.kt)("p",null,"Read more about persistentSession ",(0,a.kt)("a",u({parentName:"p"},{href:"./mqtt#connect"}),"here"),"."),(0,a.kt)("h3",u({},{id:"username--password"}),"username / password:"),(0,a.kt)("p",null,"MQTT can forward and handle username and password within a sent packet. Please be aware that the password is sent as plain text whenever a packet is not encrypted or hashed. Username/password is only for authorization purposes. To keep your connection safe make sure to encrypt your connection."),(0,a.kt)("h3",u({},{id:"lastwill-1"}),"lastWill:"),(0,a.kt)("p",null,"The lastWill message is sent by the broker on behalf of the client when a disconnect occurs without a DISCONNECT packet before the actual break-off."),(0,a.kt)("p",null,"Even though there is no lastWill command part of the packet, we speak about lastWill in general as there are various commands that define and specify how the lastWillMessage will be sent."),(0,a.kt)("h4",u({},{id:"lastwillmessage-1"}),"lastWillMessage:"),(0,a.kt)("p",null,"The lastWill message is sent by the broker on behalf of the client when a disconnect occurs without a DISCONNECT packet before the actual break-off. So it\u2019s a connection break-off without an earlier announcement."),(0,a.kt)("p",null,"The lastWill notifies connected clients when this happens."),(0,a.kt)("h4",u({},{id:"lastwilltopic-1"}),"lastWillTopic:"),(0,a.kt)("p",null,"The MQTT topic that clients subscribed to, who will receive the lastWill message."),(0,a.kt)("h4",u({},{id:"lastwillqos-1"}),"lastWillQoS:"),(0,a.kt)("p",null,"If the lastWillQoS is set to 1 or 2, the message will be sent with this QoS level."),(0,a.kt)("h4",u({},{id:"lastwillretain-1"}),"lastWillRetain:"),(0,a.kt)("p",null,"Whenever the connection disconnects, the lastWillMessage will be sent within the keepAlive interval (+ half of the interval - see keepAlive) to all subscribers. But also to subscribers that are newly assigned to the topic."),(0,a.kt)("p",null,"As the client reconnects and publishes a message all subscribers will know that the client is connected again."),(0,a.kt)("h3",u({},{id:"keepalive-1"}),"keepAlive:"),(0,a.kt)("p",null,"A maximum length of the time interval is defined for each client request to connect with the broker (e.g. 120 seconds). Within the interval, it's ok that the client and broker do not transmit messages. After this interval, the client must send a so-called PING Request packet."),(0,a.kt)("h1",u({},{id:"pingreq"}),"PINGREQ"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(7350).Z,width:"600",height:"203"})),(0,a.kt)("p",null,"The broker must respond with a PING Response (PINGRESP)."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(96713).Z,width:"600",height:"203"})),(0,a.kt)("p",null,'If a participant is not responding (PINGRESP) - called a "half-open connection", keepAlive takes action. Within the specific time interval plus another half of the very same interval, the broker or client must disconnect. When this happens, the broker sends the lastWill and testament message. As a client is online again whilst a half-open connection is still kept on by the broker, the broker simply performs a client take-over.'),(0,a.kt)("h1",u({},{id:"connack"}),"CONNACK"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(35153).Z,width:"600",height:"280"})),(0,a.kt)("p",null,"The broker - in return for the CONNECT package - responds by sending a so-called CONNACK packet (Acknowledge connection request) and the CONNACK return code."),(0,a.kt)("p",null,"If the client sets cleanSession=false (no cleanSession / persistentSession), the broker must set the sessionPresent=true in the CONNACK packet."),(0,a.kt)("p",null,"If the client sets cleanSession=true, the broker must respond whether a sessionState (data about the session before a disconnect happened) is stored or not. For the case that there has been a sessionState stored the CONNACK replies with 1. If not, it replies with 0."),(0,a.kt)("p",null,"The return code indicates whether the reply (sessionPresent) is correct or not. ",(0,a.kt)("a",u({parentName:"p"},{href:"./mosquitto-manpage-pub#exit-status"}),"Here")," you can find a list of all exit statuses (return codes)."),(0,a.kt)("h1",u({},{id:"publish-packet"}),"PUBLISH PACKET"),(0,a.kt)("p",null,"Except clientId there are differences between v.3.1.1 and .v.5.0 except packetId, topicName and QoS:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(80460).Z,width:"600",height:"310"})),(0,a.kt)("h2",u({},{id:"v311-1"}),"v.3.1.1"),(0,a.kt)("h3",u({},{id:"packetid"}),"packetId:"),(0,a.kt)("p",null,"Identifies a message."),(0,a.kt)("h3",u({},{id:"topicname"}),"topicName:"),(0,a.kt)("p",null,"The broker will send the message to all subscribers authorized subscribers that subscribed to this specific topicName."),(0,a.kt)("p",null,"The topic is set using a simple string."),(0,a.kt)("p",null,'Topics are treated hierarchically. To delimiter, a slash "/" symbolizes a separation, e.g. \u201c/rooms/room1\u201d.'),(0,a.kt)("p",null,"A subscriber must know about the topic name to subscribe to it."),(0,a.kt)("h3",u({},{id:"qos"}),"QoS:"),(0,a.kt)("p",null,"The QoS (Quality of Service) defines a certain level of service that enables the publisher to make sure that the certainty and quantity of a subscriber receiving a sent message equal the importance to receive the message at all, plus whether to receive the message only once."),(0,a.kt)("p",null,"Also, a subscriber can set a QoS, defining the importance to receive every message, and whether to accept one message multiple times or not."),(0,a.kt)("p",null,"There are three levels available:"),(0,a.kt)("h4",u({},{id:"qos0-is-the-minimum-qos-level"}),"QoS0 is the minimum QoS level:"),(0,a.kt)("p",null,"The broker/client is delivering the message only once, without confirmation."),(0,a.kt)("p",null,"There is no guarantee that the message sent has been sent to the subscriber. The recipient on the other end does not acknowledge the receipt. Neither is the acknowledgment stored."),(0,a.kt)("p",null,'The QoS0 - level is often referred to be the "fire and forget"-level.'),(0,a.kt)("p",null,"Using the minimum level of quality can make sense, as MQTT requires to be lightweight, bandwidth-saving, and super fast delivery. QoS0 does not require as many resources from the broker."),(0,a.kt)("h4",u({},{id:"level-1-qos-guarantees-the-delivery-of-a-message-to-the-receiver-at-least-once"}),"Level 1 QoS guarantees the delivery of a message to the receiver at least once."),(0,a.kt)("p",null,'However, "at least once" means that a single message can be transmitted to the receiver more than once. Thus, this QoS level ensures that a message reaches its subscribers, but does not care about how many times that might be the case.'),(0,a.kt)("p",null,"To achieve this behavior a sender stores a message in a queue until it receives an acknowledgment from the receiver. Within a defined time, the sender sends the message again and again."),(0,a.kt)("p",null,"Remember: Publishers are always message-senders, and the broker is (not only a data receiver but) also a sender when transmitting messages to\nsubscribers. "),(0,a.kt)("p",null,"Nevertheless, the QoS levels are always set by the clients (the publishers as well as the subscribers) and not by the broker. The broker simply supports all 3 levels and caters to each client and topic individually."),(0,a.kt)("p",null,"Despite the advantage of guaranteed delivery, QoS1 also entails a disadvantage. It demands and occupies more resources on the sender \u0301s side."),(0,a.kt)("p",null,"On the other hand, you really should think about the disadvantages, as QoS1 occupies resources."),(0,a.kt)("p",null,"Whether to use QoS1 or another level is a design choice and depends on your use case."),(0,a.kt)("h5",u({},{id:"how-the-acknowledgment-works"}),"How the acknowledgment works"),(0,a.kt)("p",null,"A subscriber must send a so-called PUBACK packet (publish acknowledge) to the broker when the broker demands acknowledgment."),(0,a.kt)("p",null,"If the subscriber does not send a PUBACK, the broker continues to send PUBLISH packets. If the broker sends the PUBLISH packet again, even the second time, it contains a duplicate flag (DUP)."),(0,a.kt)("p",null,"The packetId enables the broker to match the PUBLISH packet and the PUBACK packet. And the packetId is free and reusable again."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(48360).Z,width:"600",height:"219"})),(0,a.kt)("p",null,"The publishing client must store all QoS1 messages which were sent to the broker but which were not (yet) acknowledged/confirmed by the broker."),(0,a.kt)("p",null,"The broker must store:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The information that the session still exists."),(0,a.kt)("li",{parentName:"ul"},"All subscriptions a client subscribed to."),(0,a.kt)("li",{parentName:"ul"},"The QoS1 messages waiting to be sent to the client."),(0,a.kt)("li",{parentName:"ul"},"The QoS1 message, will message and will delay the interval that the client received, but without confirmation.")),(0,a.kt)("h3",u({},{id:"qos-level-2-guarantees-each-message-is-received-exactly-once"}),"QoS level 2 guarantees each message is received exactly once."),(0,a.kt)("p",null,"To do as pleased the broker transmits the PUBLISH packet as usual. But the recipient must respond with a PUBREC (Publish received)."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(24504).Z,width:"600",height:"219"})),(0,a.kt)("p",null,"After that happens, the broker sends another request, the PUBREL (Publish release), to which the recipient must respond again."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(69968).Z,width:"600",height:"219"})),(0,a.kt)("p",null,"The publishing client must store all QoS2 messages sent to the broker without confirmation from the broker."),(0,a.kt)("p",null,"The broker must store:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The information that the session still exists."),(0,a.kt)("li",{parentName:"ul"},"All subscriptions a client subscribed to."),(0,a.kt)("li",{parentName:"ul"},"The QoS2 messages waiting to be sent to the client."),(0,a.kt)("li",{parentName:"ul"},"The QoS2 message, will message and will delay the interval that the client received, but without confirmation.")),(0,a.kt)("p",null,"To discard all stored states and answers a so-called PUBCOMP packet (Publish complete) is sent. That's the end of the QoS2 order of events."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(98505).Z,width:"600",height:"219"})),(0,a.kt)("p",null,"Until a PUBCOMP is sent, the broker stores a reference of the original PUBLISH packets packetId."),(0,a.kt)("p",null,"The packet and packetId become reusable again."),(0,a.kt)("h2",u({},{id:"v31"}),"v.3.1.:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(80460).Z,width:"600",height:"310"})),(0,a.kt)("h3",u({},{id:"retainflag"}),"retainFlag:"),(0,a.kt)("p",null,"In many cases, a device can not wait until the next time the publisher provides information sending a message."),(0,a.kt)("p",null,"A sensor of a car door tells whether the door is open or closed. As the door is used very infrequently, including a retained flag makes sense."),(0,a.kt)("p",null,"Without a retained flag set (retainFlag=false), you must wait for the next time the door is opened or closed to find out about the status."),(0,a.kt)("p",null,"With retained messages (retainFlag=true), you immediately find out, because the retained message gives you the last status."),(0,a.kt)("p",null,"A retained message safes the last known value of the topic."),(0,a.kt)("p",null,"It's only possible to save up to one retained message, equal to one retained value."),(0,a.kt)("p",null,"The retainFlag identifies a message to be a retained message. To identify the message the packetId is used."),(0,a.kt)("h3",u({},{id:"payload"}),"Payload:"),(0,a.kt)("p",null,"The actual content of a message is the content of a payload. Whether it's a .mp3-file or .mp4-file, a picture, or a video. Up to 256MB. The payload does not encrypt the content. The broker simply delivers what the publisher inserted into the payload."),(0,a.kt)("h3",u({},{id:"dupflag"}),"dupFlag:"),(0,a.kt)("p",null,"A dupFlag indicates the duplicate of a message."),(0,a.kt)("h2",u({},{id:"v50-1"}),"v.5.0:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(44258).Z,width:"6614",height:"3659"})),(0,a.kt)("h3",u({},{id:"messageexpiryinterval"}),"messageExpiryInterval:"),(0,a.kt)("p",null,"With a sessionExpiryInterval active the sessionState will be saved immediately after the keepAlive (set in the CONNECT packet) runs out (e.g. 120 plus half of the keepAlive - that would be 60 seconds in this case).The sessionState is safed for the amount of time set (in this case 60 seconds)."),(0,a.kt)("h3",u({},{id:"retainflag-1"}),"retainFlag:"),(0,a.kt)("p",null,"In many cases, a device can not wait until the next time the publisher provides information sending a message."),(0,a.kt)("p",null,"A sensor of a car door tells whether the door is open or closed. As the door is used very infrequently, including a retained flag makes sense."),(0,a.kt)("p",null,"Without a retained flag set (retainFlag=false), you must wait for the next time the door is opened or closed to find out about the status."),(0,a.kt)("p",null,"With retained messages (retainFlag=true), you immediately find out, because the retained message gives you the last status."),(0,a.kt)("p",null,"A retained message safes the last known value of the topic."),(0,a.kt)("p",null,"It's only possible to save up to one retained message, equal to one retained value."),(0,a.kt)("p",null,"The retainFlag identifies a message to be a retained message. To identify the message the packetId is used."),(0,a.kt)("h3",u({},{id:"payload-1"}),"Payload:"),(0,a.kt)("p",null,"The actual content of a message is the content of a payload. Whether it's a .mp3-file or .mp4-file, a picture, or a video. Up to 256MB. The payload does not encrypt the content. The broker simply delivers what the publisher inserted into the payload."),(0,a.kt)("h3",u({},{id:"dupflag-1"}),"dupFlag:"),(0,a.kt)("p",null,"A dupFlag indicates the duplicate of a message."),(0,a.kt)("h1",u({},{id:"subscribe"}),"SUBSCRIBE"),(0,a.kt)("p",null,"SUBSCRIBE Packet"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(18207).Z,width:"600",height:"373"})),(0,a.kt)("h2",u({},{id:"packetid-1"}),"packetId:"),(0,a.kt)("p",null,"Unique packet identifier."),(0,a.kt)("h2",u({},{id:"subscriptions"}),"subscriptions:"),(0,a.kt)("p",null,"Each subscription consists of a topic and a QoS level."),(0,a.kt)("h1",u({},{id:"suback-packet"}),"SUBACK Packet"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(1373).Z,width:"600",height:"286"})),(0,a.kt)("h2",u({},{id:"packetid-2"}),"packetId:"),(0,a.kt)("p",null,"Unique packet identifier."),(0,a.kt)("p",null,"The broker sends one return code for each topic/QoS-pair that it receives in the SUBSCRIBE packet."),(0,a.kt)("p",null,"The return codes can be:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"0 - Success-Maximum QoS0"),(0,a.kt)("li",{parentName:"ul"},"1 - Success-Maximum QoS1"),(0,a.kt)("li",{parentName:"ul"},"2 - Success-Maximum QoS2"),(0,a.kt)("li",{parentName:"ul"},"128 - Failure")),(0,a.kt)("h1",u({},{id:"unsubscribe"}),"UNSUBSCRIBE"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"mqttProtocol",src:s(99871).Z,width:"600",height:"286"})),(0,a.kt)("h2",u({},{id:"packetid-3"}),"packetId:"),(0,a.kt)("p",null,"Unique packet identifier."),(0,a.kt)("h2",u({},{id:"list-of-topics"}),"List of topics:"),(0,a.kt)("p",null,"The UNSUBSCRIBE packet also contains the topics you want to unsubscribe from."),(0,a.kt)("p",null,"After the packet is sent, the broker unsubscribes the client from the topics."))}f.isMDXComponent=!0},35153:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/CONNACK-01d74fa06e61abb23ab6c3136b9ee4f9.png"},11816:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/CONNECT-5a980387b5072c46485bb7e5846a778e.png"},45818:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/CONNECT_v.5.0-8c5656742c3f8afd987b95cc3a9eb6bb.png"},7350:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/PINGREQ-3f59bf01166e56a43e22c0a329a2ac23.png"},96713:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/PINGRESP-015856310847e3d4f1d6765f307f3b43.png"},48360:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/PUBACK-006003278fa5905ddb879b54cbb6f378.png"},98505:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/PUBCOMP-c6e2ea70b25e2fa1ce2a910dccb8be7b.png"},80460:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/PUBLISH-e0d3503e716c9661f59b1704ad9cd154.png"},44258:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/PUBLISH_v.5.0-3d6c82cb0f4df38d89551459c7652bdb.png"},24504:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/PUBREC-e13f60c51521081b2905ecc1003ef1bb.png"},69968:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/PUBREL-ed79ff6635f8562dda6dc0fbd268f679.png"},1373:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/SUBACK-53a4bd04acbd26f7aaf37a9888f04f95.png"},18207:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/SUBSCRIBE-85c834fcaaa6eed0eb6bd0b86a9a96fa.png"},99871:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/UNSUBSCRIBE-bafcc7ea712e85f35476223766cd5572.png"}}]);