"use strict";(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[68601],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=i,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(f,r(r({ref:t},c),{},{components:n})):a.createElement(f,r({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var u=2;u<o;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},85685:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>m,default:()=>k,frontMatter:()=>d,metadata:()=>f,toc:()=>g});var a=n(3905),i=Object.defineProperty,o=Object.defineProperties,r=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,u=Object.prototype.propertyIsEnumerable,c=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,p=(e,t)=>{for(var n in t||(t={}))l.call(t,n)&&c(e,n,t[n]);if(s)for(var n of s(t))u.call(t,n)&&c(e,n,t[n]);return e};const d={id:"introduction",title:"Introduction",sidebar_label:"Introduction"},m=void 0,f={unversionedId:"kubernetes/introduction",id:"version-2.7/kubernetes/introduction",title:"Introduction",description:"Cedalo offers different Mosquitto broker configurations that you can deploy starting from single-node solutions to High Availability Cluster using docker. We also now introduce the kubernetes support for Mosquitto. Kubernetes simplifies Mosquitto broker deployment by providing automated scaling, and easy updates. Our main objective is to offer Kubernetes support for Mosquitto to add support for manual scaling, automated scaling, easier deployment and orchestration of Mosquitto resources and of course reaching a wider audience by giving access to various tech stacks. Its container orchestration streamlines management and ensures high availability, making it ideal for IoT and real-time messaging applications. Kubernetes abstracts infrastructure complexities, allowing you to focus on building robust MQTT services efficiently.",source:"@site/mosquitto_versioned_docs/version-2.7/kubernetes/introduction.md",sourceDirName:"kubernetes",slug:"/kubernetes/introduction",permalink:"/mosquitto/kubernetes/introduction",draft:!1,tags:[],version:"2.7",frontMatter:{id:"introduction",title:"Introduction",sidebar_label:"Introduction"},sidebar:"someSidebar",previous:{title:"Glossary",permalink:"/mosquitto/MQTT/mqtt-glossary"},next:{title:"Single Node",permalink:"/mosquitto/kubernetes/single-node"}},h={},g=[{value:"Helm Charts",id:"helm-charts",level:3},{value:"Minikube:",id:"minikube",level:3},{value:"Kubeadm",id:"kubeadm",level:3},{value:"Calico",id:"calico",level:3},{value:"Further common kubernetes concepts that we would using in this setup:",id:"further-common-kubernetes-concepts-that-we-would-using-in-this-setup",level:3},{value:"Deployments:",id:"deployments",level:3},{value:"StatefulSets:",id:"statefulsets",level:3},{value:"Services",id:"services",level:3}],b={toc:g};function k(e){var t,n=e,{components:i}=n,c=((e,t)=>{var n={};for(var a in e)l.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&s)for(var a of s(e))t.indexOf(a)<0&&u.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=p(p({},b),c),o(t,r({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Cedalo offers different Mosquitto broker configurations that you can deploy starting from single-node solutions to High Availability Cluster using docker. We also now introduce the kubernetes support for Mosquitto. Kubernetes simplifies Mosquitto broker deployment by providing automated scaling, and easy updates. Our main objective is to offer Kubernetes support for Mosquitto to add support for manual scaling, automated scaling, easier deployment and orchestration of Mosquitto resources and of course reaching a wider audience by giving access to various tech stacks. Its container orchestration streamlines management and ensures high availability, making it ideal for IoT and real-time messaging applications. Kubernetes abstracts infrastructure complexities, allowing you to focus on building robust MQTT services efficiently.\nKubernetes, the go-to solution for container orchestration, offers a streamlined approach to deploying and managing applications. In this article, we'll explore some of the tools that we would be using to deploy Kubernetes setup in different versions of Mosquitto deployment."),(0,a.kt)("p",null,"Different Versions of Mosquitto Configuration deployment:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Single Node Deployment (1 Management-Center and 1 Mosquitto broker)"),(0,a.kt)("li",{parentName:"ul"},"Multi-node deployment on a single host(3 Mosquitto broker and 1 Management-Center)"),(0,a.kt)("li",{parentName:"ul"},"Multi Node Deployment on different Host - High Availability (3 -Mosquitto broker and 1 Management-Center)"),(0,a.kt)("li",{parentName:"ul"},"Multi-node Deployment - High Availability with Autoscaling (1 Management Center, 1 NFS server, on-demand Mosquitto brokers)")),(0,a.kt)("p",null,"Tools we would be discussing here are as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Helm Charts (For all versions)"),(0,a.kt)("li",{parentName:"ul"},"Minikube (Single node and multi-node on a single host)"),(0,a.kt)("li",{parentName:"ul"},"Kubeadm and Calico(HA and HA with autoscaling)")),(0,a.kt)("h3",p({},{id:"helm-charts"}),"Helm Charts"),(0,a.kt)("p",null,"Helm is a package manager for Kubernetes that simplifies application deployment, management, and scaling. Helm charts are predefined packages that encapsulate an application's configuration, dependencies, and runtime requirements. These charts allow you to deploy complex applications like the Mosquitto broker effortlessly. You can refer to further details about helm charts on the official documentation page. A simple helm charts deployment could like this:\n",(0,a.kt)("inlineCode",{parentName:"p"},"helm install my-mosquitto ./mosquitto-chart")),(0,a.kt)("h3",p({},{id:"minikube"}),"Minikube:"),(0,a.kt)("p",null,"Minikube is a lightweight, local Kubernetes distribution and management tool that allows you to run a single-node Kubernetes cluster on your local development machine. It is designed for local development, testing, and experimentation with Kubernetes without the need for a full-fledged multi-node cluster.\nHere are some key features and benefits of Minikube:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Local Kubernetes Environment"),": Minikube provides a simple and convenient way to create a Kubernetes cluster on your host machine. This local cluster mimics the behavior of a full Kubernetes cluster, allowing you to develop and test applications that you plan to deploy on a production Kubernetes environment."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Ease of Setup"),": Minikube is easy to set up and use. It automates the deployment of a single-node cluster and takes care of many of the complexities of Kubernetes, making it accessible to developers who may not be Kubernetes experts."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Isolation"),": Minikube runs the Kubernetes cluster within a virtual machine or a container (depending on the driver you choose). This isolation ensures that your local cluster doesn't interfere with your machine's primary operating system or other applications.")),(0,a.kt)("h3",p({},{id:"kubeadm"}),"Kubeadm"),(0,a.kt)("p",null,"Kubeadm is a command-line tool in the Kubernetes ecosystem designed to facilitate the process of setting up and bootstrapping a Kubernetes cluster. It's part of the Kubernetes project and serves as a simplified, but highly configurable, tool for initializing and managing a cluster. Kubeadm is particularly useful for quickly deploying Kubernetes clusters for development, testing, or small-scale production environments.Kubeadm is a valuable tool for administrators and operators who need to create and manage Kubernetes clusters quickly and consistently. It abstracts many of the complexities involved in cluster configuration, making it easier to get started with Kubernetes or manage small to medium-sized clusters efficiently."),(0,a.kt)("p",null,"Here are some key features and use cases for kubeadm:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Cluster Initialization"),": Kubeadm automates the process of setting up the control plane components (like the API server, controller manager, and etcd) on the master node. It helps initialize the cluster, so you don't have to configure these components manually."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Node Joining"),": Kubeadm simplifies the process of adding worker nodes to the cluster. This includes generating the necessary authentication tokens and certificates, which makes it easier to scale your cluster."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Cluster Configuration"),": Kubeadm provides sensible default configurations, but it also allows you to customise various aspects of your Kubernetes cluster by specifying configuration files."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Addon Support"),": It has built-in support for deploying common Kubernetes addons, such as the network overlay (CNI) plugin, without manual intervention.")),(0,a.kt)("h3",p({},{id:"calico"}),"Calico"),(0,a.kt)("p",null,"Calico is an open-source networking and network security solution designed for cloud-native environments, particularly for Kubernetes clusters. It provides network connectivity and security for containerized applications and is known for its simplicity, scalability, and robust features."),(0,a.kt)("p",null,"Key features and aspects of Calico include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Network Connectivity"),": Calico enables containerized applications to communicate with each other, both within and across Kubernetes clusters. It sets up the necessary network routes and policies to facilitate this communication."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"BGP-Based Routing"),": Calico uses Border Gateway Protocol (BGP) to route traffic within and between Kubernetes clusters. This approach is highly scalable and flexible, making it suitable for large, complex deployments."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Network Security"),": Calico offers fine-grained network security policies. It allows administrators to define rules for controlling traffic between pods, making it a valuable tool for implementing security and segmentation in Kubernetes environments.")),(0,a.kt)("h3",p({},{id:"further-common-kubernetes-concepts-that-we-would-using-in-this-setup"}),"Further common kubernetes concepts that we would using in this setup:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Deployments (MMC and HA)"),(0,a.kt)("li",{parentName:"ul"},"Statefulsets (Mosquitto)"),(0,a.kt)("li",{parentName:"ul"},"Services (Mosquitto, MMC and HA)")),(0,a.kt)("h3",p({},{id:"deployments"}),"Deployments:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Use Case"),": Deployments are primarily used for managing stateless applications, where instances of the application can be easily replaced or scaled up/down without regard to their identity."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Scaling"),": Deployments provide easy scaling of applications horizontally by creating or removing replicas."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Rolling Updates"),": Deployments support rolling updates and rollbacks, making it easy to update the application to a new version or configuration while ensuring zero downtime."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pod Identity"),": Pods managed by Deployments do not have stable network identities or storage. They are disposable, and Kubernetes may reschedule them to different nodes.")),(0,a.kt)("h3",p({},{id:"statefulsets"}),"StatefulSets:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Use Case"),": StatefulSets are designed for managing stateful applications, such as databases, where each pod has a stable and unique identity and may require ordered, sequential scaling or rolling updates."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pod Identity"),": Pods managed by StatefulSets are assigned a stable hostname and storage identity. They are often used for distributed systems where pod identity is critical for operations like failover, sharding, and replication."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Scaling"),": StatefulSets support ordered scaling. You can specify how many replicas you want, and they are created in order, ensuring predictable naming and network identities."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Rolling Updates"),": StatefulSets also support rolling updates, but they are designed to handle the complexity of updating stateful applications while maintaining their unique identities.")),(0,a.kt)("p",null,"In summary, Deployments are suitable for stateless applications, offering easy scaling and rolling updates. StatefulSets, on the other hand, are designed for stateful applications that require stable identities and predictable, ordered scaling. The choice between the two depends on the specific requirements of your application. StatefulSets are essential for scenarios like running databases in Kubernetes, while Deployments are more suitable for typical web services and microservices."),(0,a.kt)("h3",p({},{id:"services"}),"Services"),(0,a.kt)("p",null,'In Kubernetes, a "Service" is an abstraction that defines a logical set of pods and a policy by which to access them. It acts as a stable endpoint for communication, allowing other services or external users to interact with applications running within a Kubernetes cluster without needing to be aware of the specific details of how those applications are deployed or scaled.'),(0,a.kt)("p",null,"Here are the key aspects of Kubernetes Services:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Load Balancing"),": Services provide load balancing across a set of pods. They ensure that network traffic is distributed fairly and efficiently among the pods that belong to the service. This load balancing is crucial for high availability and scalability.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Stable Endpoint"),": Each service is assigned a stable IP address or DNS name, which doesn't change even if pods come and go due to scaling or failures. This stable endpoint simplifies the process of connecting to the application.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Label-Based Selection"),": Services select pods based on labels and label selectors, making it easy to specify which pods should be part of the service. This label-based selection allows dynamic membership management."),(0,a.kt)("h4",p({parentName:"li"},{id:"types-of-services"}),"Types of Services:")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"ClusterIP"),": The default service type, accessible only within the cluster.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"NodePort"),": Exposes the service on each node's IP at a static port on the node. This makes the service accessible externally at the specified port.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"LoadBalancer"),": Provides an external IP address that routes traffic to the service. This is primarily used when running Kubernetes in a cloud environment that supports load balancers.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"ExternalName"),": Maps the service to a DNS name. It doesn't create a cluster IP or load balancer. It's used to make services accessible as external names, often pointing to resources outside the cluster.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Service Discovery"),": Services enable easy service discovery within the Kubernetes cluster. Other pods or services can discover and connect to the service using its DNS name or IP address.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Headless Service"),': You can create a "headless" service, which doesn\'t provide a cluster IP but instead allows direct DNS-based communication with individual pods, useful for certain specialized use cases like StatefulSets.'))),(0,a.kt)("p",null,"Kubernetes Services are a fundamental component for building scalable and resilient applications within a cluster. They abstract the network and routing complexities, allowing developers and operators to focus on the application logic while ensuring reliable communication and load distribution.\nWe would be using different services for different types of applications:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Headless Service (Mosquitto)"),(0,a.kt)("li",{parentName:"ul"},"NodePort: (MMC and HA)")))}k.isMDXComponent=!0}}]);