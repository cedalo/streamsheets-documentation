"use strict";(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[88366],{83166:(e,t,n)=>{var a=n(64836);t.Z=void 0;var i=a(n(64938)),o=n(85893),r=(0,i.default)((0,o.jsx)("path",{d:"M12 2 4 5v6.09c0 5.05 3.41 9.76 8 10.91 4.59-1.15 8-5.86 8-10.91V5l-8-3zm-1.06 13.54L7.4 12l1.41-1.41 2.12 2.12 4.24-4.24 1.41 1.41-5.64 5.66z"}),"GppGood");t.Z=r},82321:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>k,contentTitle:()=>h,default:()=>N,frontMatter:()=>u,metadata:()=>f,toc:()=>g});var a=n(3905),i=n(49044),o=Object.defineProperty,r=Object.defineProperties,l=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,p=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,m=(e,t,n)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,c=(e,t)=>{for(var n in t||(t={}))p.call(t,n)&&m(e,n,t[n]);if(s)for(var n of s(t))d.call(t,n)&&m(e,n,t[n]);return e};const u={id:"snowflake-bridge",title:"Snowflake Bridge",sidebar_label:"Snowflake Bridge"},h=void 0,f={unversionedId:"bridges/snowflake-bridge",id:"version-3.0/bridges/snowflake-bridge",title:"Snowflake Bridge",description:"Introduction",source:"@site/mosquitto_versioned_docs/version-3.0/bridges/Snowflake-bridge.md",sourceDirName:"bridges",slug:"/bridges/snowflake-bridge",permalink:"/mosquitto/bridges/snowflake-bridge",draft:!1,tags:[],version:"3.0",frontMatter:{id:"snowflake-bridge",title:"Snowflake Bridge",sidebar_label:"Snowflake Bridge"},sidebar:"someSidebar",previous:{title:"SQL Bridges",permalink:"/mosquitto/bridges/sql-bridge"},next:{title:"Broker Home",permalink:"/mosquitto/monitoring/broker-home"}},k={},g=[{value:"Introduction",id:"introduction",level:2},{value:"Plugin Activation",id:"plugin-activation",level:2},{value:"Config File Format",id:"config-file-format",level:2},{value:"Mapping MQTT packets to database table columns",id:"mapping-mqtt-packets-to-database-table-columns",level:2},{value:"Column type casting",id:"column-type-casting",level:2},{value:"Selector options",id:"selector-options",level:2},{value:"Configuration example",id:"configuration-example",level:2},{value:"Error handling",id:"error-handling",level:2},{value:"Buffering",id:"buffering",level:2},{value:"Retry queue",id:"retry-queue",level:2},{value:"Limitations",id:"limitations",level:2},{value:"JSON Schema",id:"json-schema",level:2}],b={toc:g};function N(e){var t,n=e,{components:o}=n,m=((e,t)=>{var n={};for(var a in e)p.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&s)for(var a of s(e))t.indexOf(a)<0&&d.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=c(c({},b),m),r(t,l({components:o,mdxType:"MDXLayout"}))),(0,a.kt)(i.Z,{mdxType:"PremiumFeature"}),(0,a.kt)("h2",c({},{id:"introduction"}),"Introduction"),(0,a.kt)("p",null,"The Snowflake Bridge plugin can be used to forward data published to the Mosquitto broker to the Snowflake DB.\nThe plugin can handle multiple database connections. For each connection, a mapping between certain MQTT topics and database tables can be defined (see ",(0,a.kt)("a",c({parentName:"p"},{href:"#configuration-example"}),"example configuration"),")."),(0,a.kt)("p",null,"In general Snowflake Bridge operates very similar to the SQL bridges with some differences in how it connects to the database and ",(0,a.kt)("a",c({parentName:"p"},{href:"#limitations"}),"what datatypes are supported"),"."),(0,a.kt)("p",null,"Snowflake bridge supports basic (username, password) authentication."),(0,a.kt)("p",null,"The plugin manages incoming MQTT messages in a buffer to perform batching and leverage batch inserting capabilities of the databases. The size properties of the buffer can be controlled via the config file (",(0,a.kt)("inlineCode",{parentName:"p"},"snowflake-bridge.json"),") in the ",(0,a.kt)("inlineCode",{parentName:"p"},"options")," section, with ",(0,a.kt)("inlineCode",{parentName:"p"},"bufferSize"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"batchSize"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"timeoutMs")," (refer to ",(0,a.kt)("a",c({parentName:"p"},{href:"#config-file-format"}),"config file format"),")."),(0,a.kt)("h2",c({},{id:"plugin-activation"}),"Plugin Activation"),(0,a.kt)("p",null,"To enable the Snowflake Bridge plugin in the broker add the following to the ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquitto.conf")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{}),"plugin /usr/lib/cedalo_snowflake_bridge.so\n\npersistence_location /mosquitto/data\n")),(0,a.kt)("p",null,"This is an example configuration snippet applicable to the docker container setup. For installation not running in a container the above configuration needs to be adjusted accordingly (namely the location of ",(0,a.kt)("inlineCode",{parentName:"p"},"cedalo_snowflake_bridge.so")," dynamic library and ",(0,a.kt)("inlineCode",{parentName:"p"},"persistence_location")," may differ)."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"persistence_location")," is used as the search base path for the plugin's config file."),(0,a.kt)("p",null,"In addition to modifying ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquitto.conf"),", ensure that you have the appropriate license to use the plugin."),(0,a.kt)("h2",c({},{id:"config-file-format"}),"Config File Format"),(0,a.kt)("p",null,"The configuration is stored in a single JSON file (named ",(0,a.kt)("inlineCode",{parentName:"p"},"snowflake-bridge.json"),") located inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"persistence_location"),", which is defined in ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquitto.conf"),". To use a different config file name, ",(0,a.kt)("inlineCode",{parentName:"p"},"plugin_opt_config_file")," option can be specified under the Snowflake bridge plugin in ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquitto.conf"),"."),(0,a.kt)("p",null,'The file represents a configuration object consisting of an array of connection objects as well as an array of so-called "schema mappings". Each connection object defines its own Snowflake connection, MQTT topics to listen to, and references a mapping of MQTT message properties to columns of a Snowflake DB table. Such mappings are called schema mappings and are described in a different array within the same config file under ',(0,a.kt)("inlineCode",{parentName:"p"},"schemaMapping")," field."),(0,a.kt)("p",null,"The fields of the configuration object are described below. To see the entire structure of the configuration file take a look at the ",(0,a.kt)("a",c({parentName:"p"},{href:"#json-schema"}),"JSON schema")," at the bottom of this page. To see an example of the config file refer to the ",(0,a.kt)("a",c({parentName:"p"},{href:"#configuration-example"}),"configuration example section"),"."),(0,a.kt)("p",null,"The following fields of the config are mandatory:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"connections")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections"),"): ",(0,a.kt)("br",null)," An array of Snowflake connection objects. Each connection objects also contains a MQTT topic mapping information apart from Snowflake connection settings (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"array"),").",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"name")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].name"),"): ",(0,a.kt)("br",null)," Unique identifier of the Snowflake connection object. In simple terms, one can think of it as a convenient name for the Snowflake connection (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"connection")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection"),"): ",(0,a.kt)("br",null)," Object holding the actual Snowflake connection information (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"object"),").",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"accountId")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.accountId"),"): ",(0,a.kt)("br",null)," Your Snowflake account ID to connect to. Account ID can be found by performing the following query ",(0,a.kt)("inlineCode",{parentName:"li"},"SELECT CURRENT_ACCOUNT();")," or by logging into the Snowflake Web Interface and checking the first part of the url after the protocol portion. Example account ID is ",(0,a.kt)("inlineCode",{parentName:"li"},'su11111.eu-central-1"')," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"credentials")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials"),"): ",(0,a.kt)("br",null)," Object holding basic authentication fields. (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"object"),")",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"username")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials.username"),"): ",(0,a.kt)("br",null)," Username used for authenticating against Snowflake (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"password")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials.password"),"): ",(0,a.kt)("br",null)," Password of the user used for authenticating against Snowflake. (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")"))))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"topicMappings")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings"),"): ",(0,a.kt)("br",null)," List of mappings specifying which MQTT topics should forward data to which Snowlflake tables (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,a.kt)("inlineCode",{parentName:"li"},"object"),").\n",(0,a.kt)("em",{parentName:"li"}," ",(0,a.kt)("inlineCode",{parentName:"em"},"name")," (path: ",(0,a.kt)("inlineCode",{parentName:"em"},"$.connections[].topicMappings.name"),"): ",(0,a.kt)("br",null)," Unique identifier of the current topic mapping. Used to provide useful information about configuration errors to the user (type: ",(0,a.kt)("inlineCode",{parentName:"em"},"string"),").\n")," ",(0,a.kt)("inlineCode",{parentName:"li"},"target")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.target"),"): ",(0,a.kt)("br",null)," Name of the Snowflake table that you want to insert your MQTT messages into (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),"). ","*"," ",(0,a.kt)("inlineCode",{parentName:"li"},"mqttTopics")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.mqttTopics"),"): ",(0,a.kt)("br",null)," An array of MQTT topics that should be forwarded to Snowflake. MQTT wildcards (",(0,a.kt)("inlineCode",{parentName:"li"},"+")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"#"),") can also be used (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),").",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"options")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.options"),"): ",(0,a.kt)("br",null)," Additional options which are to be applied before inserting records into the database.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"database")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.options.database"),"): ",(0,a.kt)("br",null)," Name of the database in which the target table is stored (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."))))))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"schemaMappings")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings"),"): ",(0,a.kt)("br",null)," An array of schema mappings (selectors). May be empty, therefore elements of this array are optional and are described in the section below (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,a.kt)("inlineCode",{parentName:"li"},"object"),").")),(0,a.kt)("p",null,"Optional fields:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"version")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.version"),"): ",(0,a.kt)("br",null)," Version of the config file. Reserved for future use (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"connections")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.connections"),")"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"connection")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.connections[].connection"),")"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"lazyConnect")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.lazyConnect"),"): ",(0,a.kt)("br",null)," Whether to initialize Snowflake connection lazily meaning that the connection pool will be created but the Snowflake connection will not be performed until there are records to be inserted. In case this option is ",(0,a.kt)("inlineCode",{parentName:"li"},"false")," the connection to Snowflake will be established and confirmed on plugin startup. In case of connection failure at this stage the plugin will output an error and fail (become unoperational). This allows to spot the connection issues early. Note that with this option being set to ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),", Snowflake bridge plugin will fail only if problems with initial connection are encountered. If the connection to Snowflake was established sucessfully at startup and fails later, the plugin will try reconnecting normally. (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"debug")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.debug"),"): ",(0,a.kt)("br",null)," Whether to log debug information (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),")."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"options")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.connections[].options"),"): ",(0,a.kt)("br",null)," Object holding additional plugin settings (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"object"),")."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"bufferSize")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.bufferSize"),"): ",(0,a.kt)("br",null)," Defines the size of the buffer, which is used to batch multiple MQTT messages together before inserting them into the database. For more information, see ",(0,a.kt)("a",c({parentName:"li"},{href:"#buffering"}),"the section on buffering")," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"1000"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"batchSize")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.batchSize"),"): ",(0,a.kt)("br",null)," Defines the size of the batch inside the buffer. Buffer is broken down into batches and a separate batch insert is issued to the database for every batch in the buffer when the latter is released. (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"bufferSize"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"timeoutMs")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.timeoutMs"),"): ",(0,a.kt)("br",null)," Interval in milliseconds after which buffer is forcefully released if it is not empty. In other words, it specifies a maximum latency of the buffer release (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"5000"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"queueMaxSize")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.queueMaxSize"),"): ",(0,a.kt)("br",null)," Defines the max size of a retry queue used in case a database insert fails due to connection problems (and not due to malformed data). If set to ",(0,a.kt)("inlineCode",{parentName:"li"},"-1"),", the size of the queue is not limited. For more information see ",(0,a.kt)("a",c({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"1000"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"-1"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"maxRetries")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.maxRetries"),"): ",(0,a.kt)("br",null)," Defines a number of retries to be performed by a retry queue before dropping the message. For more information, see ",(0,a.kt)("a",c({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"1000"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"10"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"retryDelayMs")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.retryDelayMs"),"): ",(0,a.kt)("br",null)," Defines a delay in milliseconds between the retry attempts of the queue. For more information, see ",(0,a.kt)("a",c({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"1000"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"1000"),")."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"topicMappings")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.connections[].topicMappings"),")"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"options")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.options"),")",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"schema")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.options.schema"),"): ",(0,a.kt)("br",null)," Name of the database schema in which the target table is stored (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"uppercase")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.options.uppercase"),"): ",(0,a.kt)("br",null)," Whether to cast database identifiers (tablename, schemaname, column names) to uppercase or use them as provided. (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),")."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"schemaMapping")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.schemaMapping"),"): ",(0,a.kt)("br",null)," Name of a particular schema mapping from ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings")," array to be used as a mapping between ",(0,a.kt)("inlineCode",{parentName:"li"},"target")," table and ",(0,a.kt)("inlineCode",{parentName:"li"},"mqttTopics"),"."))))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"schemaMappings")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings"),"): ",(0,a.kt)("br",null)," An array of schema mappings. Each element of the array specifies a mapping between MQTT message properties and database table columns, along with typecasting and transformations if needed (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"array")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"object"),")."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"name")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].name"),"): ",(0,a.kt)("br",null)," Unique identifier of the current schema mapping. This name is matched against ",(0,a.kt)("inlineCode",{parentName:"p"},"$.connections[].topicMappings.schemaMapping")," to determine which schema mapping to used for particular table (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping"),"): ",(0,a.kt)("br",null)," An array holding source-to-target mapper object with information about which properties or metadata to pick out from your MQTT messages as well as which columns of the target database table those properties should be inserted into. These objects are also called selectors because they select what parts of the MQTT message are to be inserted into the DB table (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"array")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"object"),")."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"source")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].source"),"): ",(0,a.kt)("br",null)," Source of the data to be inserted. This can be a property of the MQTT message payload (in case the payload is a JSON object) or some metadata property (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"client_id"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"timestamp")," etc). This field follows a particular unpacking syntax. For more information, see ",(0,a.kt)("a",c({parentName:"p"},{href:"#mapping-mqtt-packets-to-database-table-columns"}),"below")," (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"target")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].target"),"): ",(0,a.kt)("br",null)," Target table column into which data from the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field will be inserted (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"type")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].type"),"): ",(0,a.kt)("br",null)," Optional type casting of the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field before it gets inserted into the database. See more information about typecasting ",(0,a.kt)("a",c({parentName:"p"},{href:"#column-type-casting"}),"here")," (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", one of: ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"integer"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"datetime"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"raw"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"json"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"options")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options"),"): ",(0,a.kt)("br",null)," Object holding information about additional transformations to be performed on ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," before it is inserted into the database."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"replace")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.replace"),"): ",(0,a.kt)("br",null)," Specifies an array of two strings. Replaces all occurrences of the first string with the second one before inserting the data into the database (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"array")," consisting of two elements of type ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"isConst"),"(path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.isConst"),"): ",(0,a.kt)("br",null)," Used to indicate that the field in ",(0,a.kt)("inlineCode",{parentName:"li"},"source")," is a constant that should be inserted into the database as is without trying to unpack it. This is relevant in case the constant in the ",(0,a.kt)("inlineCode",{parentName:"li"},"source")," field is a string that follows the unpacking syntax (see ",(0,a.kt)("a",c({parentName:"li"},{href:"#mapping-mqtt-packets-to-database-table-columns"}),"below")," for more information) and, in particular, contains ",(0,a.kt)("inlineCode",{parentName:"li"},"[")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"]"),". Otherwise, this field can be omitted (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: if ",(0,a.kt)("inlineCode",{parentName:"li"},"source")," is a string following the unpacking syntax: ",(0,a.kt)("inlineCode",{parentName:"li"},"true")," else: ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"treatNullAsDefault")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.treatNullAsDefault"),"): This parameter specifies whether null values in the MQTT message should be treated as not defined and handled by the database table's default values (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", default: ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"nullValue")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.nullValue"),"): Used to specify which value encountered in ",(0,a.kt)("inlineCode",{parentName:"li"},"source")," should be replaced with ",(0,a.kt)("inlineCode",{parentName:"li"},"null")," when performing an insert into the table. For example, with the help of this field, you can specify to convert all ",(0,a.kt)("inlineCode",{parentName:"li"},'"<None>"')," strings to ",(0,a.kt)("inlineCode",{parentName:"li"},"null")," values (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"boolean"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"number"),", or ",(0,a.kt)("inlineCode",{parentName:"li"},"null"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"defaultValue")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.defaultValue"),"): Used to specify which value encountered in the ",(0,a.kt)("inlineCode",{parentName:"li"},"source")," field should be treated as not defined and therefore replaced with the tables's ",(0,a.kt)("inlineCode",{parentName:"li"},"DEFAULT")," value of the ",(0,a.kt)("inlineCode",{parentName:"li"},"target")," column when insert is performed (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"boolean"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"number"),", or ",(0,a.kt)("inlineCode",{parentName:"li"},"null"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"replaceNullWith")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.replaceNullWith"),"): Specifies a value that null values will be replaced with (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"any"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"replaceUndefinedWith")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.replaceUndefinedWith"),"): In case that a property specified in ",(0,a.kt)("inlineCode",{parentName:"li"},"source")," is missing on the MQTT message, it will be replaced with the value specified in this option (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"any"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"format")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.format"),"): Used when casting into ",(0,a.kt)("inlineCode",{parentName:"li"},"datetime")," datatype. Specifies a datetime format string representing the values from ",(0,a.kt)("inlineCode",{parentName:"li"},"source"),". See ",(0,a.kt)("a",c({parentName:"li"},{href:"https://date-fns.org/v3.3.1/docs/format"}),"format string documentation")," for more information on available format strings. Defaults to ",(0,a.kt)("inlineCode",{parentName:"li"},"yyyy-MM-ddTHH:mm:ss.sssZ")," (with an optional timezone information). However, by default if an integer value representing a unix timestamp in milliseconds is encountered in ",(0,a.kt)("inlineCode",{parentName:"li"},"source"),", it will also be accepted and appropriately converted to the datetime datatype (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."))))))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"options")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.options"),"): ",(0,a.kt)("br",null)," An array of schema mappings. Each element of the array specifies a mapping between MQTT message properties and database table columns, along with typecasting and transformations if needed (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"array")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"object"),")."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"driverDebug")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.options.driverDebug"),")  ",(0,a.kt)("br",null)," Whether to log driver specific debug information into stdout. The format of the logged messages is Snowflake driver dependent and does not follow a typical structure of a Mosquitto logentry. There is currently no way of outputting driver debug information for specific Snowflake conenectiuons. Therefore this setting is applied to all connections when enabled. (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),").")))),(0,a.kt)("h2",c({},{id:"mapping-mqtt-packets-to-database-table-columns"}),"Mapping MQTT packets to database table columns"),(0,a.kt)("p",null,"The plugin configuration specifies the mapping between MQTT packets and table columns in the ",(0,a.kt)("inlineCode",{parentName:"p"},"schemaMappings")," field. Elements of the ",(0,a.kt)("inlineCode",{parentName:"p"},"schemaMappings")," array must have unique names that will be matched against the ",(0,a.kt)("inlineCode",{parentName:"p"},"schemaMapping")," field of the respective connection object and a ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," field."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," specifies an array of mapper objects (also referred to as selectors) between sources and targets. ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field represents the source of the data. It comes from the MQTT message or its metadata. ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," field, on the other hand, is an appropriate table column that ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," will be inserted into. It should be able to accomodate the datatype of ",(0,a.kt)("inlineCode",{parentName:"p"},"source"),". Most of the time the consistency between the common datatypes of sources and targets (e.g. string to VARCHAR, number to NUMBER etc.) is handled by the Snwoflake bridge itself. However, in certain cases of datatype mismatches (e.g. when handling non-ISO formatted date strings etc) a typecasting may be required. See the ",(0,a.kt)("a",c({parentName:"p"},{href:"#column-type-casting"}),"following section on typecasting"),"."),(0,a.kt)("p",null,"To be more precise, the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field can either be a constant or a path to a particular metadata property of an MQTT message or a data property within its payload. In case MQTT payload is a JSON, the path to some data property of such payload can be specified."),(0,a.kt)("p",null,"Here are some examples to put the above-mentioned into context:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "I am a constant string",\n            "target": "column_a"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"The select object above maps a constant string (",(0,a.kt)("inlineCode",{parentName:"p"},'"I am a constant string"'),") to the ",(0,a.kt)("inlineCode",{parentName:"p"},"column_a")," of the database. This means that for every MQTT message for which this mapping is invoked, an SQL statement inserting ",(0,a.kt)("inlineCode",{parentName:"p"},'"I am a constant string"')," into the column ",(0,a.kt)("inlineCode",{parentName:"p"},"column_a")," will be performed."),(0,a.kt)("p",null,"To insert the entire MQTT payload, the selector would look similar to the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload]",\n            "target": "column_a"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"Note that apart from ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload]"),", various special metadata properties of the MQTT message may be selected. Here is the entire list of special (meta)data properties:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"hostname"),": Hostname of the broker. Note that the ",(0,a.kt)("inlineCode",{parentName:"li"},"HOSTNAME")," environment variable must be specified for the broker, or the default value will be used (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"<Unknown>"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"topic"),": Name of the topic to which the MQTT message was published (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"payload"),": Payload of the MQTT message. Can be used to further unpack (pick out) child properties of the payload object if the latter is a JSON. See below for more information. If the payload was originally a string or a number, it will be treated as such, and no typecasting is necessary (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"any"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"qos"),": QoS level of the MQTT message (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", one of: ",(0,a.kt)("inlineCode",{parentName:"li"},"0"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"1"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"2"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"retain")," - Retain flag of the MQTT message (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"timestamp")," - Unix timestamp representing the time when the MQTT message arrived at the broker. To insert this property into the database a column of type ",(0,a.kt)("inlineCode",{parentName:"li"},"INTEGER")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"BIGINT")," would typically be used (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"datetime")," - Datetime string representing the time when the MQTT message arrived at the broker. To insert this property into the database a column of type ",(0,a.kt)("inlineCode",{parentName:"li"},"DATETIME")," would typically be used (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string")," representing the date in ISO format)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"uuid")," - unique identifier (UUID) of the message. Note that it is a convenience property. This ID is internally generated by the Snowflake Bridge plugin and is not coming from the original message's metadata (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"client_id")," - client_id of the device that published the MQTT message (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),").")),(0,a.kt)("p",null,"To select one of the above-mentioned properties, it should be enclosed in square brackets (",(0,a.kt)("inlineCode",{parentName:"p"},"[]"),") and specified in the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field of the configuration file."),(0,a.kt)("p",null,"For example, to insert the client ID of the device that published the message into the ",(0,a.kt)("inlineCode",{parentName:"p"},"client_id_column")," the following selector can be defined:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[client_id]",\n            "target": "client_id_column"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"As mentioned, it is also possible to unpack MQTT payload in case it is a JSON and select/pick out/extract certain properties from it. This can be achieved by specifying a JSON path to such property in the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field. However, the properties in this path should be separated not by dots, but rather by square brackets (e.g.: not ",(0,a.kt)("inlineCode",{parentName:"p"},"payload.property1.innerProperty")," but ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][property1][innerProperty]"),")."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that currently the only supported characters for the JSON payload properties are ",(0,a.kt)("inlineCode",{parentName:"p"},"[a-zA-Z0-9_-]")," (alpha numeric characters as well as ",(0,a.kt)("inlineCode",{parentName:"p"},"_")," (underscore) and ",(0,a.kt)("inlineCode",{parentName:"p"},"-")," (dash))")),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1][innerProperty]",\n            "target": "column_a"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"In the above example ",(0,a.kt)("inlineCode",{parentName:"p"},"payload.property1.innerProperty")," is selected into the ",(0,a.kt)("inlineCode",{parentName:"p"},"column_a")," column."),(0,a.kt)("p",null,"This means that if the MQTT payload looks like below:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    "propery1": {\n        "innerProperty": "test"\n    },\n    "property2": {\n        "someProperty": 1\n    }\n}\n')),(0,a.kt)("p",null,"then the string ",(0,a.kt)("inlineCode",{parentName:"p"},'"test"')," will be inserted into ",(0,a.kt)("inlineCode",{parentName:"p"},"column_a"),"."),(0,a.kt)("h2",c({},{id:"column-type-casting"}),"Column type casting"),(0,a.kt)("p",null,"Snowflake bridge provides a feature to typecast properties of MQTT messages before they are inserted into the respective tables."),(0,a.kt)("p",null,"In order to cast a certain property to a certain type, the following configuration must be specified:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "<your mapping name here>",\n    "mapping": [\n        {\n            "source": "<your source mqtt message property>",\n            "target": "<your target db table column>",\n            "type": "<specify type to cast \'source\' into>"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][number_str]",\n            "target": "number_column",\n            "type": "number"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"The following types are supported:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"datetime"),": casts integers or strings into a datetime (",(0,a.kt)("inlineCode",{parentName:"li"},"format"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"dbFormat")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"replaceDelimiter")," might need to be specified. See ",(0,a.kt)("a",c({parentName:"li"},{href:"#selector-options"}),"options section")," for details). There is no need to typecast datetime strings if they follow ISO format (note that the timezone portion is not required here since many databases don't handle timezones)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"number"),": casts strings into either a float or integer (supports float numbers separated by both dots or commas (e.g. both ",(0,a.kt)("inlineCode",{parentName:"li"},"1.5")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"1,5")," are handled))."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"integer"),": casts string into an integer truncating the fractional part."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"boolean"),": casts strings or numbers into a boolean value (note that string ",(0,a.kt)("inlineCode",{parentName:"li"},'"false"')," is cast to a ",(0,a.kt)("inlineCode",{parentName:"li"},"false")," boolean value, as is number 0, null, empty string, or a missing property. Everything else is cast to ",(0,a.kt)("inlineCode",{parentName:"li"},"true"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"raw"),": casts strings, numbers, and objects into binary DB types like ",(0,a.kt)("inlineCode",{parentName:"li"},"BLOB")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"BINARY"),". The specific datatype depends on the underlying databae driver and a specified encoding (",(0,a.kt)("inlineCode",{parentName:"li"},"encoding"),", and ",(0,a.kt)("inlineCode",{parentName:"li"},"dbEncoding")," might need to be specified. See ",(0,a.kt)("a",c({parentName:"li"},{href:"#selector-options"}),"options section")," for details)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"string"),": can cast numbers into strings. There is typically no need to typecast JSON objects into strings as this is done automatically.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that while it might be tempting to explicitly specify typecasting for all the ",(0,a.kt)("inlineCode",{parentName:"p"},"source"),"s, this is not recommended as typecasting is often associated with additional overhead. The rule of thumb would be to cast only what is necessary.")),(0,a.kt)("h2",c({},{id:"selector-options"}),"Selector options"),(0,a.kt)("p",null,"Each selector under the ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," section of the configuration file can have additional options that define transformations to be performed on the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," data before it is inserted into ",(0,a.kt)("inlineCode",{parentName:"p"},"target"),". For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1]",\n            "target": "column_a",\n            "options": {\n                "nullValue": "<null>"\n            }\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"The above specifies a selector that maps ",(0,a.kt)("inlineCode",{parentName:"p"},"property1")," of the MQTT message to the ",(0,a.kt)("inlineCode",{parentName:"p"},"column_a")," in the database table. Once value ",(0,a.kt)("inlineCode",{parentName:"p"},'"<null>"')," is encountered in ",(0,a.kt)("inlineCode",{parentName:"p"},"property1")," it will be converted to ",(0,a.kt)("inlineCode",{parentName:"p"},"NULL")," before being inserted into the database."),(0,a.kt)("p",null,"Note that some options can only be used when typecasting to certain datatypes, while others can be used with any type or even without any typecasting."),(0,a.kt)("p",null,"Options which can only be used when typecasting to ",(0,a.kt)("inlineCode",{parentName:"p"},"datetime"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"format"))),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1]",\n            "target": "column_a",\n            "type": "datetime",\n            "options": {\n                "nullValue": "<null>",\n                "format": "yyyy-MM-dd HH:mm:ss",\n            }\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"Options which can be used as long as the underlying value is a ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"replace"))),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1]",\n            "target": "column_a",\n            "options": {\n                "replace": ["hello world", "hello Snowflake"]\n            }\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"Options which can be used regardless of types and typecasting:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"replaceNullWith")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"replaceUndefinedWith")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"nullValue")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"defaultValue")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"treatNullAsDefault")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"isConst"))),(0,a.kt)("p",null,"See ",(0,a.kt)("a",c({parentName:"p"},{href:"#config-file-format"}),"config file fieds")," for more information on the listed options (their descriptions, datatypes, allowed values)."),(0,a.kt)("h2",c({},{id:"configuration-example"}),"Configuration example"),(0,a.kt)("p",null,"An example of the ",(0,a.kt)("inlineCode",{parentName:"p"},"snowflake-bridge.json")," with two database connections is shown below (you may see all the available configuration options ",(0,a.kt)("a",c({parentName:"p"},{href:"#json-schema"}),"here"),"):"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    "version": 1,\n    "connections": [\n        {\n            "name": "snowflake-1",\n            "connection": {\n                "accountId": "su11111.eu-central-0",\n                "credentials": {\n                    "username": "mosquittouser",\n                    "password": "password"\n                },\n                "lazyConnect": false\n            },\n            "options": {\n                "bufferSize": 10000,\n                "batchSize": 1000,\n                "timeoutMs": 4000,\n                "queueMaxSize": 10000,\n                "maxRetries": 15,\n                "retryDelayMs": 1000\n            },\n            "topicMappings": [\n                {\n                    "name": "topic-mapping-to-snowflake-table-1",\n                    "schemaMapping": "schema-mapping-1",\n                    "target": "blood",\n                    "options": {\n                        "database": "mosquitto",\n                        "schema": "public",\n                        "uppercase": true\n                    },\n                    "mqttTopics": [\n                        "db/qa/#"\n                    ]\n                }\n            ]\n        },\n        {\n            "name": "snowflake-2",\n            "connection": {\n                "accountId": "su00000.eu-central-0",\n                "credentials": {\n                    "username": "mosquittouser2",\n                    "password": "password"\n                },\n                "lazyConnect": false\n            },\n            "options": {\n                "bufferSize": 10000,\n                "batchSize": 1000,\n                "timeoutMs": 4000,\n                "queueMaxSize": 10000,\n                "maxRetries": 15,\n                "retryDelayMs": 1000\n            },\n            "topicMappings": [\n                {\n                    "name": "topic-mapping-to-snowflake-table-2",\n                    "schemaMapping": "schema-mapping-1",\n                    "target": "blood",\n                    "options": {\n                        "database": "mosquitto",\n                        "schema": "public",\n                        "uppercase": true\n                    },\n                    "mqttTopics": [\n                        "db/qa/#"\n                    ]\n                }\n            ]\n        },\n    ],\n    "schemaMappings": [\n        {\n            "name": "schema-mapping-1",\n            "mapping": [\n                {\n                    "source": "[client_id]",\n                    "target": "humanname"\n                },\n                {\n                    "source": "[payload][data]",\n                    "target": "dummychars",\n                    "type": "string"\n                },\n                {\n                    "source": "[uuid]",\n                    "target": "uuidcol"\n                },\n                {\n                    "source": "[payload][tmp]",\n                    "target": "floatnumbercol",\n                    "type": "integer"\n                },\n                {\n                    "source": "[datetime]",\n                    "target": "dt"\n                },\n                {\n                    "source": "[payload][tmp_int]",\n                    "target": "floatnumbercol2",\n                    "type": "number"\n                },\n                {\n                    "source": "[payload][name]",\n                    "target": "textcol",\n                    "options": {\n                        "replace": ["Tom ", "Thomas "]\n                    }\n                },\n                {\n                    "source": "some constant desc",\n                    "target": "descript"\n                },\n                {\n                    "source": "[payload][data][temp]",\n                    "target": "temp"\n                },\n                {\n                    "source": "[payload][data][more][ok]",\n                    "target": "isok",\n                    "type": "boolean"\n                },\n                {\n                    "source": "[payload][packet_dt]",\n                    "target": "dt2",\n                    "type": "datetime",\n                    "options": {\n                        "format": "yyyy-MM-dd HH:mm:ss"\n                    }\n                },\n                {\n                    "source": "[payload][data]",\n                    "target": "sourcecolumn",\n                    "options": {\n                        "isConst": true\n                    }\n                },\n                                {\n                    "source": "[payload]",\n                    "target": "payload_string",\n                }\n            ]\n        }\n    ]\n}\n')),(0,a.kt)("p",null,"As per the example config above, Snowlake bridge will connect to two snowflake accounts: ",(0,a.kt)("inlineCode",{parentName:"p"},"su11111.eu-central-0")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"su00000.eu-central-0"),". It will use a database called ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquitto")," and will authenticate against it as ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquittouser"),"."),(0,a.kt)("p",null,"The optional ",(0,a.kt)("inlineCode",{parentName:"p"},"options")," field is specified and overrides some defaults of the plugin's buffering. It sets ",(0,a.kt)("inlineCode",{parentName:"p"},"bufferSize")," to 10000. This setting effectively assigns the specified buffer size for every buffer. Buffers are created per table to store MQTT message information for batching purposes and trigger fewer insert queries."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"batchSize")," specifies the number of rows that should be inserted into the database per single batch insert. Effectively, it breaks a single batch insert into multiple smaller batch inserts of the specified size (1000 in this case)."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"timeoutMs")," is changed to 4000 milliseconds which means that every 4 seconds all the buffers that are not empty will be forecefully cleared. Clearing the buffers triggers batch inserts even if they have not yet reached full capacity."),(0,a.kt)("p",null,"See ",(0,a.kt)("a",c({parentName:"p"},{href:"#buffering"}),"section about buffering")," for more information."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"queueMaxSize")," sets the retry queue size to 10000 which is a limit after which messages will be dropped. ",(0,a.kt)("inlineCode",{parentName:"p"},"maxRetries")," is set to 15, and ",(0,a.kt)("inlineCode",{parentName:"p"},"retryDelayMs")," to 1000. This means that we will retry once every second for 15 iterations, getting a 15 seconds of retry for every message that wasn't inserted due to connection issue. This is quite long, so it's important to adapt ",(0,a.kt)("inlineCode",{parentName:"p"},"queueMaxSize")," or set it to be limitless with a ",(0,a.kt)("inlineCode",{parentName:"p"},"-1")," value to ensure that the queue doesn't get overfilled while retrying to insert messages."),(0,a.kt)("p",null,"See ",(0,a.kt)("a",c({parentName:"p"},{href:"#retry-queue"}),"section about retry queue")," for more information."),(0,a.kt)("p",null,"The configuration uses a mapping to table ",(0,a.kt)("inlineCode",{parentName:"p"},"blood")," stored in schema ",(0,a.kt)("inlineCode",{parentName:"p"},"public")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquitto")," database in each Snowflake connections."),(0,a.kt)("p",null,"Under the ",(0,a.kt)("inlineCode",{parentName:"p"},"mqttTopics")," entry, there is an array of MQTT topics which should be mapped to the database table (",(0,a.kt)("inlineCode",{parentName:"p"},"blood"),"). In case this array was empty, no messages would be forwarded to the database."),(0,a.kt)("p",null,"Multiple topic mappings can be specified in this array, but in the case above, there is just a single entry. However, this entry uses an MQTT wildcard (",(0,a.kt)("inlineCode",{parentName:"p"},"db/qa/#"),"), specifying that any MQTT message that is published in any of the topics under ",(0,a.kt)("inlineCode",{parentName:"p"},"db/qa/")," will be unpacked and inserted into the database using selectors from the respective schema mapping specified in ",(0,a.kt)("inlineCode",{parentName:"p"},"schemaMapping")," key (",(0,a.kt)("inlineCode",{parentName:"p"},'"schema-mapping-1"')," in our case)."),(0,a.kt)("p",null,"Section ",(0,a.kt)("inlineCode",{parentName:"p"},"schemaMapping")," defines an array of schema mappings that are used to unpack MQTT messages. ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," field of each element in the array is a unique identifier of the schema mapping matched against ",(0,a.kt)("inlineCode",{parentName:"p"},"schameMapping")," field from ",(0,a.kt)("inlineCode",{parentName:"p"},"topicMappings"),". Apart from ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," each schema mapping contains a ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," field with selectors.\nEach selector under the ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," field represents a ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," for the mapping between MQTT message properties and database table column mapping. Each ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," is some property of the MQTT message (or a constant value) and each ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," is a column of the table ",(0,a.kt)("inlineCode",{parentName:"p"},"blood"),"."),(0,a.kt)("p",null,"Note that some sources specify metadata properties of the MQTT message like ",(0,a.kt)("inlineCode",{parentName:"p"},"[client_id]")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"[uuid]")," (representing a client id of the publisher or a unique identifier generated for the message). Other properties unpack the payload of the MQTT message and extract certain properties from it. For example, ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][packet_dt]"),", which extracts the ",(0,a.kt)("inlineCode",{parentName:"p"},"packet_dt")," from the MQTT payload, assuming that this payload is a JSON. Also note that this selector has a typecast to ",(0,a.kt)("inlineCode",{parentName:"p"},"datetime")," datatype meaning that it tries to interpret the value in ",(0,a.kt)("inlineCode",{parentName:"p"},"packet_dt")," as a date string according to the ",(0,a.kt)("inlineCode",{parentName:"p"},"yyyy-MM-dd HH:mm:ss")," format specified under ",(0,a.kt)("inlineCode",{parentName:"p"},"options"),"."),(0,a.kt)("p",null,"Notice the typecasting on some other sources. For example, the source ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][tmp]")," is mapped to a ",(0,a.kt)("inlineCode",{parentName:"p"},"floatnumbercol")," column. This implicitly implies (judging by the name of the column) that the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"tmp")," could be a float. However, it is typecasted to ",(0,a.kt)("inlineCode",{parentName:"p"},"integer"),", and therefore, the fractional part of the number will be sliced off before the insert into the table occurs."),(0,a.kt)("p",null,"Another example is a mapping between a deeply nested property ",(0,a.kt)("inlineCode",{parentName:"p"},"ok")," in source ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][data][more][ok]")," and the column ",(0,a.kt)("inlineCode",{parentName:"p"},"isok"),". This mapping has a ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean")," typecasting, which means that even if ",(0,a.kt)("inlineCode",{parentName:"p"},"ok")," property is not an actual boolean but a string literal with values of either ",(0,a.kt)("inlineCode",{parentName:"p"},'"true"')," or ",(0,a.kt)("inlineCode",{parentName:"p"},'"false"'),", the casting will convert those to the proper boolean values ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"false")," respectively."),(0,a.kt)("p",null,"There is also a ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][name]")," property being unpacked and transformed. The transformation in this case is a replacement of all occurrences of the substring ",(0,a.kt)("inlineCode",{parentName:"p"},'"Tom "')," to ",(0,a.kt)("inlineCode",{parentName:"p"},'"Thomas ".')),(0,a.kt)("p",null,"If required, the entire MQTT payload can be inserted into a column. This is shown in the mapping between ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload]")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"payload_string"),". In this case the if the MQTT payload is a JSON object it will be converted to and inserted as a string. For that, the respective database column should have an appropriate text type to accommodate it."),(0,a.kt)("p",null,"In cases when the payload of the MQTT message is not a JSON but a string or a number, it will be inserted as such."),(0,a.kt)("p",null,"An interesting but uncommon case is the mapping of source ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][data]")," to the ",(0,a.kt)("inlineCode",{parentName:"p"},"sourcecolumn"),". Note that, since ",(0,a.kt)("inlineCode",{parentName:"p"},"isConst")," option is set to true, ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][data]")," is being treated as a constant string rather than a ",(0,a.kt)("inlineCode",{parentName:"p"},"data")," property of the MQTT message's payload. The ",(0,a.kt)("inlineCode",{parentName:"p"},"isConst")," option is needed in this case because the constant string ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][data]")," has the same syntax as unpacking MQTT payload. If this option was not specified, the plugin would try to extract the property from the payload leading to errors if it is not present."),(0,a.kt)("p",null,"However, if there is a need to insert a constant into the database and it does not look like a valid message unpacking syntax (e.g. doesn't use the square brackets notation), then there is no need to specify the ",(0,a.kt)("inlineCode",{parentName:"p"},"isConst")," option. This can be seen in the following mapping:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'                            {\n                                "source": "some constant desc",\n                                "target": "descript"\n                            },\n')),(0,a.kt)("p",null,"which will simply insert string ",(0,a.kt)("inlineCode",{parentName:"p"},'"some constant desc"')," into ",(0,a.kt)("inlineCode",{parentName:"p"},"descript")," message for every MQTT message."),(0,a.kt)("h2",c({},{id:"error-handling"}),"Error handling"),(0,a.kt)("p",null,"Any configuration or license errors will prevent the plugin from being loaded, and respective messages will appear in the logs."),(0,a.kt)("p",null,"If recoverable errors occur during the operation of the plugin, it will generate respective error messages in its logs and prefix them with an ",(0,a.kt)("inlineCode",{parentName:"p"},"ERR:")," prefix. This includes: encountering errors when converting MQTT messages to SQL insert queries as well as failures during query execution."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that while error messages generated by the plugin will be preceded by ",(0,a.kt)("inlineCode",{parentName:"p"},"ERR:"),", warning messages will get a ",(0,a.kt)("inlineCode",{parentName:"p"},"WARN:")," prefix, while debug messages - a respective ",(0,a.kt)("inlineCode",{parentName:"p"},"DEBUG:"),".")),(0,a.kt)("h2",c({},{id:"buffering"}),"Buffering"),(0,a.kt)("p",null,"Buffers are created per table for every database connection. The size of the buffer is controlled with ",(0,a.kt)("inlineCode",{parentName:"p"},"bufferSize")," field under ",(0,a.kt)("inlineCode",{parentName:"p"},"options")," (",(0,a.kt)("inlineCode",{parentName:"p"},"$.connections[].options"),") and indicates the capacity of the buffer. The default size of the buffer is 1000. Buffer holds records representing unpacked MQTT messages which are to be inserted to the respective table once the buffer is saturated."),(0,a.kt)("p",null,"Once the buffer fills up, its flushing is triggered, and a single or multiple batch inserts are issued against the table, inserting the buffer contents. The condition for buffer flush is ",(0,a.kt)("inlineCode",{parentName:"p"},"bufferSize + 1"),". Once this number of records is reached, the buffer is released. The number of batch insert queries issued per buffer release is controlled via the ",(0,a.kt)("inlineCode",{parentName:"p"},"batchSize")," config field. This field indicates how many records should be inserted per single batch insert. By default, ",(0,a.kt)("inlineCode",{parentName:"p"},"batchSize")," equals ",(0,a.kt)("inlineCode",{parentName:"p"},"bufferSize"),", meaning that the buffer is not broken down into batches and a single batch insert query is performed."),(0,a.kt)("p",null,"Another parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"timeoutMs")," - indicates the timeinterval (in milliseconds) after which all the non-empty buffers will be forcefully released triggering the batch inserts of the buffers' contents. The default value is 5000 ms."),(0,a.kt)("p",null,"However, even though it might seem that buffer is only released after saturation or a timeout, it also has a mechanism to account for infrequent MQTT messages and decrease the latency of database inserts for such records."),(0,a.kt)("p",null,'The idea is that the time interval between the current and the previous MQTT messages is kept track of. If this interval is long enough, the record will be inserted instantly. However, if the interval between the messages is short, the plugin will keep buffering the messages anticipating a possible influx. The definition of "long enough" might change when updates to the plugin are made, but currently, it\'s a fraction of the ',(0,a.kt)("inlineCode",{parentName:"p"},"timeouts.")," For practical purposes it can be assumed as ",(0,a.kt)("inlineCode",{parentName:"p"},"timeoutMs/2"),"."),(0,a.kt)("p",null,"Note that the above leads to the first MQTT message never being buffered."),(0,a.kt)("p",null,"Also, notice that buffer options can be defined per database connection, allowing for more flexibility and fine-tuning when needed."),(0,a.kt)("h2",c({},{id:"retry-queue"}),"Retry queue"),(0,a.kt)("p",null,"The Snoflake bridge plugin guarantees the in-order insertion of all the non-malformed messages into the respective tables. However, in case of network issues or database downtime, some messages may be lost. To prevent this, Snoflake bridge has a retry queue on a per-table basis that is responsible for retrying message inserts in case of connection problems. Notice that this does not include cases when the data of the MQTT message is malformed and generates an SQL error upon insert (due to inconsistent types, exceeded limits, or violated constraints, etc)."),(0,a.kt)("p",null,"Each retry queue can be configured with the following settings (under ",(0,a.kt)("inlineCode",{parentName:"p"},"options")," field of the configuration file (",(0,a.kt)("inlineCode",{parentName:"p"},"$.connections[].options"),")):"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"queueMaxSize")," option is used to set the maximum amount of messages that the queue is able to accomodate before it starts to drop them. This limit can be set to infinity using the value ",(0,a.kt)("inlineCode",{parentName:"p"},"-1"),", which is a default. Note that if this value is not set to ",(0,a.kt)("inlineCode",{parentName:"p"},"-1"),", then careful considerations and testing should be performed to ensure that the queue will not overfill too quickly as soon as it tries to retry insertings messages."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"maxRetries")," is used to specify the maximum number that the retry queue attempts to insert a message again before dropping it."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"retryDelayMs")," is a minimum amount of time in milliseconds that must pass between the retry queue attempts."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that the elements in a retry queue can be both single MQTT messages as well as entire buffers of MQTT messages that are ready to be batch-inserted into the database.")),(0,a.kt)("h2",c({},{id:"limitations"}),"Limitations"),(0,a.kt)("p",null,"Snowflake bridge currently doesn't support ",(0,a.kt)("inlineCode",{parentName:"p"},"VARIANT")," datatype, therefore it can only serialize JSON objects as strings and insert them into string-type columns."),(0,a.kt)("h2",c({},{id:"json-schema"}),"JSON Schema"),(0,a.kt)("p",null,"Schema for all possible parameters for the ",(0,a.kt)("inlineCode",{parentName:"p"},"snowflake-bridge.json")," config file:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    "title": "Snowflake-Bridge Plugin Config",\n    "type": "object",\n    "properties": {\n        "version": {\n            "type": "string",\n            "nullable": true,\n            "description": "Version of the configuration file"\n        },\n        "options": {\n            "type": "object",\n            "description": "Global options for the Snowflake bridge",\n            "properties": {\n                "driverDebug": {\n                    "type": "boolean",\n                    "nullable": true,\n                    "description": "Whether to enable driver-level debug information for queries. Note that it does not use Mosquitto logger, so the formatting of the output is different"\n                }\n            },\n            "nullable": true\n        },\n        "connections": {\n            "type": "array",\n            "description": "List of configurations per Snowflake connection",\n            "items": {\n                "type": "object",\n                "description": "Configuration per Snowflake connection",\n                "properties": {\n                    "name": {\n                        "type": "string",\n                        "nullable": false,\n                        "description": "Unique textual identifier of the configuration"\n                    },\n                    "options": {\n                        "type": "object",\n                        "nullable": true,\n                        "description": "Plugin options for configuring internal queues and buffers",\n                        "properties": {\n                            "bufferSize": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 1,\n                                "description": "Maximum number of messages to buffer before flushing to the database"\n                            },\n                            "timeoutMs": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 0,\n                                "description": "Maximum time in milliseconds to buffer messages before flushing to the database"\n                            },\n                            "batchSize": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 0,\n                                "description": "Size of batch for bulk insert when releasing the buffer. Defaults to bufferlength"\n                            },\n                            "queueMaxSize": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": -1,\n                                "description": "Maximum number of messages in retry queue"\n                            },\n                            "maxRetries": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 0,\n                                "description": "Maximum number of retries for failed inserts due to lost connection"\n                            },\n                            "retryDelayMs": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 0,\n                                "description": "Delay in milliseconds before retrying inserts failed due to lost connection"\n                            }\n                        }\n                    },\n                    "connection": {\n                        "type": "object",\n                        "description": "Credentials and other setttings needed for a Snowflake connections",\n                        "properties": {\n                            "accountId": {\n                                "type": "string",\n                                "nullable": false,\n                                "description": "Id of the Snowflake account to connect to"\n                            },\n                            "credentials": {\n                                "type": "object",\n                                "description":\n                                    "Credentials of the database user used for connection to the database",\n                                "properties": {\n                                    "username": {\n                                        "type": "string",\n                                        "description": "Username of the database user to use for connection"\n                                    },\n                                    "password": {\n                                        "type": "string",\n                                        "description": "Password of the database user to use for connection"\n                                    }\n                                },\n                                "nullable": false,\n                                "required": [\n                                    "username",\n                                    "password"\n                                ]\n                            },\n                            "debug": {\n                                "type": "boolean",\n                                "nullable": true,\n                                "description": "Whether to enable debug query logging for connection"\n                            },\n                            "lazyConnect": {\n                                "type": "boolean",\n                                "nullable": true,\n                                "default": false,\n                                "description": "Whether to allow the plugin to continue if the connection to the database cannot be established"\n                            }\n                        },\n                        "nullable": false,\n                        "required": [\n                            "accountId",\n                            "credentials"\n                        ]\n                    },\n                    "topicMappings": {\n                        "type": "array",\n                        "description": "List of topic mapping objects to forward MQTT messages to the database",\n                        "items": {\n                            "type": "object",\n                            "properties": {\n                                "name": {\n                                    "type": "string",\n                                    "nullable": false,\n                                    "description": "Unique identifier of this mapping"\n                                },\n                                "schemaMapping": {\n                                    "type": "string",\n                                    "nullable": false,\n                                    "description": "Name of the schema mapping which should be applied here"\n                                },\n                                "target": {\n                                    "type": "string",\n                                    "nullable": false,\n                                    "description": "Database table to forward MQTT messages to"\n                                },\n                                "options": {\n                                    "type": "object",\n                                    "nullable": true,\n                                    "properties": {\n                                        "schema": {\n                                            "type": "string",\n                                            "nullable": true,\n                                            "description": "Name of the schema where the table is located in"\n                                        },\n                                        "database": {\n                                            "type": "string",\n                                            "nullable": false,\n                                            "description": "Name of the database where the table is located"\n                                        },\n                                        "uppercase": {\n                                            "type": "boolean",\n                                            "nullable": true,\n                                            "description": "Whether to uppercase all the db related objects like schema, tablename and columns or leave them as entered into the config. Defaults to false"\n                                        }\n                                    },\n                                    "required": ["database"],\n                                    "description": "Optional options for the table"\n                                },\n                                "mqttTopics": {\n                                    "type": "array",\n                                    "items": {\n                                        "type": "string",\n                                        "description": "List of MQTT topics to forward messages from",\n                                        "pattern": "^((\\\\+?|[\\\\w-]+)((\\\\/[\\\\w-]+)?(\\\\/\\\\+)?(\\\\/[\\\\w-]+)?((?<!\\\\+)\\\\/)?)*(\\\\/#)?|(\\\\/)?#)$"\n                                    }\n                                }\n                            },\n                            "required": ["name", "schemaMapping", "target", "mqttTopics"]\n                        }\n                    }\n                },\n                "required": ["name", "connection", "topicMappings"]\n            }\n        },\n        "schemaMappings": {\n            "type": "array",\n            "items": {\n                "type": "object",\n                "properties": {\n                    "name": {\n                        "type": "string",\n                        "nullable": false,\n                        "description": "Unique identifier of the mapping"\n                    },\n                    "mapping": {\n                        "type": "array",\n                        "description": "List of mappings to apply to the table. Each schema contains a mapping of database table columns to MQTT message properties",\n                        "items": {\n                            "type": "object",\n                            "description": "Properties to select from the MQTT message and insert into the database table",\n                            "properties": {\n                                "source": {\n                                    "oneOf": [\n                                        {"type": "string"},\n                                        {"type": "number"},\n                                        {"type": "null", "nullable": true}\n                                    ],\n                                    "description": "JSON path to the value to insert into the column using square brackets, e.g. \\"[foo][bar]\\" AND NOT \\"$.foo.bar\\""\n                                },\n                                "target": {\n                                    "type": "string",\n                                    "nullable": false,\n                                    "description": "Name of the column to insert data from \\"source\\" into"\n                                },\n                                "type": {\n                                    "type": "string",\n                                    "nullable": true,\n                                    "description": "Data type of the value to cast source to before inserting into the column"\n                                },\n                                "options": {\n                                    "type": "object",\n                                    "nullable": true,\n                                    "description": "Optional options for the column"\n                                }\n                            },\n                            "required": ["source", "target"]\n                        }\n                    }\n                },\n                "required": ["name", "mapping"]\n            }\n        }\n    },\n    "required": ["connections", "schemaMappings"]\n}\n')))}N.isMDXComponent=!0},49044:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(67294),i=n(39082),o=n(62659),r=n(83166);function l({inline:e}){return a.createElement(i.Z,{sx:{margin:e?"0px 5px":"5px 5px 15px 5px",height:e?"22px":void 0,color:"#ffffff",backgroundColor:o.Z[500]},size:"small",icon:a.createElement(r.Z,{style:{color:"white"},size:"small"}),label:"Premium"})}}}]);