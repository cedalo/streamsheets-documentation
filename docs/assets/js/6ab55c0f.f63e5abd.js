"use strict";(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[73803],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>d});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),p=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(r),d=a,k=m["".concat(s,".").concat(d)]||m[d]||u[d]||i;return r?n.createElement(k,o(o({ref:t},c),{},{components:r})):n.createElement(k,o({ref:t},c))}));function d(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=r[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},96453:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>d,default:()=>N,frontMatter:()=>m,metadata:()=>k,toc:()=>f});var n=r(3905),a=Object.defineProperty,i=Object.defineProperties,o=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,c=(e,t,r)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,u=(e,t)=>{for(var r in t||(t={}))s.call(t,r)&&c(e,r,t[r]);if(l)for(var r of l(t))p.call(t,r)&&c(e,r,t[r]);return e};const m={id:"server-certificates",title:"Server Certificates",sidebar_label:"Server Certificates"},d="Docker Setup",k={unversionedId:"security/certificates/server-certificates",id:"version-3.1/security/certificates/server-certificates",title:"Server Certificates",description:"Prerequisites",source:"@site/mosquitto_versioned_docs/version-3.1/security/certificates/server-certificates.md",sourceDirName:"security/certificates",slug:"/security/certificates/server-certificates",permalink:"/mosquitto/security/certificates/server-certificates",draft:!1,tags:[],version:"3.1",frontMatter:{id:"server-certificates",title:"Server Certificates",sidebar_label:"Server Certificates"},sidebar:"someSidebar",previous:{title:"SAML Authentication/SSO",permalink:"/mosquitto/security/platform-access/platform-saml-auth"},next:{title:"mTLS",permalink:"/mosquitto/security/certificates/mtls"}},h={},f=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Configuring Pro Mosquitto Broker with a Server Certificate",id:"configuring-pro-mosquitto-broker-with-a-server-certificate",level:2},{value:"Pro Mosquitto TLS termination",id:"pro-mosquitto-tls-termination",level:3},{value:"HA Proxy TLS termination",id:"ha-proxy-tls-termination",level:3},{value:"Client connections",id:"client-connections",level:3},{value:"Certificate access",id:"certificate-access",level:3},{value:"Configuring Cedalo Platform with a Server Certificate",id:"configuring-cedalo-platform-with-a-server-certificate",level:2},{value:"Environment Variables",id:"environment-variables",level:3},{value:"Example configuration",id:"example-configuration",level:3},{value:"Docker compose",id:"docker-compose",level:3},{value:"TLS Configuration Overview for Kubernetes/OpenShift",id:"tls-configuration-overview-for-kubernetesopenshift",level:2},{value:"<strong>Key Differences:</strong>",id:"key-differences",level:3},{value:"<strong>Why Different Approaches?</strong>",id:"why-different-approaches",level:3},{value:"Single Node TLS Configuration (Server-Only TLS)",id:"single-node-tls-configuration-server-only-tls",level:2},{value:"Prerequisites",id:"prerequisites-1",level:3},{value:"Secret Creation",id:"secret-creation",level:3},{value:"First-Time Installation",id:"first-time-installation",level:3},{value:"Upgrade Installation",id:"upgrade-installation",level:3},{value:"Configuration Parameters",id:"configuration-parameters",level:3},{value:"What Happens Under the Hood",id:"what-happens-under-the-hood",level:3},{value:"Verify TLS Configuration",id:"verify-tls-configuration",level:3},{value:"Important Path Configuration Notes",id:"important-path-configuration-notes",level:3},{value:"HA Cluster TLS Configuration",id:"ha-cluster-tls-configuration",level:2},{value:"Why HAProxy TLS for HA?",id:"why-haproxy-tls-for-ha",level:3},{value:"Prerequisites",id:"prerequisites-2",level:3},{value:"Prepare HAProxy PEM Certificate",id:"prepare-haproxy-pem-certificate",level:3},{value:"Configuration Using Helm Values (Recommended)",id:"configuration-using-helm-values-recommended",level:3},{value:"HAProxy TLS Configuration Parameters",id:"haproxy-tls-configuration-parameters",level:3},{value:"Alternative: Using Existing Kubernetes Secret",id:"alternative-using-existing-kubernetes-secret",level:3},{value:"What Happens Under the Hood",id:"what-happens-under-the-hood-1",level:3},{value:"Verify HAProxy TLS Configuration",id:"verify-haproxy-tls-configuration",level:3},{value:"Cluster Setup with Server-Only TLS (End-to-End Encryption)",id:"cluster-setup-with-server-only-tls-end-to-end-encryption",level:3},{value:"First-Time Installation",id:"first-time-installation-1",level:4},{value:"Upgrade Installation",id:"upgrade-installation-1",level:4},{value:"Verify Configuration",id:"verify-configuration",level:4},{value:"Updating TLS Configuration",id:"updating-tls-configuration",level:2},{value:"Server-Only TLS (Single Node and Cluster End-to-End Encryption)",id:"server-only-tls-single-node-and-cluster-end-to-end-encryption",level:3},{value:"HA Cluster (HAProxy TLS Termination)",id:"ha-cluster-haproxy-tls-termination",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Single Node Issues",id:"single-node-issues",level:3},{value:"HA Cluster Issues",id:"ha-cluster-issues",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2}],y={toc:f};function N(e){var t,r=e,{components:a}=r,c=((e,t)=>{var r={};for(var n in e)s.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&l)for(var n of l(e))t.indexOf(n)<0&&p.call(e,n)&&(r[n]=e[n]);return r})(r,["components"]);return(0,n.kt)("wrapper",(t=u(u({},y),c),i(t,o({components:a,mdxType:"MDXLayout"}))),(0,n.kt)("h1",u({},{id:"docker-setup"}),"Docker Setup"),(0,n.kt)("h2",u({},{id:"prerequisites"}),"Prerequisites"),(0,n.kt)("p",null,"Ensure you have the following files ready before configuring Mosquitto:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Server Certificate")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.crt"),"): The public server certificate."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Private Key")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.key"),"): The private key associated with the server certificate.")),(0,n.kt)("h2",u({},{id:"configuring-pro-mosquitto-broker-with-a-server-certificate"}),"Configuring Pro Mosquitto Broker with a Server Certificate"),(0,n.kt)("p",null,"This document outlines the two available methods for configuring a broker with a server certificate: using a proxy for TLS termination or configuring TLS directly on the broker. In cluster environments, the use of HAProxy, as provided in the default setup, is recommended for managing TLS termination."),(0,n.kt)("h3",u({},{id:"pro-mosquitto-tls-termination"}),"Pro Mosquitto TLS termination"),(0,n.kt)("p",null,"Open your ",(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.conf")," file to add a certificate to a certain port.\nAdd or modify the following settings to configure the Pro Mosquitto broker to use the server certificate:"),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"# Enable a listener on port 8883 for SSL/TLS connections\nlistener 8883\nprotocol mqtt\n\n# SSL/TLS certificate paths\ncertfile /path/to/server.crt\nkeyfile /path/to/server.key\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"listener 8883: Sets the port for SSL/TLS communication. Port 8883 is the standard MQTT SSL/TLS port."),(0,n.kt)("li",{parentName:"ul"},"certfile: Specifies the path to the server's public certificate file."),(0,n.kt)("li",{parentName:"ul"},"keyfile: Specifies the path to the server's private key file.")),(0,n.kt)("h3",u({},{id:"ha-proxy-tls-termination"}),"HA Proxy TLS termination"),(0,n.kt)("p",null,"In a cluster setup an HA Proxy is used for TLS termination. This is the default config of the frontend ",(0,n.kt)("inlineCode",{parentName:"p"},"haproxy.cfg"),"file:"),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"frontend mqtt_frontend\n    bind *:1883\n    mode tcp\n    default_backend mqtt_backend\n    timeout client 10m\n")),(0,n.kt)("p",null,"In order to enable TLS termination here add the following behind the ",(0,n.kt)("inlineCode",{parentName:"p"},"bind *:<port>")," parameter: ",(0,n.kt)("inlineCode",{parentName:"p"},"ssl crt /path/to/certs/server.pem"),"\nThis will do the TLS termination at the frontend stage before routing the traffic further to the set backend (here ",(0,n.kt)("inlineCode",{parentName:"p"},"mqtt_backend")," )."),(0,n.kt)("h3",u({},{id:"client-connections"}),"Client connections"),(0,n.kt)("p",null,"Use an MQTT client to connect to the broker using the secure port (e.g., 8883) to verify that the server certificate is being used:"),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"mosquitto_sub -h <broker-ip> -p 8883 -t test/topic --cafile /path/to/ca.crt\n")),(0,n.kt)("p",null,"In this example, a ",(0,n.kt)("inlineCode",{parentName:"p"},"--cafile")," parameter is added to the test because, depending on the device and the server certificate, your underlying system may not have the required CA in place to validate the server certificate you set."),(0,n.kt)("h3",u({},{id:"certificate-access"}),"Certificate access"),(0,n.kt)("p",null,"It is important that the files from the specified path are available to Pro Mosquitto. Ensure that the private key file is securely accessible to the Mosquitto service:"),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"sudo chmod 640 /path/to/server.key\nsudo chown mosquitto:mosquitto /path/to/server.key\n")),(0,n.kt)("p",null,"This ensures that only the Mosquitto service has access to the private key, enhancing security."),(0,n.kt)("p",null,"To apply the changes, restart Pro Mosquitto. Check the Mosquitto logs for troubleshooting if needed."),(0,n.kt)("h2",u({},{id:"configuring-cedalo-platform-with-a-server-certificate"}),"Configuring Cedalo Platform with a Server Certificate"),(0,n.kt)("p",null,"You can achieve https:// access either via a reverse proxy of your choice or by adding the server certificates directly to the platform via environment variables."),(0,n.kt)("h3",u({},{id:"environment-variables"}),"Environment Variables"),(0,n.kt)("p",null,"To conifgure the server certificates use the following Environment Variables:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"BASE_URL"),": URL the platform will be reachable at (should have the same IP/hostname as specified in the certificate)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"NEXTAUTH_URL"),": URL the platform will be reachable at (should have the same IP/hostname as specified in the certificate)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"MOSQUITTO_PLATFORM_HTTPS_KEY_PATH"),": Path to server's private key file (required)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"MOSQUITTO_PLATFORM_HTTPS_CERT_PATH"),": Path to server's certificate (required)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"MOSQUITTO_PLATFORM_HTTPS_CA_PATH"),": path to CA certificate (optional)")),(0,n.kt)("h3",u({},{id:"example-configuration"}),"Example configuration"),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{}),"            BASE_URL: https://192.168.178.27:3000\n            NEXTAUTH_URL: https://192.168.178.27:3000\n            MOSQUITTO_PLATFORM_HTTPS_KEY_PATH: /certs/cert.key\n            MOSQUITTO_PLATFORM_HTTPS_CERT_PATH: /certs/cert.crt\n")),(0,n.kt)("h3",u({},{id:"docker-compose"}),"Docker compose"),(0,n.kt)("p",null,"In docker based deployments make sure, that the linked certificates are reachable. A mount to the local directory allows you to store the used certs in the setup folders:"),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{}),"        volumes:\n            ...\n            - ./certs:/certs\n")),(0,n.kt)("h1",u({},{id:"kubernetesopenshift-setup"}),"Kubernetes/OpenShift Setup"),(0,n.kt)("h2",u({},{id:"tls-configuration-overview-for-kubernetesopenshift"}),"TLS Configuration Overview for Kubernetes/OpenShift"),(0,n.kt)("p",null,"The Helm charts for both Kubernetes and OpenShift support ",(0,n.kt)("strong",{parentName:"p"},"dynamic TLS configuration")," through ",(0,n.kt)("inlineCode",{parentName:"p"},"values.yaml")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"--set")," flags, eliminating the need to manually edit and repackage chart files. The approach differs between single-node and high-availability (HA) deployments:"),(0,n.kt)("h3",u({},{id:"key-differences"}),(0,n.kt)("strong",{parentName:"h3"},"Key Differences:")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",u({parentName:"tr"},{align:null}),"Deployment Type"),(0,n.kt)("th",u({parentName:"tr"},{align:null}),"TLS Termination Location"),(0,n.kt)("th",u({parentName:"tr"},{align:null}),"Certificate Format"),(0,n.kt)("th",u({parentName:"tr"},{align:null}),"Recommended Approach"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",u({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"td"},"Single Node")),(0,n.kt)("td",u({parentName:"tr"},{align:null}),"Mosquitto Broker"),(0,n.kt)("td",u({parentName:"tr"},{align:null}),"Separate cert + key files"),(0,n.kt)("td",u({parentName:"tr"},{align:null}),"Direct Mosquitto TLS")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",u({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"td"},"HA Cluster")),(0,n.kt)("td",u({parentName:"tr"},{align:null}),"HAProxy Load Balancer"),(0,n.kt)("td",u({parentName:"tr"},{align:null}),"Combined PEM file (cert+key)"),(0,n.kt)("td",u({parentName:"tr"},{align:null}),"HAProxy TLS Termination")))),(0,n.kt)("h3",u({},{id:"why-different-approaches"}),(0,n.kt)("strong",{parentName:"h3"},"Why Different Approaches?")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Single Node"),": TLS is configured directly on the Mosquitto broker since there's no load balancer in front."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"HA Cluster"),": TLS termination at HAProxy provides centralized certificate management, simplifies the setup, and allows the load balancer to handle secure connections before routing to Mosquitto brokers.")),(0,n.kt)("hr",null),(0,n.kt)("h2",u({},{id:"single-node-tls-configuration-server-only-tls"}),"Single Node TLS Configuration (Server-Only TLS)"),(0,n.kt)("p",null,"For single-node deployments, TLS is configured directly on the Mosquitto broker using server-only TLS. This enables one-way TLS where only the server presents a certificate to clients."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("em",{parentName:"strong"},"Note:"))," For OpenShift deployments, replace ",(0,n.kt)("inlineCode",{parentName:"p"},"kubectl")," with ",(0,n.kt)("inlineCode",{parentName:"p"},"oc")," in all commands below. Chart directory names:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Kubernetes Single Node: ",(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto-platform-kubernetes-sn")),(0,n.kt)("li",{parentName:"ul"},"OpenShift Single Node: ",(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto-platform-openshift-sn"))),(0,n.kt)("h3",u({},{id:"prerequisites-1"}),"Prerequisites"),(0,n.kt)("p",null,"Ensure you have the following files ready:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Server Certificate")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.crt"),"): The public server certificate"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Private Key")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.key"),"): The private key associated with the server certificate")),(0,n.kt)("h3",u({},{id:"secret-creation"}),"Secret Creation"),(0,n.kt)("p",null,"Certificates can be created externally to Helm charts using ",(0,n.kt)("inlineCode",{parentName:"p"},"kubectl")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"oc")," commands. This is the ",(0,n.kt)("strong",{parentName:"p"},"recommended approach")," as it's easier and provides better control over secret management. When using external secrets, set ",(0,n.kt)("inlineCode",{parentName:"p"},"createSecret: false")," in your Helm installation."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Note:")," The secret names and paths mentioned here are ",(0,n.kt)("strong",{parentName:"p"},"default values")," and can be configured via Helm values. See the Configuration Parameters section below for customization options."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For Kubernetes:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),'# Set namespace\nNAMESPACE="your-namespace"\n\n# Create server-only TLS certificate secret (using default secret name)\nkubectl create secret generic mosquitto-server-tls \\\n  --from-file=server.crt=server.crt \\\n  --from-file=server.key=server.key \\\n  -n $NAMESPACE\n')),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For OpenShift:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),'# Set namespace\nNAMESPACE="your-namespace"\n\n# Create server-only TLS certificate secret (using default secret name)\noc create secret generic mosquitto-server-tls \\\n  --from-file=server.crt=server.crt \\\n  --from-file=server.key=server.key \\\n  -n $NAMESPACE\n')),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Note:")," When creating secrets externally, ensure the secret name matches ",(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.secretName")," (default: ",(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto-server-tls"),") and the secret keys match the ",(0,n.kt)("inlineCode",{parentName:"p"},"certFile")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"keyFile")," values (defaults: ",(0,n.kt)("inlineCode",{parentName:"p"},"server.crt")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"server.key"),"). Set ",(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.createSecret=false")," in your Helm installation to use the externally created secret."),(0,n.kt)("h3",u({},{id:"first-time-installation"}),"First-Time Installation"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For Kubernetes Single Node:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),'# Set namespace\nNAMESPACE="your-namespace"\n\n# Install with serverOnlyTLS enabled\nhelm install mosquitto-platform \\\n  ./mosquitto-platform-kubernetes-sn \\\n  -n $NAMESPACE \\\n  -f values.yaml \\\n  --set mosquitto.serverOnlyTls.enabled=true \\\n  --set mosquitto.serverOnlyTls.createSecret=false\n')),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For OpenShift Single Node:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),'# Set namespace\nNAMESPACE="your-namespace"\n\n# Install with serverOnlyTLS enabled\nhelm install mosquitto-platform \\\n  ./mosquitto-platform-openshift-sn \\\n  -n $NAMESPACE \\\n  -f values.yaml \\\n  --set mosquitto.serverOnlyTls.enabled=true \\\n  --set mosquitto.serverOnlyTls.createSecret=false\n')),(0,n.kt)("h3",u({},{id:"upgrade-installation"}),"Upgrade Installation"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For Kubernetes Single Node:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),'# Set namespace\nNAMESPACE="your-namespace"\n\n# Upgrade with serverOnlyTLS enabled\nhelm upgrade mosquitto-platform \\\n  ./mosquitto-platform-kubernetes-sn \\\n  -n $NAMESPACE \\\n  -f values.yaml \\\n  --set mosquitto.serverOnlyTls.enabled=true \\\n  --set mosquitto.serverOnlyTls.createSecret=false\n')),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For OpenShift Single Node:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),'# Set namespace\nNAMESPACE="your-namespace"\n\n# Upgrade with serverOnlyTLS enabled\nhelm upgrade mosquitto-platform \\\n  ./mosquitto-platform-openshift-sn \\\n  -n $NAMESPACE \\\n  -f values.yaml \\\n  --set mosquitto.serverOnlyTls.enabled=true \\\n  --set mosquitto.serverOnlyTls.createSecret=false\n')),(0,n.kt)("h3",u({},{id:"configuration-parameters"}),"Configuration Parameters"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Note:")," All secret names, file names, and mount paths mentioned below are ",(0,n.kt)("strong",{parentName:"p"},"default values")," and can be customized via Helm values. You can override any of these defaults to match your specific requirements."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.enabled"),": Enable server-only TLS listener on port 8883. When enabled, Mosquitto will present a server certificate to clients for authentication. Default: ",(0,n.kt)("inlineCode",{parentName:"p"},"false"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.secretName"),": Kubernetes Secret name containing server TLS certificates. This secret must exist if ",(0,n.kt)("inlineCode",{parentName:"p"},"createSecret")," is set to ",(0,n.kt)("inlineCode",{parentName:"p"},"false"),". Default: ",(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto-server-tls"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.createSecret"),": If ",(0,n.kt)("inlineCode",{parentName:"p"},"true"),", Helm will create the secret from ",(0,n.kt)("inlineCode",{parentName:"p"},"certContent")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"keyContent"),". If ",(0,n.kt)("inlineCode",{parentName:"p"},"false"),", the secret must exist externally (created via ",(0,n.kt)("inlineCode",{parentName:"p"},"kubectl")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"oc"),"). ",(0,n.kt)("strong",{parentName:"p"},"Recommended approach"),": Set to ",(0,n.kt)("inlineCode",{parentName:"p"},"false")," and create secrets externally using ",(0,n.kt)("inlineCode",{parentName:"p"},"kubectl create secret")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"oc create secret")," commands, as this is easier and provides better control over secret management. Default: ",(0,n.kt)("inlineCode",{parentName:"p"},"true"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.certFile"),": Certificate file name (key) in the Kubernetes Secret. This should match the key name used when creating the secret externally. Default: ",(0,n.kt)("inlineCode",{parentName:"p"},"server.crt"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.keyFile"),": Private key file name (key) in the Kubernetes Secret. This should match the key name used when creating the secret externally. Default: ",(0,n.kt)("inlineCode",{parentName:"p"},"server.key"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.tlsMountPath"),": Directory path where server TLS certificates are mounted in the container. Should be a ",(0,n.kt)("strong",{parentName:"p"},"DIRECTORY path only")," (e.g., ",(0,n.kt)("inlineCode",{parentName:"p"},"/mosquitto/certs"),"). Do not include the filename. Default: ",(0,n.kt)("inlineCode",{parentName:"p"},"/mosquitto/certs"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.certName"),": Certificate filename when mounted in the container. Should be a ",(0,n.kt)("strong",{parentName:"p"},"FILENAME only")," (e.g., ",(0,n.kt)("inlineCode",{parentName:"p"},"server.crt"),"), no path. The final path is constructed as: ",(0,n.kt)("inlineCode",{parentName:"p"},"tlsMountPath/certName")," = ",(0,n.kt)("inlineCode",{parentName:"p"},"/mosquitto/certs/server.crt"),". Default: ",(0,n.kt)("inlineCode",{parentName:"p"},"server.crt"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.keyName"),": Private key filename when mounted in the container. Should be a ",(0,n.kt)("strong",{parentName:"p"},"FILENAME only")," (e.g., ",(0,n.kt)("inlineCode",{parentName:"p"},"server.key"),"), no path. The final path is constructed as: ",(0,n.kt)("inlineCode",{parentName:"p"},"tlsMountPath/keyName")," = ",(0,n.kt)("inlineCode",{parentName:"p"},"/mosquitto/certs/server.key"),". Default: ",(0,n.kt)("inlineCode",{parentName:"p"},"server.key"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.certContent"),": Base64-encoded server certificate content. Only used when ",(0,n.kt)("inlineCode",{parentName:"p"},"createSecret: true"),". If ",(0,n.kt)("inlineCode",{parentName:"p"},"createSecret: false"),", this parameter is ignored and the secret must be created externally with keys matching ",(0,n.kt)("inlineCode",{parentName:"p"},"certFile")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"keyFile"),". Default: ",(0,n.kt)("inlineCode",{parentName:"p"},'""')," (empty string)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.serverOnlyTls.keyContent"),": Base64-encoded server private key content. Only used when ",(0,n.kt)("inlineCode",{parentName:"p"},"createSecret: true"),". If ",(0,n.kt)("inlineCode",{parentName:"p"},"createSecret: false"),", this parameter is ignored and the secret must be created externally with keys matching ",(0,n.kt)("inlineCode",{parentName:"p"},"certFile")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"keyFile"),". Default: ",(0,n.kt)("inlineCode",{parentName:"p"},'""')," (empty string)"))),(0,n.kt)("h3",u({},{id:"what-happens-under-the-hood"}),"What Happens Under the Hood"),(0,n.kt)("p",null,"When you enable serverOnlyTLS, the Helm chart automatically:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Mounts the Secret as a volume in the Mosquitto StatefulSet at the configured mount path (default: ",(0,n.kt)("inlineCode",{parentName:"li"},"/mosquitto/certs"),")"),(0,n.kt)("li",{parentName:"ol"},"Updates ",(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.conf")," to enable the TLS listener on port 8883:",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",u({parentName:"pre"},{}),"listener 8883\nprotocol mqtt\ncertfile /mosquitto/certs/server.crt\nkeyfile /mosquitto/certs/server.key\n")),(0,n.kt)("strong",{parentName:"li"},"Note:")," The paths shown above are defaults. The actual paths are constructed from ",(0,n.kt)("inlineCode",{parentName:"li"},"tlsMountPath/certName")," and ",(0,n.kt)("inlineCode",{parentName:"li"},"tlsMountPath/keyName")," which are configurable."),(0,n.kt)("li",{parentName:"ol"},"Exposes port 8883 on the Mosquitto service")),(0,n.kt)("h3",u({},{id:"verify-tls-configuration"}),"Verify TLS Configuration"),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"# Check the Mosquitto service ports\nkubectl get svc mosquitto -n $NAMESPACE\n\n# Check server certificates are mounted\nkubectl exec mosquitto-0 -n $NAMESPACE -- ls -la /mosquitto/certs/\n# Should show: server.crt and server.key\n\n# Verify Mosquitto configuration\nkubectl exec mosquitto-0 -n $NAMESPACE -- grep -A 5 \"listener.*8883\" /mosquitto/config/mosquitto.conf\n\n# Test TLS connection\nmosquitto_sub -h <mosquitto-external-ip> -p 8883 --cafile ca.crt -u <username> -P <password> -t '#'\n")),(0,n.kt)("h3",u({},{id:"important-path-configuration-notes"}),"Important Path Configuration Notes"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"IMPORTANT"),": Follow these conventions to avoid path configuration errors:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"tlsMountPath"),": Should be a ",(0,n.kt)("strong",{parentName:"li"},"DIRECTORY path only")," (e.g., ",(0,n.kt)("inlineCode",{parentName:"li"},"/mosquitto/certs"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"certName"),"/",(0,n.kt)("inlineCode",{parentName:"li"},"keyName"),": Should be ",(0,n.kt)("strong",{parentName:"li"},"FILENAMES only")," (e.g., ",(0,n.kt)("inlineCode",{parentName:"li"},"server.crt"),", ",(0,n.kt)("inlineCode",{parentName:"li"},"server.key"),")"),(0,n.kt)("li",{parentName:"ul"},"Final path is constructed as: ",(0,n.kt)("inlineCode",{parentName:"li"},"tlsMountPath/certName")," = ",(0,n.kt)("inlineCode",{parentName:"li"},"/mosquitto/certs/server.crt")),(0,n.kt)("li",{parentName:"ul"},"\u274c ",(0,n.kt)("strong",{parentName:"li"},"WRONG"),": Setting ",(0,n.kt)("inlineCode",{parentName:"li"},"tlsMountPath")," to ",(0,n.kt)("inlineCode",{parentName:"li"},"/mosquitto/certs/server.crt")," (includes filename)"),(0,n.kt)("li",{parentName:"ul"},"\u2705 ",(0,n.kt)("strong",{parentName:"li"},"CORRECT"),": ",(0,n.kt)("inlineCode",{parentName:"li"},'tlsMountPath="/mosquitto/certs"')," and ",(0,n.kt)("inlineCode",{parentName:"li"},'certName="server.crt"'))),(0,n.kt)("hr",null),(0,n.kt)("h2",u({},{id:"ha-cluster-tls-configuration"}),"HA Cluster TLS Configuration"),(0,n.kt)("p",null,"For High-Availability (HA) cluster deployments, ",(0,n.kt)("strong",{parentName:"p"},"TLS termination occurs at the HAProxy load balancer"),", not on individual Mosquitto brokers. This is the ",(0,n.kt)("strong",{parentName:"p"},"recommended approach")," for production HA deployments."),(0,n.kt)("h3",u({},{id:"why-haproxy-tls-for-ha"}),"Why HAProxy TLS for HA?"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"\u2705 ",(0,n.kt)("strong",{parentName:"li"},"Centralized certificate management"),": Update certificates in one place"),(0,n.kt)("li",{parentName:"ul"},"\u2705 ",(0,n.kt)("strong",{parentName:"li"},"Simplified configuration"),": No need to configure TLS on each broker"),(0,n.kt)("li",{parentName:"ul"},"\u2705 ",(0,n.kt)("strong",{parentName:"li"},"Better performance"),": Offload TLS processing to HAProxy"),(0,n.kt)("li",{parentName:"ul"},"\u2705 ",(0,n.kt)("strong",{parentName:"li"},"Easier certificate rotation"),": Update one HAProxy Secret vs. multiple broker Secrets")),(0,n.kt)("h3",u({},{id:"prerequisites-2"}),"Prerequisites"),(0,n.kt)("p",null,"Ensure you have the following:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Server Certificate")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.crt"),"): The public server certificate"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Private Key")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.key"),"): The private key associated with the server certificate")),(0,n.kt)("h3",u({},{id:"prepare-haproxy-pem-certificate"}),"Prepare HAProxy PEM Certificate"),(0,n.kt)("p",null,"HAProxy requires certificates in ",(0,n.kt)("strong",{parentName:"p"},"PEM format")," with the certificate and private key ",(0,n.kt)("strong",{parentName:"p"},"combined")," in a single file:"),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"# Combine certificate and key into a single PEM file\ncat server.crt server.key > haproxy_combined.pem\n\n# Encode to base64 for Kubernetes Secret\ncat haproxy_combined.pem | base64 -w 0 > haproxy_combined_base64.txt\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Important"),": The order matters! Certificate first, then the private key."),(0,n.kt)("h3",u({},{id:"configuration-using-helm-values-recommended"}),"Configuration Using Helm Values (Recommended)"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Install with HAProxy TLS Configuration")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),'# Read base64 content\nPEM_CONTENT=$(cat haproxy_combined_base64.txt)\n\n# Install with HAProxy TLS enabled\nhelm install my-ha-cluster mosquitto-3.1-platform-3.1-kubernetes-cluster.tgz -n ha \\\n  --set licenseKey=<your-license-key> \\\n  --set nameserver=10.0.0.10 \\\n  --set haproxy.tls.enabled=true \\\n  --set haproxy.tls.pemContent="$PEM_CONTENT" \\\n  --set haproxy.tls.secretName="haproxy-tls-certs" \\\n  --set haproxy.tls.pemFile="haproxy_combined.pem" \\\n  --set haproxy.ports.secureListener=8883\n')),(0,n.kt)("h3",u({},{id:"haproxy-tls-configuration-parameters"}),"HAProxy TLS Configuration Parameters"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.enabled"),": Enable HAProxy TLS termination. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"false")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.secretName"),": Kubernetes Secret name for HAProxy certificates. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"haproxy-tls-certs")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.pemFile"),": PEM filename (combined cert+key). Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"haproxy_combined.pem")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.pemContent"),": Base64-encoded PEM content (cert+key combined)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.pemPath"),": Full path to PEM file in container. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"/etc/haproxy/certs/haproxy_combined.pem")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.tlsHaproxyPemDirPath"),": Directory path for HAProxy certificates. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"/etc/haproxy/certs")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.ports.secureListener"),": HAProxy secure MQTT port. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"8883")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.ports.secureListenerTarget"),": Target port for secure connection. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"8883"))),(0,n.kt)("h3",u({},{id:"alternative-using-existing-kubernetes-secret"}),"Alternative: Using Existing Kubernetes Secret"),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"# Create Kubernetes Secret with PEM file\nkubectl create secret generic haproxy-tls-certs -n ha \\\n  --from-file=haproxy_combined.pem=./haproxy_combined.pem\n\n# Install referencing existing secret\nhelm install my-ha-cluster mosquitto-3.1-platform-3.1-kubernetes-cluster.tgz -n ha \\\n  --set licenseKey=<your-license-key> \\\n  --set nameserver=10.0.0.10 \\\n  --set haproxy.tls.enabled=true \\\n  --set haproxy.tls.secretName=haproxy-tls-certs\n")),(0,n.kt)("h3",u({},{id:"what-happens-under-the-hood-1"}),"What Happens Under the Hood"),(0,n.kt)("p",null,"When you enable HAProxy TLS, the Helm chart automatically:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Creates a Kubernetes Secret (",(0,n.kt)("inlineCode",{parentName:"li"},"haproxy-tls-certs"),") with your PEM certificate"),(0,n.kt)("li",{parentName:"ol"},"Mounts the Secret as a volume in the HAProxy Deployment at ",(0,n.kt)("inlineCode",{parentName:"li"},"/etc/haproxy/certs")),(0,n.kt)("li",{parentName:"ol"},"Updates HAProxy configuration to add a secure frontend:",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",u({parentName:"pre"},{}),"frontend mqtt_frontend_secure\n    bind *:8883 ssl crt /etc/haproxy/certs/haproxy_combined.pem\n    mode tcp\n    maxconn 10000\n    default_backend mqtt_backend\n    timeout client 10m\n"))),(0,n.kt)("li",{parentName:"ol"},"Exposes port 8883 on the HAProxy LoadBalancer service"),(0,n.kt)("li",{parentName:"ol"},"Routes secure traffic to Mosquitto brokers (non-TLS communication between HAProxy and brokers)")),(0,n.kt)("h3",u({},{id:"verify-haproxy-tls-configuration"}),"Verify HAProxy TLS Configuration"),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"# Check HAProxy service ports (should show both 1883 and 8883)\nkubectl get svc haproxy -n ha\n\n# Test TLS connection through HAProxy\nmosquitto_sub -h <haproxy-external-ip> -p 8883 --cafile ca.crt -u <username> -P <password> -t '#'\n")),(0,n.kt)("h3",u({},{id:"cluster-setup-with-server-only-tls-end-to-end-encryption"}),"Cluster Setup with Server-Only TLS (End-to-End Encryption)"),(0,n.kt)("p",null,"If you require encryption ",(0,n.kt)("strong",{parentName:"p"},"between HAProxy and Mosquitto brokers")," (end-to-end encryption), you can enable serverOnlyTLS on Mosquitto. HAProxy will automatically perform TCP passthrough, allowing Mosquitto to handle TLS termination directly."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("em",{parentName:"strong"},"Note:"))," For OpenShift deployments, replace ",(0,n.kt)("inlineCode",{parentName:"p"},"kubectl")," with ",(0,n.kt)("inlineCode",{parentName:"p"},"oc")," in all commands below. Chart directory names:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Kubernetes Cluster: ",(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto-platform-kubernetes-cluster")),(0,n.kt)("li",{parentName:"ul"},"OpenShift Cluster: ",(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto-platform-openshift-cluster"))),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Prerequisites, Secret Creation, and Configuration Parameters:")," See the ",(0,n.kt)("a",u({parentName:"p"},{href:"#single-node-tls-configuration-server-only-tls"}),"Single Node TLS Configuration (Server-Only TLS)")," section above. The same prerequisites, secret creation steps, and configuration parameters apply to cluster deployments."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Key Differences for Cluster Deployments:")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Use cluster chart directories: ",(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto-platform-kubernetes-cluster")," or ",(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto-platform-openshift-cluster")),(0,n.kt)("li",{parentName:"ul"},"HAProxy automatically performs TCP passthrough when serverOnlyTLS is enabled"),(0,n.kt)("li",{parentName:"ul"},"HAProxy rollout is required after installation/upgrade to pick up configuration changes")),(0,n.kt)("h4",u({},{id:"first-time-installation-1"}),"First-Time Installation"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For Kubernetes Cluster:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),'# Set namespace\nNAMESPACE="your-namespace"\n\n# Install with serverOnlyTLS enabled\nhelm install mosquitto-platform \\\n  ./mosquitto-platform-kubernetes-cluster \\\n  -n $NAMESPACE \\\n  -f values.yaml \\\n  --set mosquitto.serverOnlyTls.enabled=true \\\n  --set mosquitto.serverOnlyTls.createSecret=false\n\n# Rollout HAProxy to pick up serverOnlyTLS configuration\nkubectl rollout restart deployment haproxy -n $NAMESPACE\n')),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For OpenShift Cluster:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),'# Set namespace\nNAMESPACE="your-namespace"\n\n# Install with serverOnlyTLS enabled\nhelm install mosquitto-platform \\\n  ./mosquitto-platform-openshift-cluster \\\n  -n $NAMESPACE \\\n  -f values.yaml \\\n  --set mosquitto.serverOnlyTls.enabled=true \\\n  --set mosquitto.serverOnlyTls.createSecret=false\n\n# Rollout HAProxy to pick up serverOnlyTLS configuration\noc rollout restart deployment haproxy -n $NAMESPACE\n')),(0,n.kt)("h4",u({},{id:"upgrade-installation-1"}),"Upgrade Installation"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For Kubernetes Cluster:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),'# Set namespace\nNAMESPACE="your-namespace"\n\n# Upgrade with serverOnlyTLS enabled\nhelm upgrade mosquitto-platform \\\n  ./mosquitto-platform-kubernetes-cluster \\\n  -n $NAMESPACE \\\n  -f values.yaml \\\n  --set mosquitto.serverOnlyTls.enabled=true \\\n  --set mosquitto.serverOnlyTls.createSecret=false\n\n# Rollout HAProxy to pick up serverOnlyTLS configuration changes\nkubectl rollout restart deployment haproxy -n $NAMESPACE\n')),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For OpenShift Cluster:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),'# Set namespace\nNAMESPACE="your-namespace"\n\n# Upgrade with serverOnlyTLS enabled\nhelm upgrade mosquitto-platform \\\n  ./mosquitto-platform-openshift-cluster \\\n  -n $NAMESPACE \\\n  -f values.yaml \\\n  --set mosquitto.serverOnlyTls.enabled=true \\\n  --set mosquitto.serverOnlyTls.createSecret=false\n\n# Rollout HAProxy to pick up serverOnlyTLS configuration changes\noc rollout restart deployment haproxy -n $NAMESPACE\n')),(0,n.kt)("h4",u({},{id:"verify-configuration"}),"Verify Configuration"),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"# Check server certificates are mounted\nkubectl exec mosquitto-0 -n $NAMESPACE -- ls -la /mosquitto/certs/\n# Should show: server.crt and server.key\n\n# Verify Mosquitto configuration\nkubectl exec mosquitto-0 -n $NAMESPACE -- grep -A 5 \"listener.*8883\" /mosquitto/config/mosquitto.conf\n# Should show serverOnlyTLS listener configuration with certfile and keyfile\n\n# Test TLS connection through HAProxy (TCP passthrough)\nmosquitto_sub -h <haproxy-external-ip> -p 8883 --cafile ca.crt -u <username> -P <password> -t '#'\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Note"),": This approach provides end-to-end encryption where TLS is terminated at Mosquitto brokers. HAProxy performs TCP passthrough and does not inspect or terminate TLS traffic. This is typically ",(0,n.kt)("strong",{parentName:"p"},"not required")," for most deployments, as communication between HAProxy and Mosquitto occurs within the Kubernetes cluster network. For most use cases, HAProxy TLS termination (described above) is the recommended approach."),(0,n.kt)("hr",null),(0,n.kt)("h2",u({},{id:"updating-tls-configuration"}),"Updating TLS Configuration"),(0,n.kt)("p",null,"To update certificates after initial deployment:"),(0,n.kt)("h3",u({},{id:"server-only-tls-single-node-and-cluster-end-to-end-encryption"}),"Server-Only TLS (Single Node and Cluster End-to-End Encryption)"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Note:")," This process applies to both single node deployments and cluster deployments using serverOnlyTLS for end-to-end encryption. Both use the same secret (",(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto-server-tls"),") and update process."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For Kubernetes:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"# Update the secret with new certificates\nkubectl create secret generic mosquitto-server-tls \\\n  --from-file=server.crt=server.crt \\\n  --from-file=server.key=server.key \\\n  -n $NAMESPACE \\\n  --dry-run=client -o yaml | kubectl apply -f -\n\n# Restart pods to pick up new certificates\nkubectl rollout restart statefulset mosquitto -n $NAMESPACE\n\n# For cluster deployments, also restart HAProxy\nkubectl rollout restart deployment haproxy -n $NAMESPACE\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For OpenShift:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"# Update the secret with new certificates\noc create secret generic mosquitto-server-tls \\\n  --from-file=server.crt=server.crt \\\n  --from-file=server.key=server.key \\\n  -n $NAMESPACE \\\n  --dry-run=client -o yaml | oc apply -f -\n\n# Restart pods to pick up new certificates\noc rollout restart statefulset mosquitto -n $NAMESPACE\n\n# For cluster deployments, also restart HAProxy\noc rollout restart deployment haproxy -n $NAMESPACE\n")),(0,n.kt)("h3",u({},{id:"ha-cluster-haproxy-tls-termination"}),"HA Cluster (HAProxy TLS Termination)"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For Kubernetes:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"# Update HAProxy certificates\nkubectl create secret generic haproxy-tls-certs \\\n  --from-file=haproxy_combined.pem=./haproxy_combined.pem \\\n  -n $NAMESPACE \\\n  --dry-run=client -o yaml | kubectl apply -f -\n\n# Restart HAProxy to pick up new certificates\nkubectl rollout restart deployment haproxy -n $NAMESPACE\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For OpenShift:")),(0,n.kt)("pre",null,(0,n.kt)("code",u({parentName:"pre"},{className:"language-bash"}),"# Update HAProxy certificates\noc create secret generic haproxy-tls-certs \\\n  --from-file=haproxy_combined.pem=./haproxy_combined.pem \\\n  -n $NAMESPACE \\\n  --dry-run=client -o yaml | oc apply -f -\n\n# Restart HAProxy to pick up new certificates\noc rollout restart deployment haproxy -n $NAMESPACE\n")),(0,n.kt)("hr",null),(0,n.kt)("h2",u({},{id:"troubleshooting"}),"Troubleshooting"),(0,n.kt)("h3",u({},{id:"single-node-issues"}),"Single Node Issues"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Connection Refused on Port 8883")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Verify ",(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.serverOnlyTls.enabled=true")," is set"),(0,n.kt)("li",{parentName:"ul"},"Check service exposes port 8883: ",(0,n.kt)("inlineCode",{parentName:"li"},"kubectl get svc mosquitto -n $NAMESPACE")),(0,n.kt)("li",{parentName:"ul"},"Verify certificates are mounted: ",(0,n.kt)("inlineCode",{parentName:"li"},"kubectl exec mosquitto-0 -n $NAMESPACE -- ls -la /mosquitto/certs"))),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Certificate Validation Errors")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Ensure certificate matches the hostname/IP you're connecting to"),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"--cafile")," flag to provide CA certificate if not in system trust store")),(0,n.kt)("h3",u({},{id:"ha-cluster-issues"}),"HA Cluster Issues"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Connection Refused on Port 8883 (HAProxy)")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Verify ",(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.enabled=true")," is set"),(0,n.kt)("li",{parentName:"ul"},"Check HAProxy service exposes port 8883: ",(0,n.kt)("inlineCode",{parentName:"li"},"kubectl get svc haproxy -n ha")),(0,n.kt)("li",{parentName:"ul"},"Verify PEM file is mounted: ",(0,n.kt)("inlineCode",{parentName:"li"},"kubectl exec <haproxy-pod> -n ha -- ls -la /etc/haproxy/certs"))),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Invalid PEM Format")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Ensure certificate and key are combined in correct order: certificate first, then key"),(0,n.kt)("li",{parentName:"ul"},"Verify base64 encoding is correct: ",(0,n.kt)("inlineCode",{parentName:"li"},'echo "$PEM_CONTENT" | base64 -d | openssl x509 -text'))),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"HAProxy Not Starting")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Check HAProxy logs: ",(0,n.kt)("inlineCode",{parentName:"li"},"kubectl logs <haproxy-pod> -n ha")),(0,n.kt)("li",{parentName:"ul"},"Common issue: Missing or incorrectly formatted PEM file")),(0,n.kt)("hr",null),(0,n.kt)("h2",u({},{id:"security-best-practices"}),"Security Best Practices"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Use Strong Certificates"),": Use certificates from a trusted CA or properly configured self-signed certificates"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Secure Private Keys"),": Never commit private keys to version control"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Rotate Certificates Regularly"),": Update certificates before expiration"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Use Kubernetes Secrets"),": Store certificates in Kubernetes Secrets, not in plain text"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Restrict Secret Access"),": Use Kubernetes RBAC to limit who can access certificate Secrets"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Monitor Certificate Expiration"),": Set up alerts for certificate expiration"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"For HA"),": Always use HAProxy TLS termination instead of individual broker TLS for easier management")))}N.isMDXComponent=!0}}]);