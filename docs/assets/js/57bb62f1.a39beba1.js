"use strict";(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[11434],{83166:(e,t,n)=>{var a=n(64836);t.Z=void 0;var i=a(n(64938)),o=n(85893),r=(0,i.default)((0,o.jsx)("path",{d:"M12 2 4 5v6.09c0 5.05 3.41 9.76 8 10.91 4.59-1.15 8-5.86 8-10.91V5l-8-3zm-1.06 13.54L7.4 12l1.41-1.41 2.12 2.12 4.24-4.24 1.41 1.41-5.64 5.66z"}),"GppGood");t.Z=r},61327:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>k,contentTitle:()=>h,default:()=>N,frontMatter:()=>u,metadata:()=>f,toc:()=>g});var a=n(3905),i=n(49044),o=Object.defineProperty,r=Object.defineProperties,l=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,p=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,m=(e,t,n)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,c=(e,t)=>{for(var n in t||(t={}))p.call(t,n)&&m(e,n,t[n]);if(s)for(var n of s(t))d.call(t,n)&&m(e,n,t[n]);return e};const u={id:"sql-bridge",title:"SQL Bridges",sidebar_label:"SQL Bridges"},h=void 0,f={unversionedId:"bridges/sql-bridge",id:"version-3.1/bridges/sql-bridge",title:"SQL Bridges",description:"Coming soon: Configuring this plugin will soon be easier than ever before. Find more information about this here.",source:"@site/mosquitto_versioned_docs/version-3.1/bridges/sql-bridge.md",sourceDirName:"bridges",slug:"/bridges/sql-bridge",permalink:"/mosquitto/bridges/sql-bridge",draft:!1,tags:[],version:"3.1",frontMatter:{id:"sql-bridge",title:"SQL Bridges",sidebar_label:"SQL Bridges"},sidebar:"someSidebar",previous:{title:"Snowflake Bridge",permalink:"/mosquitto/bridges/snowflake-bridge"},next:{title:"Broker Home",permalink:"/mosquitto/monitoring/broker-home"}},k={},g=[{value:"Plugin Activation",id:"plugin-activation",level:2},{value:"Config File Format",id:"config-file-format",level:2},{value:"Mapping MQTT packets to database table columns",id:"mapping-mqtt-packets-to-database-table-columns",level:2},{value:"Column type casting",id:"column-type-casting",level:2},{value:"Selector options",id:"selector-options",level:2},{value:"Configuration example",id:"configuration-example",level:2},{value:"Error handling",id:"error-handling",level:2},{value:"Debugging",id:"debugging",level:2},{value:"Case sensitivity",id:"case-sensitivity",level:2},{value:"Buffering",id:"buffering",level:2},{value:"Retry queue",id:"retry-queue",level:2},{value:"JSON Schema",id:"json-schema",level:2}],b={toc:g};function N(e){var t,n=e,{components:o}=n,m=((e,t)=>{var n={};for(var a in e)p.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&s)for(var a of s(e))t.indexOf(a)<0&&d.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=c(c({},b),m),r(t,l({components:o,mdxType:"MDXLayout"}))),(0,a.kt)(i.Z,{mdxType:"PremiumFeature"}),(0,a.kt)("admonition",c({},{type:"info"}),(0,a.kt)("p",{parentName:"admonition"},"Coming soon: Configuring this plugin will soon be easier than ever before. Find more information about this ",(0,a.kt)("a",c({parentName:"p"},{href:"#INSERT_LINK"}),"here"),".")),(0,a.kt)("p",null,"The SQL Bridge plugin can be used to forward data published to the Mosquitto broker to various relational databases.\nThe plugin can handle multiple database connections. For each connection, a mapping between certain MQTT topics and database tables can be defined (see ",(0,a.kt)("a",c({parentName:"p"},{href:"#configuration-example"}),"example configuration"),")."),(0,a.kt)("p",null,"The list of currently supported DBMS:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"PostgreSQL"),(0,a.kt)("li",{parentName:"ul"},"TimescaleDB"),(0,a.kt)("li",{parentName:"ul"},"MySQL"),(0,a.kt)("li",{parentName:"ul"},"AlloyDB"),(0,a.kt)("li",{parentName:"ul"},"MariaDB"),(0,a.kt)("li",{parentName:"ul"},"Amazon Redshift"),(0,a.kt)("li",{parentName:"ul"},"Microsoft SQL"),(0,a.kt)("li",{parentName:"ul"},"OracleDB"),(0,a.kt)("li",{parentName:"ul"},"CockroachDB")),(0,a.kt)("p",null,"SQL bridge supports basic (username, password) authentication."),(0,a.kt)("p",null,"The plugin manages incoming MQTT messages in a buffer to perform batching and leverage batch inserting capabilities of the databases. The size properties of the buffer can be controlled via the config file (",(0,a.kt)("inlineCode",{parentName:"p"},"sql-bridge.json"),") in the ",(0,a.kt)("inlineCode",{parentName:"p"},"options")," section, with ",(0,a.kt)("inlineCode",{parentName:"p"},"bufferSize"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"batchSize"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"timeoutMs")," (refer to ",(0,a.kt)("a",c({parentName:"p"},{href:"#config-file-format"}),"config file format"),")."),(0,a.kt)("h2",c({},{id:"plugin-activation"}),"Plugin Activation"),(0,a.kt)("p",null,"To enable the SQL Bridge plugin in the broker add the following to the ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquitto.conf")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{}),"plugin /usr/lib/cedalo_sql_bridge.so\n\npersistence_location /mosquitto/data\n")),(0,a.kt)("p",null,"This is an example configuration snippet applicable to the docker container setup. For installation not running in a container the above configuration needs to be adjusted accordingly (namely the location of ",(0,a.kt)("inlineCode",{parentName:"p"},"cedalo_sql_bridge.so")," dynamic library and ",(0,a.kt)("inlineCode",{parentName:"p"},"persistence_location")," may differ)."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"persistence_location")," is used as the search base path for the plugin's config file."),(0,a.kt)("p",null,"In addition to modifying ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquitto.conf"),", ensure that you have the appropriate license (with the required database integrations) to use the plugin."),(0,a.kt)("h2",c({},{id:"config-file-format"}),"Config File Format"),(0,a.kt)("p",null,"The configuration is stored in a single JSON file (called ",(0,a.kt)("inlineCode",{parentName:"p"},"sql-bridge.json")," by default) located inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"persistence_location"),", which is defined in ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquitto.conf"),". To use a different config file name, ",(0,a.kt)("inlineCode",{parentName:"p"},"plugin_opt_config_file")," option can be specified under the SQL bridge plugin in ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquitto.conf"),"."),(0,a.kt)("p",null,'The file represents a configuration object consisting of an array of connection objects as well as an array of so-called "schema mappings". Each connection object defines its own database connection, MQTT topics to listen to, and references a mapping of MQTT message properties to columns of a database table. Such mappings are called schema mappings and are described in a different array within the same config file under ',(0,a.kt)("inlineCode",{parentName:"p"},"schemaMapping")," field."),(0,a.kt)("p",null,"The fields of the configuration object are described below. To see the entire structure of the configuration file take a look at the ",(0,a.kt)("a",c({parentName:"p"},{href:"#json-schema"}),"JSON schema")," at the bottom of this page. To see an example of the config file refer to the ",(0,a.kt)("a",c({parentName:"p"},{href:"#configuration-example"}),"configuration example section"),"."),(0,a.kt)("p",null,"The following fields of the config are mandatory:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"connections")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections"),"): ",(0,a.kt)("br",null)," An array of database connection objects. Each connection objects also contains a MQTT topic mapping information apart from database connection settings (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"array"),").",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"name")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].name"),"): ",(0,a.kt)("br",null)," Unique identifier of the SQL Bridge connection object. In simple terms, one can think of it as a convenient name for the database connection (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"connection")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection"),"): ",(0,a.kt)("br",null)," Object holding the actual database connection information (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"object"),").",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"driver")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.driver"),"): ",(0,a.kt)("br",null)," Name of the driver to be used with the database connection. (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),", one of: ",(0,a.kt)("inlineCode",{parentName:"li"},"mysql"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"timescaledb"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"postgres"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"alloydb"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"mariadb"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"cockroachdb"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"redshift"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"oracle"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"mssql"),"). "),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"hostname")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.hostname"),"): ",(0,a.kt)("br",null)," Hostname or IP address of the database server (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"port")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.port"),"): ",(0,a.kt)("br",null)," Port that the database server listens for client connections on (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"database")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.database"),"): ",(0,a.kt)("br",null)," Name of the database to connect to (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"topicMappings")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings"),"): ",(0,a.kt)("br",null)," List of mappings specifying which MQTT topics should forward data to which database tables (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,a.kt)("inlineCode",{parentName:"li"},"object"),").\n",(0,a.kt)("em",{parentName:"li"}," ",(0,a.kt)("inlineCode",{parentName:"em"},"name")," (path: ",(0,a.kt)("inlineCode",{parentName:"em"},"$.connections[].topicMappings.name"),"): ",(0,a.kt)("br",null)," Unique identifier of the current topic mapping. Used to provide useful information about configuration errors to the user (type: ",(0,a.kt)("inlineCode",{parentName:"em"},"string"),").\n")," ",(0,a.kt)("inlineCode",{parentName:"li"},"target")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.target"),"): ",(0,a.kt)("br",null)," Name of the database table that you want to insert your MQTT messages into (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),"). ","*"," ",(0,a.kt)("inlineCode",{parentName:"li"},"mqttTopics")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.mqttTopics"),"): ",(0,a.kt)("br",null)," An array of MQTT topics that should be forwarded to the database. MQTT wildcards (",(0,a.kt)("inlineCode",{parentName:"li"},"+")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"#"),") can also be used (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"schemaMappings")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings"),"): ",(0,a.kt)("br",null)," An array of schema mappings (selectors). May be empty, therefore elements of this array are optional and are described in the section below (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,a.kt)("inlineCode",{parentName:"li"},"object"),").")),(0,a.kt)("p",null,"Optional fields:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"version")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.version"),"): ",(0,a.kt)("br",null)," Version of the config file. Reserved for future use (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"connections")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.connections"),")"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"connection")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection"),")",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"credentials")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials"),"): ",(0,a.kt)("br",null)," Object holding basic authentication fields. (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"object"),")",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"username")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials.username"),"): ",(0,a.kt)("br",null)," Username used for authenticating against the database (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"password")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials.password"),"): ",(0,a.kt)("br",null)," Password of the user used for authenticating against the database. May be an empty string (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ssl")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl"),"): ",(0,a.kt)("br",null)," SSL options. SSL connection with DB will not be established if this option is not defined (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"object"),")",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"rejectUnauthorized")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.rejectUnauthorized"),"): ",(0,a.kt)("br",null)," Whether to refuse unauthorized certificates from the DB server. I.e. DB certificate is malformed or not signed by CA certificate provided in ",(0,a.kt)("inlineCode",{parentName:"li"},"caPath")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"ca")," option (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),")"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"caPath")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.caPath"),"): ",(0,a.kt)("br",null)," Path to CA that signed DB server certificate (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"certPath")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.certPath"),"): ",(0,a.kt)("br",null)," Path to client certificate (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"keyPath")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.keyPath"),"): ",(0,a.kt)("br",null)," Path to private client key (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ca")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.ca"),"): ",(0,a.kt)("br",null)," string with CA that signed DB server certificate. Use either this or ",(0,a.kt)("inlineCode",{parentName:"li"},"caPath")," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"cert")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.cert"),"): ",(0,a.kt)("br",null)," client certificate string. Use either this or ",(0,a.kt)("inlineCode",{parentName:"li"},"certPath")," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"key")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.key"),"): ",(0,a.kt)("br",null)," private client key string. Use either this or ",(0,a.kt)("inlineCode",{parentName:"li"},"keyPath")," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"lazyConnect")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.lazyConnect"),"): ",(0,a.kt)("br",null)," Whether to initialize database connection lazily meaning that the connection pool will be created but the database connection will not be performed until there are records to be inserted. In case this option is ",(0,a.kt)("inlineCode",{parentName:"li"},"false")," the connection to the database will be established and confirmed on plugin startup. In case of connection failure at this stage the plugin will output an error and fail (become unoperational). This allows to spot the connection issues early. Note that with this option being set to ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),", sql bridge plugin will fail only if problems with initial connection are encountered. If the connection to the database was established sucessfully at startup and fails later, the plugin will try reconnecting normally. (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"debug")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.debug"),"): ",(0,a.kt)("br",null)," Whether to log debug information about each SQL query performed by the plugin (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"driverDebug")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.driverDebug"),"): ",(0,a.kt)("br",null)," Whether to log driver specific debug information into stdout. Note that different database drivers log different information. Additionally, this option does not work for all the drivers. The format of the logged messages is entirely driver-dependent and does not follow a typical structure of a Mosquitto logentry (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),")."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"options")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options"),"): ",(0,a.kt)("br",null)," Object holding additional plugin settings (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"object"),").",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"bufferSize")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.bufferSize"),"): ",(0,a.kt)("br",null)," Defines the size of the buffer, which is used to batch multiple MQTT messages together before inserting them into the database. For more information, see ",(0,a.kt)("a",c({parentName:"li"},{href:"#buffering"}),"the section on buffering")," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"1000"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"batchSize")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.batchSize"),"): ",(0,a.kt)("br",null)," Defines the size of the batch inside the buffer. Buffer is broken down into batches and a separate batch insert is issued to the database for every batch in the buffer when the latter is released. (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"bufferSize"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"timeoutMs")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.timeoutMs"),"): ",(0,a.kt)("br",null)," Interval in milliseconds after which buffer is forcefully released if it is not empty. In other words, it specifies a maximum latency of the buffer release (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"5000"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"queueMaxSize")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.queueMaxSize"),"): ",(0,a.kt)("br",null)," Defines the max size of a retry queue used in case a database insert fails due to connection problems (and not due to malformed data). If set to ",(0,a.kt)("inlineCode",{parentName:"li"},"-1"),", the size of the queue is not limited. For more information see ",(0,a.kt)("a",c({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"1000"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"maxRetries")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.maxRetries"),"): ",(0,a.kt)("br",null)," Defines a number of retries to be performed by a retry queue before dropping the message. For more information, see ",(0,a.kt)("a",c({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"1000"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"10"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"retryDelayMs")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].options.retryDelayMs"),"): ",(0,a.kt)("br",null)," Defines a delay in milliseconds between the retry attempts of the queue. For more information, see ",(0,a.kt)("a",c({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"1000"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"1000"),")."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"topicMappings")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings"),")",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"options")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.options"),"): ",(0,a.kt)("br",null)," Additional options which are to be applied before inserting records into the database.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"schema")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.options.schema"),"): ",(0,a.kt)("br",null)," Name of the database schema in which the table is stored (if any, since not all the database management systems use schemas) (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"uppercase")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.options.uppercase"),"): ",(0,a.kt)("br",null)," Whether to cast database identifiers (tablename, schemaname, column names) to uppercase or use them as provided. (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),")."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"schemaMapping")," (path: ",(0,a.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.schemaMapping"),"): ",(0,a.kt)("br",null)," Name of a particular schema mapping from ",(0,a.kt)("inlineCode",{parentName:"li"},"$.schemaMappings")," array to be used as a mapping between ",(0,a.kt)("inlineCode",{parentName:"li"},"target")," table and ",(0,a.kt)("inlineCode",{parentName:"li"},"mqttTopics"),"."))))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"schemaMappings")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings"),"): ",(0,a.kt)("br",null)," An array of schema mappings. Each element of the array specifies a mapping between MQTT message properties and database table columns, along with typecasting and transformations if needed (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"array")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"object"),")."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"name")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].name"),"): ",(0,a.kt)("br",null)," Unique identifier of the current schema mapping. This name is matched against ",(0,a.kt)("inlineCode",{parentName:"p"},"$.connections[].topicMappings.schemaMapping")," to determine which schema mapping to used for particular table (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping"),"): ",(0,a.kt)("br",null)," An array holding source-to-target mapper object with information about which properties or metadata to pick out from your MQTT messages as well as which columns of the target database table those properties should be inserted into. These objects are also called selectors because they select what parts of the MQTT message are to be inserted into the DB table. (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"array")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"object"),")."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"source")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].source"),"): ",(0,a.kt)("br",null)," Source of the data to be inserted. This can be a property of the MQTT message payload (in case the payload is a JSON object) or some metadata property (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"client_id"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"timestamp")," etc). This field follows a particular unpacking syntax. For more information, see ",(0,a.kt)("a",c({parentName:"p"},{href:"#mapping-mqtt-packets-to-database-table-columns"}),"below")," (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"target")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].target"),"): ",(0,a.kt)("br",null)," Target table column into which data from the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field will be inserted (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"type")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].type"),"): ",(0,a.kt)("br",null)," Optional type casting of the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field before it gets inserted into the database. See more information about typecasting ",(0,a.kt)("a",c({parentName:"p"},{href:"#column-type-casting"}),"here")," (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", one of: ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"integer"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"datetime"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"raw"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"json"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"options")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options"),"): ",(0,a.kt)("br",null)," Object holding information about additional transformations to be performed on ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," before it is inserted into the database."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"encoding")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.encoding"),"): ",(0,a.kt)("br",null)," Used when casting a string data to ",(0,a.kt)("inlineCode",{parentName:"p"},"raw")," datatype. Specifies the encoding of the string data from ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", one of: ",(0,a.kt)("inlineCode",{parentName:"p"},"ascii"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"base64"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"base64url"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"hex"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ucs2"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"utf16le"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"utf8"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"binary"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"p"},"utf8"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"dbEncoding")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.dbEncoding"),"): ",(0,a.kt)("br",null)," Used when casting a to ",(0,a.kt)("inlineCode",{parentName:"p"},"raw")," datatype. Specifies which string encoding the database expects for raw/binary datatypes. If not specified, the default encoding of the underlying database driver will be used (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", one of: ",(0,a.kt)("inlineCode",{parentName:"p"},"ascii"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"base64"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"base64url"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"hex"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ucs2"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"utf16le"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"utf8"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"binary"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"replace")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.replace"),"): ",(0,a.kt)("br",null)," Specifies an array of two strings. Replaces all occurrences of the first string with the second one before inserting the data into the database (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"array")," consisting of two elements of type ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"isConst"),"(path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.isConst"),"): ",(0,a.kt)("br",null)," Used to indicate that the field in ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," is a constant that should be inserted into the database as is without trying to unpack it. This is relevant in case the constant in the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field is a string that follows the unpacking syntax (see ",(0,a.kt)("a",c({parentName:"p"},{href:"#mapping-mqtt-packets-to-database-table-columns"}),"below")," for more information) and, in particular, contains ",(0,a.kt)("inlineCode",{parentName:"p"},"[")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"]"),". Otherwise, this field can be omitted (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"bool"),", defaults to: if ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," is a string following the unpacking syntax: ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," else: ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"treatNullAsDefault")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.treatNullAsDefault"),"): This parameter specifies whether null values in the MQTT message should be treated as not defined and handled by the database table's default values (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"bool"),", default: ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"nullValue")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.nullValue"),"): Used to specify which value encountered in ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," should be replaced with ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," when performing an insert into the table. For example, with the help of this field, you can specify to convert all ",(0,a.kt)("inlineCode",{parentName:"p"},'"<None>"')," strings to ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," values (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"null"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"defaultValue")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.defaultValue"),"): Used to specify which value encountered in the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field should be treated as not defined and therefore replaced with the tables's ",(0,a.kt)("inlineCode",{parentName:"p"},"DEFAULT")," value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," column when insert is performed (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"null"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"replaceNullWith")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.replaceNullWith"),"): Specifies a value that null values will be replaced with (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"any"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"replaceUndefinedWith")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.replaceUndefinedWith"),"): In case that a property specified in ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," is missing on the MQTT message, it will be replaced with the value specified in this option (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"any"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"format")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.format"),"): Used when casting into ",(0,a.kt)("inlineCode",{parentName:"p"},"datetime")," datatype. Specifies a datetime format string representing the values from ",(0,a.kt)("inlineCode",{parentName:"p"},"source"),". See ",(0,a.kt)("a",c({parentName:"p"},{href:"https://date-fns.org/v3.3.1/docs/format"}),"format string documentation")," for more information on available format strings. Defaults to ",(0,a.kt)("inlineCode",{parentName:"p"},"yyyy-MM-ddTHH:mm:ss.sssZ")," (with an optional timezone information). However, by default if an integer value representing a unix timestamp in milliseconds is encountered in ",(0,a.kt)("inlineCode",{parentName:"p"},"source"),", it will also be accepted and appropriately converted to the datetime datatype (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"dbFormat")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.dbFormat"),"): ",(0,a.kt)("br",null)," Used when casting into ",(0,a.kt)("inlineCode",{parentName:"p"},"datetime")," datatype. Specifies a format string that datetime values should be converted to before they are inserted into the table. Database drivers typically handle this conversion automatically and usually default to the ISO string format. However, in some specific cases (for example, with OracleDB which uses ",(0,a.kt)("inlineCode",{parentName:"p"},"dd-MMM-yy hh:mm:ss")," instead of ISO format by default) an appropriate format might be required be defined by the user (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),").")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"replaceDelimiter")," (path: ",(0,a.kt)("inlineCode",{parentName:"p"},"$.schemaMappings[].mapping[].options.replaceDelimiter"),"): ",(0,a.kt)("br",null)," Used when casting into ",(0,a.kt)("inlineCode",{parentName:"p"},"datetime")," datatype. The format of the datetime values inserted into the database will typically be an ISO format as in the following example: ",(0,a.kt)("inlineCode",{parentName:"p"},"2017-01-29T14:07:00"),". If, for some reason, the database does not accept the ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," delimiter separating the date and time portion, a different delimiter may be specified using this option. Some database drivers will handle this transformation automatically, but in other cases, this field may become useful (type: ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),")."))))))))),(0,a.kt)("h2",c({},{id:"mapping-mqtt-packets-to-database-table-columns"}),"Mapping MQTT packets to database table columns"),(0,a.kt)("p",null,"The plugin configuration specifies the mapping between MQTT packets and table columns in the ",(0,a.kt)("inlineCode",{parentName:"p"},"schemaMappings")," field. Elements of the ",(0,a.kt)("inlineCode",{parentName:"p"},"schemaMappings")," array must have unique names that will be matched against the ",(0,a.kt)("inlineCode",{parentName:"p"},"schemaMapping")," field of the respective connection object and a ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," field."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," specifies an array of mapper objects (also referred to as selectors) between sources and targets. ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field represents the source of the data. It comes from the MQTT message or its metadata. ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," field, on the other hand, is an appropriate table column that ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," will be inserted into. It should be able to accomodate the datatype of ",(0,a.kt)("inlineCode",{parentName:"p"},"source"),". Most of the time the consistency between the common datatypes of sources and targets (e.g. string to VARCHAR, number to NUMBER etc.) is handled by the SQL bridge itself. However, in certain cases of datatype mismatches (e.g. when handling non-ISO formatted date strings etc) a typecasting may be required. See the ",(0,a.kt)("a",c({parentName:"p"},{href:"#column-type-casting"}),"following section on typecasting"),"."),(0,a.kt)("p",null,"To be more precise, the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field can either be a constant or a path to a particular metadata property of an MQTT message or a data property within its payload. In case MQTT payload is a JSON, the path to some data property of such payload can be specified."),(0,a.kt)("p",null,"Here are some examples to put the above-mentioned into context:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "I am a constant string",\n            "target": "column_a"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"The select object above maps a constant string (",(0,a.kt)("inlineCode",{parentName:"p"},'"I am a constant string"'),") to the ",(0,a.kt)("inlineCode",{parentName:"p"},"column_a")," of the database. This means that for every MQTT message for which this mapping is invoked, an SQL statement inserting ",(0,a.kt)("inlineCode",{parentName:"p"},'"I am a constant string"')," into the column ",(0,a.kt)("inlineCode",{parentName:"p"},"column_a")," will be performed."),(0,a.kt)("p",null,"To insert the entire MQTT payload, the selector would look similar to the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload]",\n            "target": "column_a"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"Note that apart from ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload]"),", various special metadata properties of the MQTT message may be selected. Here is the entire list of special (meta)data properties:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"hostname"),": Hostname of the broker. Note that the ",(0,a.kt)("inlineCode",{parentName:"li"},"HOSTNAME")," environment variable must be specified for the broker, or the default value will be used (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),", defaults to: ",(0,a.kt)("inlineCode",{parentName:"li"},"<Unknown>"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"topic"),": Name of the topic to which the MQTT message was published (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"payload"),": Payload of the MQTT message. Can be used to further unpack (pick out) child properties of the payload object if the latter is a JSON. See below for more information. If the payload was originally a string or a number, it will be treated as such, and no typecasting is necessary (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"any"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"qos"),": QoS level of the MQTT message (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),", one of: ",(0,a.kt)("inlineCode",{parentName:"li"},"0"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"1"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"2"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"retain")," - Retain flag of the MQTT message (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"timestamp")," - Unix timestamp representing the time when the MQTT message arrived at the broker. To insert this property into the database a column of type ",(0,a.kt)("inlineCode",{parentName:"li"},"INTEGER")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"BIGINT")," would typically be used (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"integer"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"datetime")," - Datetime string representing the time when the MQTT message arrived at the broker. To insert this property into the database a column of type ",(0,a.kt)("inlineCode",{parentName:"li"},"DATETIME")," would typically be used (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string")," representing the date in ISO format)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"uuid")," - unique identifier (UUID) of the message. Note that it is a convenience property. This ID is internally generated by the SQL Bridge plugin and is not coming from the original message's metadata (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"client_id")," - client_id of the device that published the MQTT message (type: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),").")),(0,a.kt)("p",null,"To select one of the above-mentioned properties, it should be enclosed in square brackets (",(0,a.kt)("inlineCode",{parentName:"p"},"[]"),") and specified in the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field of the configuration file."),(0,a.kt)("p",null,"For example, to insert the client ID of the device that published the message into the ",(0,a.kt)("inlineCode",{parentName:"p"},"client_id_column")," the following selector can be defined:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[client_id]",\n            "target": "client_id_column"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"As mentioned, it is also possible to unpack MQTT payload in case it is a JSON and select/pick out/extract certain properties from it. This can be achieved by specifying a JSON path to such property in the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," field. However, the properties in this path should be separated not by dots, but rather by square brackets (e.g.: not ",(0,a.kt)("inlineCode",{parentName:"p"},"payload.property1.innerProperty")," but ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][property1][innerProperty]"),")."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that currently the only supported characters for the JSON payload properties are ",(0,a.kt)("inlineCode",{parentName:"p"},"[a-zA-Z0-9_-]")," (alpha numeric characters as well as ",(0,a.kt)("inlineCode",{parentName:"p"},"_")," (underscore) and ",(0,a.kt)("inlineCode",{parentName:"p"},"-")," (dash))")),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1][innerProperty]",\n            "target": "column_a"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"In the above example ",(0,a.kt)("inlineCode",{parentName:"p"},"payload.property1.innerProperty")," is selected into the ",(0,a.kt)("inlineCode",{parentName:"p"},"column_a")," column."),(0,a.kt)("p",null,"This means that if the MQTT payload looks like below:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    "propery1": {\n        "innerProperty": "test"\n    },\n    "property2": {\n        "someProperty": 1\n    }\n}\n')),(0,a.kt)("p",null,"then the string ",(0,a.kt)("inlineCode",{parentName:"p"},'"test"')," will be inserted into ",(0,a.kt)("inlineCode",{parentName:"p"},"column_a"),"."),(0,a.kt)("h2",c({},{id:"column-type-casting"}),"Column type casting"),(0,a.kt)("p",null,"SQL bridge provides a feature to typecast properties of MQTT messages before they are inserted into the respective tables."),(0,a.kt)("p",null,"In order to cast a certain property to a certain type, the following configuration must be specified:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "<your mapping name here>",\n    "mapping": [\n        {\n            "source": "<your source mqtt message property>",\n            "target": "<your target db table column>",\n            "type": "<specify type to cast \'source\' into>"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][number_str]",\n            "target": "number_column",\n            "type": "number"\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"The following types are supported:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"datetime"),": casts integers or strings into a datetime (",(0,a.kt)("inlineCode",{parentName:"li"},"format"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"dbFormat")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"replaceDelimiter")," might need to be specified. See ",(0,a.kt)("a",c({parentName:"li"},{href:"#selector-options"}),"options section")," for details). There is no need to typecast datetime strings if they follow ISO format (note that the timezone portion is not required here since many databases don't handle timezones)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"number"),": casts strings into either a float or integer (supports float numbers separated by both dots or commas (e.g. both ",(0,a.kt)("inlineCode",{parentName:"li"},"1.5")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"1,5")," are handled))."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"integer"),": casts string into an integer truncating the fractional part."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"boolean"),": casts strings or numbers into a boolean value (note that string ",(0,a.kt)("inlineCode",{parentName:"li"},'"false"')," is cast to a ",(0,a.kt)("inlineCode",{parentName:"li"},"false")," boolean value, as is number 0, null, empty string, or a missing property. Everything else is cast to ",(0,a.kt)("inlineCode",{parentName:"li"},"true"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"raw"),": casts strings, numbers, and objects into binary DB types like ",(0,a.kt)("inlineCode",{parentName:"li"},"BLOB")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"BINARY"),". The specific datatype depends on the underlying databae driver and a specified encoding (",(0,a.kt)("inlineCode",{parentName:"li"},"encoding"),", and ",(0,a.kt)("inlineCode",{parentName:"li"},"dbEncoding")," might need to be specified. See ",(0,a.kt)("a",c({parentName:"li"},{href:"#selector-options"}),"options section")," for details)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"string"),": can cast numbers into strings. There is typically no need to typecast JSON objects to strings as this is done automatically."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"json"),": casts strings into JSON objects. This type is used very rarely, since implicit JSON casting is handled very well by the SQL bridge itself.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that while it might be tempting to explicitly specify typecasting for all the ",(0,a.kt)("inlineCode",{parentName:"p"},"source"),"s, this is not recommended as typecasting is often associated with additional overhead. The rule of thumb would be to cast only what is necessary.")),(0,a.kt)("h2",c({},{id:"selector-options"}),"Selector options"),(0,a.kt)("p",null,"Each selector under the ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," section of the configuration file can have additional options that define transformations to be performed on the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," data before it is inserted into ",(0,a.kt)("inlineCode",{parentName:"p"},"target"),". For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1]",\n            "target": "column_a",\n            "options": {\n                "nullValue": "<null>"\n            }\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"The above specifies a selector that maps ",(0,a.kt)("inlineCode",{parentName:"p"},"property1")," of the MQTT message to the ",(0,a.kt)("inlineCode",{parentName:"p"},"column_a")," in the database table. Once value ",(0,a.kt)("inlineCode",{parentName:"p"},'"<null>"')," is encountered in ",(0,a.kt)("inlineCode",{parentName:"p"},"property1")," it will be converted to ",(0,a.kt)("inlineCode",{parentName:"p"},"NULL")," before being inserted into the database."),(0,a.kt)("p",null,"Note that some options can only be used when typecasting to certain datatypes, while others can be used with any type or even without any typecasting."),(0,a.kt)("p",null,"Options which can only be used when typecasting to ",(0,a.kt)("inlineCode",{parentName:"p"},"datetime"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"format")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"dbFormat")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"replaceDelimiter"))),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1]",\n            "target": "column_a",\n            "type": "datetime",\n            "options": {\n                "nullValue": "<null>",\n                "format": "yyyy-MM-dd HH:mm:ss",\n                "dbFormat": "dd-MMM-yy hh:mm:ss",\n                "replaceDelimiter": " "\n            }\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"Options which can only be used when typecasting number, string, or an object to ",(0,a.kt)("inlineCode",{parentName:"p"},"raw"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"dbEncoding"))),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1]",\n            "target": "column_a",\n            "type": "raw",\n            "options": {\n                "dbEncoding": "hex"\n            }\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"Options which can only be used when typecasting a string to ",(0,a.kt)("inlineCode",{parentName:"p"},"raw"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"encoding"))),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1]",\n            "target": "column_a",\n            "type": "raw",\n            "options": {\n                "encoding": "utf8",\n                "dbEncoding": "hex"\n            }\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"Options which can be used as long as the underlying value is a ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"replace"))),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1]",\n            "target": "column_a",\n            "options": {\n                "replace": ["hello world", "hello SQL"]\n            }\n        }\n    ],\n    ...\n}\n')),(0,a.kt)("p",null,"Options which can be used regardless of types and typecasting:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"replaceNullWith")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"replaceUndefinedWith")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"nullValue")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"defaultValue")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"treatNullAsDefault")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"isConst"))),(0,a.kt)("p",null,"See ",(0,a.kt)("a",c({parentName:"p"},{href:"#config-file-format"}),"config file fieds")," for more information on the listed options (their descriptions, datatypes, allowed values)."),(0,a.kt)("h2",c({},{id:"configuration-example"}),"Configuration example"),(0,a.kt)("p",null,"An example of the ",(0,a.kt)("inlineCode",{parentName:"p"},"sql-bridge.json")," with two database connections is shown below (you may see all the available configuration options ",(0,a.kt)("a",c({parentName:"p"},{href:"#json-schema"}),"here"),"):"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    "version": 1,\n    "connections": [\n        {\n            "name": "PostgreSQL - Bridge",\n            "connection": {\n                "driver": "postgres",\n                "hostname": "postgres.cedalo.com",\n                "port": 5432,\n                "database": "mosquitto",\n                "credentials": {\n                    "username": "mosquittouser",\n                    "password": "password"\n                },\n                "debug": true\n            },\n            "options": {\n                "bufferSize": 10000,\n                "batchSize": 1000,\n                "timeoutMs": 4000,\n                "queueMaxSize": 10000,\n                "maxRetries": 15,\n                "retryDelayMs": 1000\n            },\n            "topicMappings": [\n                {\n                    "name": "topic-mapping-to-postgers-table",\n                    "schemaMapping": "schema-mapping-1",\n                    "target": "blood",\n                    "options": {\n                        "schema": "public"\n                    },\n                    "mqttTopics": [\n                        "db/qa/#"\n                    ]\n                }\n            ]\n        },\n        {\n            "name": "MySQL - Bridge",\n            "connection": {\n                "driver": "mysql",\n                "hostname": "mysql.cedalo.com",\n                "port": 3306,\n                "database": "mosquitto",\n                "credentials": {\n                    "username": "mosquittouser",\n                    "password": "password"\n                },\n                "debug": true\n            },\n            "options": {\n                "bufferSize": 10000,\n                "batchSize": 1000,\n                "timeoutMs": 4000,\n                "queueMaxSize": 10000,\n                "maxRetries": 15,\n                "retryDelayMs": 1000\n            },\n            "topicMappings": [\n                {\n                    "name": "topic-mapping-to-mysql-table",\n                    "target": "blood",\n                    "schemaMapping": "schema-mapping-1",\n                    "mqttTopics": [\n                        "db/qa/#"\n                    ]\n                }\n            ]\n        }\n    ],\n    "schemaMappings": [\n        {\n            "name": "schema-mapping-1",\n            "mapping": [\n                {\n                    "source": "[client_id]",\n                    "target": "humanname"\n                },\n                {\n                    "source": "[payload][data]",\n                    "target": "dummychars"\n                },\n                {\n                    "source": "[uuid]",\n                    "target": "uuidcol"\n                },\n                {\n                    "source": "[payload][tmp]",\n                    "target": "floatnumbercol",\n                    "type": "integer"\n                },\n                {\n                    "source": "[datetime]",\n                    "target": "dt"\n                },\n                {\n                    "source": "[payload][tmp_int]",\n                    "target": "floatnumbercol2",\n                    "type": "number"\n                },\n                {\n                    "source": "[payload][name]",\n                    "target": "textcol",\n                    "options": {\n                        "replace": ["Tom ", "Thomas "]\n                    }\n                },\n                {\n                    "source": "some constant desc",\n                    "target": "descript"\n                },\n                {\n                    "source": "[payload][data][temp]",\n                    "target": "temp"\n                },\n                {\n                    "source": "[payload][data][more][ok]",\n                    "target": "isok",\n                    "type": "boolean"\n                },\n                {\n                    "source": "[payload][tmp_json]",\n                    "target": "jsn"\n                },\n                {\n                    "source": "[payload][jsonarray]",\n                    "target": "jsonarray"\n                },\n                {\n                    "source": "[payload][packet_dt]",\n                    "target": "dt2",\n                    "type": "datetime",\n                    "options": {\n                        "format": "DD-MM-YYYY HH:mm:ss"\n                    }\n                },\n                {\n                    "source": "[payload]",\n                    "target": "payloadcolumn",\n                },\n                {\n                    "source": "[payload][data]",\n                    "target": "sourcecolumn",\n                    "options": {\n                        "isConst": true\n                    }\n                }\n            ]\n        }\n    ]\n}\n')),(0,a.kt)("p",null,"As per the example config above, SQL bridge will connect to two databases at ",(0,a.kt)("inlineCode",{parentName:"p"},"postgres.cedalo.com:5432")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"mysql.cedalo.com:3306"),". It will use a database called ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquitto")," and will authenticate against it as ",(0,a.kt)("inlineCode",{parentName:"p"},"mosquittouser"),"."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that in this example both database connections have passwords. However, some databases like CockroachDB if started in an insecure mode will not require password and so, in such cases, the password field may be left empty.")),(0,a.kt)("p",null,"The optional ",(0,a.kt)("inlineCode",{parentName:"p"},"options")," field is specified and overrides some defaults of the plugin's buffering. It sets ",(0,a.kt)("inlineCode",{parentName:"p"},"bufferSize")," to 10000. This setting effectively assigns the specified buffer size for every buffer. Buffers are created per table to store MQTT message information for batching purposes and trigger fewer insert queries."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"batchSize")," specifies the number of rows that should be inserted into the database per single batch insert. Effectively, it breaks a single batch insert into multiple smaller batch inserts of the specified size (1000 in this case)."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"timeoutMs")," is changed to 4000 milliseconds which means that every 4 seconds all the buffers that are not empty will be forecefully cleared. Clearing the buffers triggers batch inserts even if they have not yet reached full capacity."),(0,a.kt)("p",null,"See ",(0,a.kt)("a",c({parentName:"p"},{href:"#buffering"}),"section about buffering")," for more information."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"queueMaxSize")," sets the retry queue size to 10000 which is a limit after which messages will be dropped. ",(0,a.kt)("inlineCode",{parentName:"p"},"maxRetries")," is set to 15, and ",(0,a.kt)("inlineCode",{parentName:"p"},"retryDelayMs")," to 1000. This means that we will retry once every second for 15 iterations, getting a 15 seconds of retry for every message that wasn't inserted due to connection issue. This is quite long, so it's important to adapt ",(0,a.kt)("inlineCode",{parentName:"p"},"queueMaxSize")," or set it to be limitless with a ",(0,a.kt)("inlineCode",{parentName:"p"},"-1")," value to ensure that the queue doesn't get overfilled while retrying to insert messages."),(0,a.kt)("p",null,"See ",(0,a.kt)("a",c({parentName:"p"},{href:"#retry-queue"}),"section about retry queue")," for more information."),(0,a.kt)("p",null,"The configuration uses a mapping to table ",(0,a.kt)("inlineCode",{parentName:"p"},"blood")," stored in schema ",(0,a.kt)("inlineCode",{parentName:"p"},"public")," in the case of the Postgres database. Notice that MySQL doesn't have ",(0,a.kt)("inlineCode",{parentName:"p"},"schema")," in it's ",(0,a.kt)("inlineCode",{parentName:"p"},"topicMapings")," under ",(0,a.kt)("inlineCode",{parentName:"p"},"options"),". That is because MySQL does not use database schemas."),(0,a.kt)("p",null,"Under the ",(0,a.kt)("inlineCode",{parentName:"p"},"mqttTopics")," entry, there is an array of MQTT topics which should be mapped to the database table (",(0,a.kt)("inlineCode",{parentName:"p"},"blood"),"). In case this array was empty, no messages would be forwarded to the database."),(0,a.kt)("p",null,"Multiple topic mappings can be specified in this array, but in the case above, there is just a single entry. However, this entry uses an MQTT wildcard (",(0,a.kt)("inlineCode",{parentName:"p"},"db/qa/#"),"), specifying that any MQTT message that is published in any of the topics under ",(0,a.kt)("inlineCode",{parentName:"p"},"db/qa/")," will be unpacked and inserted into the database using selectors from the respective schema mapping specified in ",(0,a.kt)("inlineCode",{parentName:"p"},"schemaMapping")," key (",(0,a.kt)("inlineCode",{parentName:"p"},'"schema-mapping-1"')," in our case)."),(0,a.kt)("p",null,"Section ",(0,a.kt)("inlineCode",{parentName:"p"},"schemaMapping")," defines an array of schema mappings that are used to unpack MQTT messages. ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," field of each element in the array is a unique identifier of the schema mapping matched against ",(0,a.kt)("inlineCode",{parentName:"p"},"schameMapping")," field from ",(0,a.kt)("inlineCode",{parentName:"p"},"topicMappings"),". Apart from ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," each schema mapping contains a ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," field with selectors.\nEach selector under the ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," field represents a ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," for the mapping between MQTT message properties and database table column mapping. Each ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," is some property of the MQTT message (or a constant value) and each ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," is a column of the table ",(0,a.kt)("inlineCode",{parentName:"p"},"blood"),"."),(0,a.kt)("p",null,"Note that some sources specify metadata properties of the MQTT message like ",(0,a.kt)("inlineCode",{parentName:"p"},"[client_id]")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"[uuid]")," (representing a client id of the publisher or a unique identifier generated for the message). Other properties unpack the payload of the MQTT message and extract certain properties from it. For example, ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][packet_dt]"),", which extracts the ",(0,a.kt)("inlineCode",{parentName:"p"},"packet_dt")," from the MQTT payload, assuming that this payload is a JSON. Also note that this selector has a typecast to ",(0,a.kt)("inlineCode",{parentName:"p"},"datetime")," datatype meaning that it tries to interpret the value in ",(0,a.kt)("inlineCode",{parentName:"p"},"packet_dt")," as a date string according to the ",(0,a.kt)("inlineCode",{parentName:"p"},"DD-MM-YYYY HH:mm:ss")," format specified under ",(0,a.kt)("inlineCode",{parentName:"p"},"options"),"."),(0,a.kt)("p",null,"Notice the typecasting on some other sources. For example, the source ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][tmp]")," is mapped to a ",(0,a.kt)("inlineCode",{parentName:"p"},"floatnumbercol")," column. This implicitly implies (judging by the name of the column) that the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"tmp")," could be a float. However, it is typecasted to ",(0,a.kt)("inlineCode",{parentName:"p"},"integer"),", and therefore, the fractional part of the number will be sliced off before the insert into the table occurs."),(0,a.kt)("p",null,"Another example is a mapping between a deeply nested property ",(0,a.kt)("inlineCode",{parentName:"p"},"ok")," in source ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][data][more][ok]")," and the column ",(0,a.kt)("inlineCode",{parentName:"p"},"isok"),". This mapping has a ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean")," typecasting, which means that even if ",(0,a.kt)("inlineCode",{parentName:"p"},"ok")," property is not an actual boolean but a string literal with values of either ",(0,a.kt)("inlineCode",{parentName:"p"},'"true"')," or ",(0,a.kt)("inlineCode",{parentName:"p"},'"false"'),", the casting will convert those to the proper boolean values ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"false")," respectively."),(0,a.kt)("p",null,"There is also a ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][name]")," property being unpacked and transformed. The transformation in this case is a replacement of all occurrences of the substring ",(0,a.kt)("inlineCode",{parentName:"p"},'"Tom "')," to ",(0,a.kt)("inlineCode",{parentName:"p"},'"Thomas ".')),(0,a.kt)("p",null,"If required, the entire MQTT payload can be inserted into a column. This is shown in the mapping between ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload]")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"payloadcolumn"),". If the payload is JSON and the database supports JSON types (like PostgreSQL does, for example), then the payload will be inserted as JSON. Otherwise, if the database of choice does not support this type, then the plugin will try to insert the payload as a string, and the respective database column should have an appropriate type to accommodate it."),(0,a.kt)("p",null,"In cases when the payload of the MQTT message is not a JSON but a string or a number, it will be inserted as such."),(0,a.kt)("p",null,"An interesting but uncommon case is the mapping of source ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][data]")," to the ",(0,a.kt)("inlineCode",{parentName:"p"},"sourcecolumn"),". Note that, since ",(0,a.kt)("inlineCode",{parentName:"p"},"isConst")," option is set to true, ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][data]")," is being treated as a constant string rather than a ",(0,a.kt)("inlineCode",{parentName:"p"},"data")," property of the MQTT message's payload. The ",(0,a.kt)("inlineCode",{parentName:"p"},"isConst")," option is needed in this case because the constant string ",(0,a.kt)("inlineCode",{parentName:"p"},"[payload][data]")," has the same syntax as unpacking MQTT payload. If this option was not specified, the plugin would try to extract the property from the payload leading to errors if it is not present."),(0,a.kt)("p",null,"However, if there is a need to insert a constant into the database and it does not look like a valid message unpacking syntax (e.g. doesn't use the square brackets notation), then there is no need to specify the ",(0,a.kt)("inlineCode",{parentName:"p"},"isConst")," option. This can be seen in the following mapping:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'                            {\n                                "source": "some constant desc",\n                                "target": "descript"\n                            },\n')),(0,a.kt)("p",null,"which will simply insert string ",(0,a.kt)("inlineCode",{parentName:"p"},'"some constant desc"')," into ",(0,a.kt)("inlineCode",{parentName:"p"},"descript")," message for every MQTT message."),(0,a.kt)("h2",c({},{id:"error-handling"}),"Error handling"),(0,a.kt)("p",null,"Any configuration or license errors will prevent the plugin from being loaded, and respective messages will appear in the logs."),(0,a.kt)("p",null,"If recoverable errors occur during the operation of the plugin, it will generate respective error messages in its logs and prefix them with an ",(0,a.kt)("inlineCode",{parentName:"p"},"ERR:")," prefix. This includes: encountering errors when converting MQTT messages to SQL insert queries as well as failures during query execution."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that while error messages generated by the plugin will be preceded by ",(0,a.kt)("inlineCode",{parentName:"p"},"ERR:"),", warning messages will get a ",(0,a.kt)("inlineCode",{parentName:"p"},"WARN:")," prefix, while debug messages - a respective ",(0,a.kt)("inlineCode",{parentName:"p"},"DEBUG:"),".")),(0,a.kt)("h2",c({},{id:"debugging"}),"Debugging"),(0,a.kt)("p",null,"To debug the plugin it is possible to set the ",(0,a.kt)("inlineCode",{parentName:"p"},"debug")," variable in the configuration file under ",(0,a.kt)("inlineCode",{parentName:"p"},"connection")," section to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),". This will print all the SQL queries that are being performed against the database to the stdout."),(0,a.kt)("p",null,"Another option is specifying ",(0,a.kt)("inlineCode",{parentName:"p"},"driverDebug")," (under the ",(0,a.kt)("inlineCode",{parentName:"p"},"connection")," section as well), which will lead to an SQL driver-specific output. Note that some drivers do not produce such output at all. Also note that the records printed with ",(0,a.kt)("inlineCode",{parentName:"p"},"driverDebug")," do not follow a typical Mosquitto log message structure. The logs generated when this option is enabled might also not be synchronized with Mosquitto logs leading to malformed log records in certain cases. Therefore, the use of this option beyond debug purposes is strongly not recommended."),(0,a.kt)("h2",c({},{id:"case-sensitivity"}),"Case sensitivity"),(0,a.kt)("p",null,"Different databases handle database identifiers a bit differently. While DBMSs such as PostgreSQL fold identifier names to lowercase (unless they were enclosed with double quotes upon creation), other databases, such as OracleDB, tend to fold unquoted identifiers to uppercase by default."),(0,a.kt)("p",null,"The SQL bridge config file is case-sensitive to the database identifier names, which, coupled with different conventions for name folding, might create some confusion and errors, especially when reusing parts of the config or specifying different databases with identically named tables."),(0,a.kt)("p",null,"For instance, if there was a table ",(0,a.kt)("inlineCode",{parentName:"p"},"products")," in OracleDB and a table with the same name in PostgreSQL, the following config:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    "connections": [\n        {\n            "name": "PostgreSQL - Bridge",\n            "connection": {\n                "driver": "postgres",\n                "hostname": "postgres.cedalo.com",\n                "port": 5432,\n                "database": "mosquitto",\n                "credentials": {\n                    "username": "test",\n                    "password": "secret_password"\n                },\n                "debug": true\n            },\n            "topicMappings": [\n                {\n                    "name": "topic-mapping-to-postgers-table",\n                    "schemaMapping": "schema-mapping-1",\n                    "target": "products",\n                    "options": {\n                        "uppercase": false,\n                        "schema": "test"\n                    },\n                    "mqttTopics": [\n                        "db/qa"\n                    ]\n                }\n            ]\n        },\n        {\n            "name": "OracleDB - Bridge",\n            "connection": {\n                "driver": "oracle",\n                "hostname": "oracle.cedalo.com",\n                "port": 1521,\n                "database": "FREEPDB1",\n                "credentials": {\n                    "username": "test",\n                    "password": "secret_password"\n                }\n            },\n            "topicMappings": [\n                {\n                    "name": "topic-mapping-to-oracledb-table",\n                    "schemaMapping": "schema-mapping-1",\n                    "options": {\n                        "schema": "test"\n                    },\n                    "target": "products"\n                }\n            ]\n        }\n    ],\n    "schemaMapping": [\n        {\n            "name": "schema-mapping-1",\n            "mapping": [\n                {\n                    "source": "[payload][product]",\n                    "target": "product_name"\n                }\n            ]\n        }\n    ]\n}\n')),(0,a.kt)("p",null,"could potentially lead to errors. The reason is exactly the default name folding.\nWhen SQL bridge generates SQL queries, it encloses identifier names in double quotes, meaning that they become case-sensitive. If you specify the table ",(0,a.kt)("inlineCode",{parentName:"p"},"products"),", schema ",(0,a.kt)("inlineCode",{parentName:"p"},"test"),", and column ",(0,a.kt)("inlineCode",{parentName:"p"},"product_name")," as above (notice the lowercase) to the Oracle database, it will search for those identifiers as if they were intentionally lowercased. The query would look something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-sql"}),'insert into "test"."products"."product_name" values("some_value");\n')),(0,a.kt)("p",null,"If the ",(0,a.kt)("inlineCode",{parentName:"p"},"products")," table was not created with a double-quoted lowercase identifier, the above query would not find the correct table and fail. In this case, a correct query should be:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-sql"}),'insert into "TEST"."PRODUCTS"."PRODUCT_NAME" values("some_value");\n')),(0,a.kt)("p",null,"To construct the correct query in such cases there are two options: either specifying the identifier names in the config file using uppercase characters (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},'"target": "PRODUCTS",')," etc) for databases that fold to uppercase, or to specify a property ",(0,a.kt)("inlineCode",{parentName:"p"},"uppercase")," in the entry of the ",(0,a.kt)("inlineCode",{parentName:"p"},"mappings")," array and set it to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),". E.g.:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n...\n    "topicMappings": [\n        {\n            "name": "topic-mapping-to-oracledb-table",\n            "schemaMapping": "schema-mapping-1",\n            "target": "products",\n            "options": {\n                "schema": "test",\n                "uppercase": true\n            },\n            ...\n        },\n        ...\n    ]\n...\n}\n')),(0,a.kt)("p",null,"And once again note that this example would not have been a problem for PostgreSQL and some other databases which fold identifiers to lowercase by default."),(0,a.kt)("p",null,"As to the rationale behind this documentation using mostly lowercase for database identifiers, it is because the majority of the supported DBMSs fold to lowercase."),(0,a.kt)("p",null,"An advantage of the case sensitivity of the database identifiers in the SQL bridge config files is that it allows to reference tables which were created as case sensitive. For example: ",(0,a.kt)("inlineCode",{parentName:"p"},"producttable"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"PRODUCTTABLE"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"PrOdUcTtAbLe")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"ProductTable")," are 4 completely different identifiers that can be easily referenced with in the configuration file.\nFor case sensitivity of the configuration file to work ensure that ",(0,a.kt)("inlineCode",{parentName:"p"},"uppercase")," fields are set to ",(0,a.kt)("inlineCode",{parentName:"p"},"false")," or removed from the config."),(0,a.kt)("h2",c({},{id:"buffering"}),"Buffering"),(0,a.kt)("p",null,"Buffers are created per table for every database connection. The size of the buffer is controlled with ",(0,a.kt)("inlineCode",{parentName:"p"},"bufferSize")," field under ",(0,a.kt)("inlineCode",{parentName:"p"},"options")," (",(0,a.kt)("inlineCode",{parentName:"p"},"$.connections[].options"),") and indicates the capacity of the buffer. The default size of the buffer is 1000. Buffer holds records representing unpacked MQTT messages which are to be inserted to the respective table once the buffer is saturated."),(0,a.kt)("p",null,"Once the buffer fills up, its flushing is triggered, and a single or multiple batch inserts are issued against the table, inserting the buffer contents. The condition for buffer flush is ",(0,a.kt)("inlineCode",{parentName:"p"},"bufferSize + 1"),". Once this number of records is reached, the buffer is released. The number of batch insert queries issued per buffer release is controlled via the ",(0,a.kt)("inlineCode",{parentName:"p"},"batchSize")," config field. This field indicates how many records should be inserted per single batch insert. By default, ",(0,a.kt)("inlineCode",{parentName:"p"},"batchSize")," equals ",(0,a.kt)("inlineCode",{parentName:"p"},"bufferSize"),", meaning that the buffer is not broken down into batches and a single batch insert query is performed."),(0,a.kt)("p",null,"Another parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"timeoutMs")," - indicates the timeinterval (in milliseconds) after which all the non-empty buffers will be forcefully released triggering the batch inserts of the buffers' contents. The default value is 5000 ms."),(0,a.kt)("p",null,"However, even though it might seem that buffer is only released after saturation or a timeout, it also has a mechanism to account for infrequent MQTT messages and decrease the latency of database inserts for such records."),(0,a.kt)("p",null,'The idea is that the time interval between the current and the previous MQTT messages is kept track of. If this interval is long enough, the record will be inserted instantly. However, if the interval between the messages is short, the plugin will keep buffering the messages anticipating a possible influx. The definition of "long enough" might change when updates to the plugin are made, but currently, it\'s a fraction of the ',(0,a.kt)("inlineCode",{parentName:"p"},"timeouts.")," For practical purposes it can be assumed as ",(0,a.kt)("inlineCode",{parentName:"p"},"timeoutMs/2"),"."),(0,a.kt)("p",null,"Note that the above leads to the first MQTT message never being buffered."),(0,a.kt)("p",null,"Also, notice that buffer options can be defined per database connection, allowing for more flexibility and fine-tuning when needed."),(0,a.kt)("h2",c({},{id:"retry-queue"}),"Retry queue"),(0,a.kt)("p",null,"The SQL bridge plugin guarantees the in-order insertion of all the non-malformed messages into the respective tables. However, in case of network issues or database downtime, some messages may be lost. To prevent this, SQL bridge has a retry queue on a per-table basis that is responsible for retrying message inserts in case of connection problems. Notice that this does not include cases when the data of the MQTT message is malformed and generates an SQL error upon insert (due to inconsistent types, exceeded limits, or violated constraints, etc)."),(0,a.kt)("p",null,"Each retry queue can be configured with the following settings (under ",(0,a.kt)("inlineCode",{parentName:"p"},"options")," field of the configuration file (",(0,a.kt)("inlineCode",{parentName:"p"},"$.connections[].options"),")):"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"queueMaxSize")," option is used to set the maximum amount of messages that the queue is able to accomodate before it starts to drop them. This limit can be set to infinity using the value ",(0,a.kt)("inlineCode",{parentName:"p"},"-1"),", which is a default. Note that if this value is not set to ",(0,a.kt)("inlineCode",{parentName:"p"},"-1"),", then careful considerations and testing should be performed to ensure that the queue will not overfill too quickly as soon as it tries to retry insertings messages."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"maxRetries")," is used to specify the maximum number that the retry queue attempts to insert a message again before dropping it."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"retryDelayMs")," is a minimum amount of time in milliseconds that must pass between the retry queue attempts."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that the elements in a retry queue can be both single MQTT messages as well as entire buffers of MQTT messages that are ready to be batch-inserted into the database.")),(0,a.kt)("h2",c({},{id:"json-schema"}),"JSON Schema"),(0,a.kt)("p",null,"Schema for all possible parameters for the ",(0,a.kt)("inlineCode",{parentName:"p"},"sql-bridge.json")," config file:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-json"}),'{\n    "title": "SQL-Bridge Plugin Config",\n    "type": "object",\n    "properties": {\n        "version": {\n            "type": "string",\n            "nullable": true,\n            "default": "1",\n            "description": "Version of the configuration file",\n        },\n        "connections": {\n            "type": "array",\n            "description": "List of sub-configurations per DB connection",\n            "items": {\n                "type": "object",\n                "description": "Configuration per DB connection",\n                "properties": {\n                    "name": {\n                        "type": "string",\n                        "nullable": false,\n                        "description": "Unique textual identifier of the configuration"\n                    },\n                    "options": {\n                        "type": "object",\n                        "nullable": true,\n                        "description": "Plugin options for configuring internal queues and buffers",\n                        "properties": {\n                            "bufferSize": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 1,\n                                "description": "Maximum number of messages to buffer before flushing to the database"\n                            },\n                            "timeoutMs": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 0,\n                                "description": "Maximum time in milliseconds to buffer messages before flushing to the database"\n                            },\n                            "batchSize": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 0,\n                                "description": "Size of batch for bulk insert when releasing the buffer. Defaults to bufferlength"\n                            },\n                            "queueMaxSize": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": -1,\n                                "description": "Maximum number of messages in retry queue"\n                            },\n                            "maxRetries": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 0,\n                                "description": "Maximum number of retries for failed inserts due to lost connection"\n                            },\n                            "retryDelayMs": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 0,\n                                "description": "Delay in milliseconds before retrying inserts failed due to lost connection"\n                            }\n                        }\n                    },\n                    "connection": {\n                        "type": "object",\n                        "description": "DB connection specific configuration",\n                        "properties": {\n                            "driver": {\n                                "type": "string",\n                                "enum": ["mysql", "postgres", "timescaledb", "alloydb", "mariadb", "cockroachdb", "redshift", "oracle", "mssql"],\n                                "nullable": false,\n                                "description": "Name of the DB driver to use, e.g. \\"mysql\\", \\"postgres\\", \\"mssql\\" etc."\n                            },\n                            "version": {\n                                "type": "string",\n                                "nullable": true,\n                                "description": "Used to specify DB name for old postgres databases mainly"\n                            },\n                            "hostname": {\n                                "type": "string",\n                                "nullable": true,\n                                "description": "Hostname or IP of the DB server to connect to"\n                            },\n                            "port": {\n                                "type": "integer",\n                                "nullable": true,\n                                "description": "Port of the DB server to connect to"\n                            },\n                            "database": {\n                                "type": "string",\n                                "nullable": true,\n                                "description": "Name of the database to connect to"\n                            },\n                            "filename": {\n                                "type": "string",\n                                "nullable": true,\n                                "description": "Path to dbfile in case of sqlite only. If sqlite is used, then port, host, credentials, and database fields are not used"\n                            },\n                            "credentials": {\n                                "type": "object",\n                                "description": "Credentials of the database user used for connection to the database",\n                                "properties": {\n                                    "username": {\n                                        "type": "string",\n                                        "description": "Username of the database user to use for connection"\n                                    },\n                                    "password": {\n                                        "type": "string",\n                                        "description": "Password of the database user to use for connection"\n                                    }\n                                },\n                                "nullable": true,\n                                "required": ["username", "password"]\n                            },\n                            "ssl": {\n                                "type": "object",\n                                "nullable": true,\n                                "description": "SSL configuration for the connection",\n                                "properties": {\n                                    "ca": {\n                                        "type": "string",\n                                        "nullable": true,\n                                        "description": "CA certificate file to use for the connection"\n                                    },\n                                    "key": {\n                                        "type": "string",\n                                        "nullable": true,\n                                        "description": "Private key file to use for the connection"\n                                    },\n                                    "cert": {\n                                        "type": "string",\n                                        "nullable": true,\n                                        "description": "Certificate file to use for the connection"\n                                    },\n                                    "caPath": {\n                                        "type": "string",\n                                        "nullable": true,\n                                        "description": "CA certificate path to use for the connection"\n                                    },\n                                    "keyPath": {\n                                        "type": "string",\n                                        "nullable": true,\n                                        "description": "Private key path to use for the connection"\n                                    },\n                                    "certPath": {\n                                        "type": "string",\n                                        "nullable": true,\n                                        "description": "Certificate path to use for the connection"\n                                    },\n                                    "rejectUnauthorized": {\n                                        "type": "boolean",\n                                        "nullable": true,\n                                        "description": "Whether to reject unauthorized connections or not"\n                                    }\n                                }\n                            },\n                            "debug": {\n                                "type": "boolean",\n                                "nullable": true,\n                                "description": "Whether to enable debug query logging for connection"\n                            },\n                            "driverDebug": {\n                                "type": "boolean",\n                                "nullable": true,\n                                "description": "Whether to enable db-driver-level debug information for queries. Note that it does not use Mosquitto logger, so the formatting of the output is different. Also not all drivers support this option"\n                            },\n                            "lazyConnect": {\n                                "type": "boolean",\n                                "nullable": true,\n                                "default": false,\n                                "description": "Whether to allow the plugin to continue if the connection to the database cannot be established",\n                            },\n                        },\n                        "nullable": false,\n                        "required": ["driver"]\n                    },\n                    "topicMappings": {\n                        "type": "array",\n                        "description": "List of topic mapping objects to forward MQTT messages to the database",\n                        "items": {\n                            "type": "object",\n                            "properties": {\n                                "name": {\n                                    "type": "string",\n                                    "nullable": false,\n                                    "description": "Unique identifier of this mapping"\n                                },\n                                "schemaMapping": {\n                                    "type": "string",\n                                    "nullable": false,\n                                    "description": "Name of the schema mapping which should be applied here"\n                                },\n                                "target": {\n                                    "type": "string",\n                                    "description": "Database table to forward MQTT messages to"\n                                },\n                                "options": {\n                                    "type": "object",\n                                    "nullable": true,\n                                    "properties": {\n                                        "schema": {\n                                            "type": "string",\n                                            "nullable": true,\n                                            "description": "Name of the schema where the table is located in"\n                                        }\n                                    },\n                                    "description": "Optional options for the table"\n                                },\n                                "mqttTopics": {\n                                    "type": "array",\n                                    "items": {\n                                        "type": "string",\n                                        "description": "List of MQTT topics to forward messages from",\n                                        "pattern": "^((\\\\+?|[\\\\w-]+)((\\\\/[\\\\w-]+)?(\\\\/\\\\+)?(\\\\/[\\\\w-]+)?((?<!\\\\+)\\\\/)?)*(\\\\/#)?|(\\\\/)?#)$"\n                                    }\n                                }\n                            },\n                            "required": ["name", "target", "mqttTopics"]\n                        }\n                    }\n                },\n                "required": ["name", "connection", "topicMappings"]\n            }\n        },\n        "schemaMappings": {\n            "type": "array",\n            "items": {\n                "type": "object",\n                "properties": {\n                    "name": {\n                        "type": "string",\n                        "nullable": false,\n                        "description": "Unique identifier of the mapping"\n                    },\n                    "mapping": {\n                        "type": "array",\n                        "description": "List of mappings to apply to the table. Each schema contains a mapping of database table columns to MQTT message properties",\n                        "items": {\n                            "type": "object",\n                            "description": "Properties to select from the MQTT message and insert into the database table",\n                            "properties": {\n                                "source": {\n                                    "oneOf": [\n                                        { "type": "string" },\n                                        { "type": "number" },\n                                        { "type": "null", "nullable": true }\n                                    ],\n                                    "description": "JSON path to the value to insert into the column using square brackets, e.g. \\"[foo][bar]\\" AND NOT \\"$.foo.bar\\""\n                                },\n                                "target": {\n                                    "type": "string",\n                                    "description": "Name of the column to insert data from \\"source\\" into"\n                                },\n                                "type": {\n                                    "type": "string",\n                                    "nullable": true,\n                                    "description": "Data type of the value to cast source to before inserting into the column"\n                                },\n                                "options": {\n                                    "type": "object",\n                                    "nullable": true,\n                                    "description": "Optional options for the column"\n                                }\n                            },\n                            "required": ["source", "target"]\n                        }\n                    }\n                },\n                "required": ["name", "mapping"]\n            }\n        }\n    },\n    "required": ["connections", "schemaMappings"]\n}\n')))}N.isMDXComponent=!0},49044:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(67294),i=n(39082),o=n(62659),r=n(83166);function l({inline:e}){return a.createElement(i.Z,{sx:{margin:e?"0px 5px":"0px 5px 5px 10px",height:e?"22px":void 0,color:"#ffffff",backgroundColor:o.Z[500]},size:"small",icon:a.createElement(r.Z,{style:{color:"white"},size:"small"}),label:"Premium"})}}}]);