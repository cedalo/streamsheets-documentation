"use strict";(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[73803],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>d});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=c(r),d=a,k=m["".concat(s,".").concat(d)]||m[d]||p[d]||i;return r?n.createElement(k,o(o({ref:t},u),{},{components:r})):n.createElement(k,o({ref:t},u))}));function d(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},96453:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>d,default:()=>y,frontMatter:()=>m,metadata:()=>k,toc:()=>f});var n=r(3905),a=Object.defineProperty,i=Object.defineProperties,o=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,u=(e,t,r)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,p=(e,t)=>{for(var r in t||(t={}))s.call(t,r)&&u(e,r,t[r]);if(l)for(var r of l(t))c.call(t,r)&&u(e,r,t[r]);return e};const m={id:"server-certificates",title:"Server Certificates",sidebar_label:"Server Certificates"},d="Docker Setup",k={unversionedId:"security/certificates/server-certificates",id:"version-3.1/security/certificates/server-certificates",title:"Server Certificates",description:"Prerequisites",source:"@site/mosquitto_versioned_docs/version-3.1/security/certificates/server-certificates.md",sourceDirName:"security/certificates",slug:"/security/certificates/server-certificates",permalink:"/mosquitto/security/certificates/server-certificates",draft:!1,tags:[],version:"3.1",frontMatter:{id:"server-certificates",title:"Server Certificates",sidebar_label:"Server Certificates"},sidebar:"someSidebar",previous:{title:"SAML Authentication/SSO",permalink:"/mosquitto/security/platform-access/platform-saml-auth"},next:{title:"mTLS",permalink:"/mosquitto/security/certificates/mtls"}},h={},f=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Configuring Pro Mosquitto Broker with a Server Certificate",id:"configuring-pro-mosquitto-broker-with-a-server-certificate",level:2},{value:"Pro Mosquitto TLS termination",id:"pro-mosquitto-tls-termination",level:3},{value:"HA Proxy TLS termination",id:"ha-proxy-tls-termination",level:3},{value:"Client connections",id:"client-connections",level:3},{value:"Certificate access",id:"certificate-access",level:3},{value:"Configuring Cedalo Platform with a Server Certificate",id:"configuring-cedalo-platform-with-a-server-certificate",level:2},{value:"Environment Variables",id:"environment-variables",level:3},{value:"Example configuration",id:"example-configuration",level:3},{value:"Docker compose",id:"docker-compose",level:3},{value:"TLS Configuration Overview for Kubernetes/OpenShift",id:"tls-configuration-overview-for-kubernetesopenshift",level:2},{value:"<strong>Key Differences:</strong>",id:"key-differences",level:3},{value:"<strong>Why Different Approaches?</strong>",id:"why-different-approaches",level:3},{value:"Single Node TLS Configuration",id:"single-node-tls-configuration",level:2},{value:"Prerequisites",id:"prerequisites-1",level:3},{value:"Configuration Using Helm Values (Recommended)",id:"configuration-using-helm-values-recommended",level:3},{value:"Configuration Parameters",id:"configuration-parameters",level:3},{value:"Alternative: Using Existing Kubernetes Secret",id:"alternative-using-existing-kubernetes-secret",level:3},{value:"What Happens Under the Hood",id:"what-happens-under-the-hood",level:3},{value:"Verify TLS Configuration",id:"verify-tls-configuration",level:3},{value:"Important Path Configuration Notes",id:"important-path-configuration-notes",level:3},{value:"HA Cluster TLS Configuration",id:"ha-cluster-tls-configuration",level:2},{value:"Why HAProxy TLS for HA?",id:"why-haproxy-tls-for-ha",level:3},{value:"Prerequisites",id:"prerequisites-2",level:3},{value:"Prepare HAProxy PEM Certificate",id:"prepare-haproxy-pem-certificate",level:3},{value:"Configuration Using Helm Values (Recommended)",id:"configuration-using-helm-values-recommended-1",level:3},{value:"HAProxy TLS Configuration Parameters",id:"haproxy-tls-configuration-parameters",level:3},{value:"Alternative: Using Existing Kubernetes Secret",id:"alternative-using-existing-kubernetes-secret-1",level:3},{value:"What Happens Under the Hood",id:"what-happens-under-the-hood-1",level:3},{value:"Verify HAProxy TLS Configuration",id:"verify-haproxy-tls-configuration",level:3},{value:"End-to-End Encryption (Optional)",id:"end-to-end-encryption-optional",level:3},{value:"Updating TLS Configuration",id:"updating-tls-configuration",level:2},{value:"Single Node",id:"single-node",level:3},{value:"HA Cluster",id:"ha-cluster",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Single Node Issues",id:"single-node-issues",level:3},{value:"HA Cluster Issues",id:"ha-cluster-issues",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2}],g={toc:f};function y(e){var t,r=e,{components:a}=r,u=((e,t)=>{var r={};for(var n in e)s.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&l)for(var n of l(e))t.indexOf(n)<0&&c.call(e,n)&&(r[n]=e[n]);return r})(r,["components"]);return(0,n.kt)("wrapper",(t=p(p({},g),u),i(t,o({components:a,mdxType:"MDXLayout"}))),(0,n.kt)("h1",p({},{id:"docker-setup"}),"Docker Setup"),(0,n.kt)("h2",p({},{id:"prerequisites"}),"Prerequisites"),(0,n.kt)("p",null,"Ensure you have the following files ready before configuring Mosquitto:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Server Certificate")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.crt"),"): The public server certificate."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Private Key")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.key"),"): The private key associated with the server certificate.")),(0,n.kt)("h2",p({},{id:"configuring-pro-mosquitto-broker-with-a-server-certificate"}),"Configuring Pro Mosquitto Broker with a Server Certificate"),(0,n.kt)("p",null,"This document outlines the two available methods for configuring a broker with a server certificate: using a proxy for TLS termination or configuring TLS directly on the broker. In cluster environments, the use of HAProxy, as provided in the default setup, is recommended for managing TLS termination."),(0,n.kt)("h3",p({},{id:"pro-mosquitto-tls-termination"}),"Pro Mosquitto TLS termination"),(0,n.kt)("p",null,"Open your ",(0,n.kt)("inlineCode",{parentName:"p"},"mosquitto.conf")," file to add a certificate to a certain port.\nAdd or modify the following settings to configure the Pro Mosquitto broker to use the server certificate:"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),"# Enable a listener on port 8883 for SSL/TLS connections\nlistener 8883\nprotocol mqtt\n\n# SSL/TLS certificate paths\ncertfile /path/to/server.crt\nkeyfile /path/to/server.key\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"listener 8883: Sets the port for SSL/TLS communication. Port 8883 is the standard MQTT SSL/TLS port."),(0,n.kt)("li",{parentName:"ul"},"certfile: Specifies the path to the server's public certificate file."),(0,n.kt)("li",{parentName:"ul"},"keyfile: Specifies the path to the server's private key file.")),(0,n.kt)("h3",p({},{id:"ha-proxy-tls-termination"}),"HA Proxy TLS termination"),(0,n.kt)("p",null,"In a cluster setup an HA Proxy is used for TLS termination. This is the default config of the frontend ",(0,n.kt)("inlineCode",{parentName:"p"},"haproxy.cfg"),"file:"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),"frontend mqtt_frontend\n    bind *:1883\n    mode tcp\n    default_backend mqtt_backend\n    timeout client 10m\n")),(0,n.kt)("p",null,"In order to enable TLS termination here add the following behind the ",(0,n.kt)("inlineCode",{parentName:"p"},"bind *:<port>")," parameter: ",(0,n.kt)("inlineCode",{parentName:"p"},"ssl crt /path/to/certs/server.pem"),"\nThis will do the TLS termination at the frontend stage before routing the traffic further to the set backend (here ",(0,n.kt)("inlineCode",{parentName:"p"},"mqtt_backend")," )."),(0,n.kt)("h3",p({},{id:"client-connections"}),"Client connections"),(0,n.kt)("p",null,"Use an MQTT client to connect to the broker using the secure port (e.g., 8883) to verify that the server certificate is being used:"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),"mosquitto_sub -h <broker-ip> -p 8883 -t test/topic --cafile /path/to/ca.crt\n")),(0,n.kt)("p",null,"In this example, a ",(0,n.kt)("inlineCode",{parentName:"p"},"--cafile")," parameter is added to the test because, depending on the device and the server certificate, your underlying system may not have the required CA in place to validate the server certificate you set."),(0,n.kt)("h3",p({},{id:"certificate-access"}),"Certificate access"),(0,n.kt)("p",null,"It is important that the files from the specified path are available to Pro Mosquitto. Ensure that the private key file is securely accessible to the Mosquitto service:"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),"sudo chmod 640 /path/to/server.key\nsudo chown mosquitto:mosquitto /path/to/server.key\n")),(0,n.kt)("p",null,"This ensures that only the Mosquitto service has access to the private key, enhancing security."),(0,n.kt)("p",null,"To apply the changes, restart Pro Mosquitto. Check the Mosquitto logs for troubleshooting if needed."),(0,n.kt)("h2",p({},{id:"configuring-cedalo-platform-with-a-server-certificate"}),"Configuring Cedalo Platform with a Server Certificate"),(0,n.kt)("p",null,"You can achieve https:// access either via a reverse proxy of your choice or by adding the server certificates directly to the platform via environment variables."),(0,n.kt)("h3",p({},{id:"environment-variables"}),"Environment Variables"),(0,n.kt)("p",null,"To conifgure the server certificates use the following Environment Variables:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"BASE_URL"),": URL the platform will be reachable at (should have the same IP/hostname as specified in the certificate)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"NEXTAUTH_URL"),": URL the platform will be reachable at (should have the same IP/hostname as specified in the certificate)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"MOSQUITTO_PLATFORM_HTTPS_KEY_PATH"),": Path to server's private key file (required)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"MOSQUITTO_PLATFORM_HTTPS_CERT_PATH"),": Path to server's certificate (required)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"MOSQUITTO_PLATFORM_HTTPS_CA_PATH"),": path to CA certificate (optional)")),(0,n.kt)("h3",p({},{id:"example-configuration"}),"Example configuration"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{}),"            BASE_URL: https://192.168.178.27:3000\n            NEXTAUTH_URL: https://192.168.178.27:3000\n            MOSQUITTO_PLATFORM_HTTPS_KEY_PATH: /certs/cert.key\n            MOSQUITTO_PLATFORM_HTTPS_CERT_PATH: /certs/cert.crt\n")),(0,n.kt)("h3",p({},{id:"docker-compose"}),"Docker compose"),(0,n.kt)("p",null,"In docker based deployments make sure, that the linked certificates are reachable. A mount to the local directory allows you to store the used certs in the setup folders:"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{}),"        volumes:\n            ...\n            - ./certs:/certs\n")),(0,n.kt)("h1",p({},{id:"kubernetesopenshift-setup"}),"Kubernetes/OpenShift Setup"),(0,n.kt)("h2",p({},{id:"tls-configuration-overview-for-kubernetesopenshift"}),"TLS Configuration Overview for Kubernetes/OpenShift"),(0,n.kt)("p",null,"The Helm charts for both Kubernetes and OpenShift support ",(0,n.kt)("strong",{parentName:"p"},"dynamic TLS configuration")," through ",(0,n.kt)("inlineCode",{parentName:"p"},"values.yaml")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"--set")," flags, eliminating the need to manually edit and repackage chart files. The approach differs between single-node and high-availability (HA) deployments:"),(0,n.kt)("h3",p({},{id:"key-differences"}),(0,n.kt)("strong",{parentName:"h3"},"Key Differences:")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",p({parentName:"tr"},{align:null}),"Deployment Type"),(0,n.kt)("th",p({parentName:"tr"},{align:null}),"TLS Termination Location"),(0,n.kt)("th",p({parentName:"tr"},{align:null}),"Certificate Format"),(0,n.kt)("th",p({parentName:"tr"},{align:null}),"Recommended Approach"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",p({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"td"},"Single Node")),(0,n.kt)("td",p({parentName:"tr"},{align:null}),"Mosquitto Broker"),(0,n.kt)("td",p({parentName:"tr"},{align:null}),"Separate cert + key files"),(0,n.kt)("td",p({parentName:"tr"},{align:null}),"Direct Mosquitto TLS")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",p({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"td"},"HA Cluster")),(0,n.kt)("td",p({parentName:"tr"},{align:null}),"HAProxy Load Balancer"),(0,n.kt)("td",p({parentName:"tr"},{align:null}),"Combined PEM file (cert+key)"),(0,n.kt)("td",p({parentName:"tr"},{align:null}),"HAProxy TLS Termination")))),(0,n.kt)("h3",p({},{id:"why-different-approaches"}),(0,n.kt)("strong",{parentName:"h3"},"Why Different Approaches?")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Single Node"),": TLS is configured directly on the Mosquitto broker since there's no load balancer in front."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"HA Cluster"),": TLS termination at HAProxy provides centralized certificate management, simplifies the setup, and allows the load balancer to handle secure connections before routing to Mosquitto brokers.")),(0,n.kt)("hr",null),(0,n.kt)("h2",p({},{id:"single-node-tls-configuration"}),"Single Node TLS Configuration"),(0,n.kt)("p",null,"For single-node deployments, TLS is configured directly on the Mosquitto broker."),(0,n.kt)("h3",p({},{id:"prerequisites-1"}),"Prerequisites"),(0,n.kt)("p",null,"Ensure you have the following files ready:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Server Certificate")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.crt"),"): The public server certificate"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Private Key")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.key"),"): The private key associated with the server certificate")),(0,n.kt)("h3",p({},{id:"configuration-using-helm-values-recommended"}),"Configuration Using Helm Values (Recommended)"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Step 1: Prepare Certificates")),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),"# Encode certificates to base64\ncat server.crt | base64 -w 0 > server_crt_base64.txt\ncat server.key | base64 -w 0 > server_key_base64.txt\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Step 2: Install with TLS Configuration")),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),'# Read base64 content\nCERT_CONTENT=$(cat server_crt_base64.txt)\nKEY_CONTENT=$(cat server_key_base64.txt)\n\n# Install with TLS enabled\nhelm install my-mosquitto mosquitto-3.1-platform-3.1-kubernetes-sn.tgz -n singlenode \\\n  --set licenseKey=<your-license-key> \\\n  --set nameserver=10.0.0.10 \\\n  --set mosquitto.config.enableTls=true \\\n  --set mosquitto.tls.enabled=true \\\n  --set mosquitto.tls.certContent="$CERT_CONTENT" \\\n  --set mosquitto.tls.keyContent="$KEY_CONTENT" \\\n  --set mosquitto.tls.tlsMountPath="/mosquitto/certs" \\\n  --set mosquitto.tls.certName="server.crt" \\\n  --set mosquitto.tls.keyName="server.key"\n')),(0,n.kt)("h3",p({},{id:"configuration-parameters"}),"Configuration Parameters"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.config.enableTls"),": Enable TLS listener on port 8883. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"false")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.tls.enabled"),": Enable TLS certificate mounting. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"false")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.tls.secretName"),": Kubernetes Secret name. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto-server-tls")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.tls.certContent"),": Base64-encoded certificate content"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.tls.keyContent"),": Base64-encoded private key content"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.tls.tlsMountPath"),": Directory path for mounted certificates. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"/mosquitto/certs")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.tls.certName"),": Certificate filename. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"server.crt")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.tls.keyName"),": Private key filename. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"server.key")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.tls.certFile"),": Certificate key in Secret. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"server.crt")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.tls.keyFile"),": Private key key in Secret. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"server.key"))),(0,n.kt)("h3",p({},{id:"alternative-using-existing-kubernetes-secret"}),"Alternative: Using Existing Kubernetes Secret"),(0,n.kt)("p",null,"If you prefer to create the Secret separately:"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),"# Create Kubernetes Secret\nkubectl create secret generic mosquitto-server-tls -n singlenode \\\n  --from-file=server.crt=./server.crt \\\n  --from-file=server.key=./server.key\n\n# Install referencing existing secret\nhelm install my-mosquitto mosquitto-3.1-platform-3.1-kubernetes-sn.tgz -n singlenode \\\n  --set licenseKey=<your-license-key> \\\n  --set nameserver=10.0.0.10 \\\n  --set mosquitto.config.enableTls=true \\\n  --set mosquitto.tls.enabled=true \\\n  --set mosquitto.tls.secretName=mosquitto-server-tls\n")),(0,n.kt)("h3",p({},{id:"what-happens-under-the-hood"}),"What Happens Under the Hood"),(0,n.kt)("p",null,"When you enable TLS, the Helm chart automatically:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Creates a Kubernetes Secret with your certificates"),(0,n.kt)("li",{parentName:"ol"},"Mounts the Secret as a volume in the Mosquitto StatefulSet at ",(0,n.kt)("inlineCode",{parentName:"li"},"/mosquitto/certs")),(0,n.kt)("li",{parentName:"ol"},"Updates ",(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.conf")," to enable the TLS listener on port 8883:",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",p({parentName:"pre"},{}),"listener 8883\nprotocol mqtt\ncertfile /mosquitto/certs/server.crt\nkeyfile /mosquitto/certs/server.key\n"))),(0,n.kt)("li",{parentName:"ol"},"Exposes port 8883 on the Mosquitto service")),(0,n.kt)("h3",p({},{id:"verify-tls-configuration"}),"Verify TLS Configuration"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),"# Check the Mosquitto service ports\nkubectl get svc mosquitto-loadbalancer -n singlenode\n\n# Test TLS connection\nmosquitto_sub -h <mosquitto-external-ip> -p 8883 --cafile ca.crt -u <username> -P <password> -t '#'\n")),(0,n.kt)("h3",p({},{id:"important-path-configuration-notes"}),"Important Path Configuration Notes"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"IMPORTANT"),": Follow these conventions to avoid path configuration errors:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"tlsMountPath"),": Should be a ",(0,n.kt)("strong",{parentName:"li"},"DIRECTORY path only")," (e.g., ",(0,n.kt)("inlineCode",{parentName:"li"},"/mosquitto/certs"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"certName"),"/",(0,n.kt)("inlineCode",{parentName:"li"},"keyName"),": Should be ",(0,n.kt)("strong",{parentName:"li"},"FILENAMES only")," (e.g., ",(0,n.kt)("inlineCode",{parentName:"li"},"server.crt"),", ",(0,n.kt)("inlineCode",{parentName:"li"},"server.key"),")"),(0,n.kt)("li",{parentName:"ul"},"Final path is constructed as: ",(0,n.kt)("inlineCode",{parentName:"li"},"tlsMountPath/certName")," = ",(0,n.kt)("inlineCode",{parentName:"li"},"/mosquitto/certs/server.crt")),(0,n.kt)("li",{parentName:"ul"},"\u274c ",(0,n.kt)("strong",{parentName:"li"},"WRONG"),": Setting ",(0,n.kt)("inlineCode",{parentName:"li"},"tlsMountPath")," to ",(0,n.kt)("inlineCode",{parentName:"li"},"/mosquitto/certs/server.crt")," (includes filename)"),(0,n.kt)("li",{parentName:"ul"},"\u2705 ",(0,n.kt)("strong",{parentName:"li"},"CORRECT"),": ",(0,n.kt)("inlineCode",{parentName:"li"},'tlsMountPath="/mosquitto/certs"')," and ",(0,n.kt)("inlineCode",{parentName:"li"},'certName="server.crt"'))),(0,n.kt)("hr",null),(0,n.kt)("h2",p({},{id:"ha-cluster-tls-configuration"}),"HA Cluster TLS Configuration"),(0,n.kt)("p",null,"For High-Availability (HA) cluster deployments, ",(0,n.kt)("strong",{parentName:"p"},"TLS termination occurs at the HAProxy load balancer"),", not on individual Mosquitto brokers. This is the ",(0,n.kt)("strong",{parentName:"p"},"recommended approach")," for production HA deployments."),(0,n.kt)("h3",p({},{id:"why-haproxy-tls-for-ha"}),"Why HAProxy TLS for HA?"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"\u2705 ",(0,n.kt)("strong",{parentName:"li"},"Centralized certificate management"),": Update certificates in one place"),(0,n.kt)("li",{parentName:"ul"},"\u2705 ",(0,n.kt)("strong",{parentName:"li"},"Simplified configuration"),": No need to configure TLS on each broker"),(0,n.kt)("li",{parentName:"ul"},"\u2705 ",(0,n.kt)("strong",{parentName:"li"},"Better performance"),": Offload TLS processing to HAProxy"),(0,n.kt)("li",{parentName:"ul"},"\u2705 ",(0,n.kt)("strong",{parentName:"li"},"Easier certificate rotation"),": Update one HAProxy Secret vs. multiple broker Secrets")),(0,n.kt)("h3",p({},{id:"prerequisites-2"}),"Prerequisites"),(0,n.kt)("p",null,"Ensure you have the following:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Server Certificate")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.crt"),"): The public server certificate"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Private Key")," (",(0,n.kt)("inlineCode",{parentName:"li"},"server.key"),"): The private key associated with the server certificate")),(0,n.kt)("h3",p({},{id:"prepare-haproxy-pem-certificate"}),"Prepare HAProxy PEM Certificate"),(0,n.kt)("p",null,"HAProxy requires certificates in ",(0,n.kt)("strong",{parentName:"p"},"PEM format")," with the certificate and private key ",(0,n.kt)("strong",{parentName:"p"},"combined")," in a single file:"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),"# Combine certificate and key into a single PEM file\ncat server.crt server.key > haproxy_combined.pem\n\n# Encode to base64 for Kubernetes Secret\ncat haproxy_combined.pem | base64 -w 0 > haproxy_combined_base64.txt\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Important"),": The order matters! Certificate first, then the private key."),(0,n.kt)("h3",p({},{id:"configuration-using-helm-values-recommended-1"}),"Configuration Using Helm Values (Recommended)"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Install with HAProxy TLS Configuration")),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),'# Read base64 content\nPEM_CONTENT=$(cat haproxy_combined_base64.txt)\n\n# Install with HAProxy TLS enabled\nhelm install my-ha-cluster mosquitto-3.1-platform-3.1-kubernetes-cluster.tgz -n ha \\\n  --set licenseKey=<your-license-key> \\\n  --set nameserver=10.0.0.10 \\\n  --set haproxy.tls.enabled=true \\\n  --set haproxy.tls.pemContent="$PEM_CONTENT" \\\n  --set haproxy.tls.secretName="haproxy-tls-certs" \\\n  --set haproxy.tls.pemFile="haproxy_combined.pem" \\\n  --set haproxy.ports.secureListener=8883\n')),(0,n.kt)("h3",p({},{id:"haproxy-tls-configuration-parameters"}),"HAProxy TLS Configuration Parameters"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.enabled"),": Enable HAProxy TLS termination. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"false")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.secretName"),": Kubernetes Secret name for HAProxy certificates. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"haproxy-tls-certs")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.pemFile"),": PEM filename (combined cert+key). Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"haproxy_combined.pem")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.pemContent"),": Base64-encoded PEM content (cert+key combined)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.pemPath"),": Full path to PEM file in container. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"/etc/haproxy/certs/haproxy_combined.pem")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.tlsHaproxyPemDirPath"),": Directory path for HAProxy certificates. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"/etc/haproxy/certs")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.ports.secureListener"),": HAProxy secure MQTT port. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"8883")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.ports.secureListenerTarget"),": Target port for secure connection. Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"8883"))),(0,n.kt)("h3",p({},{id:"alternative-using-existing-kubernetes-secret-1"}),"Alternative: Using Existing Kubernetes Secret"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),"# Create Kubernetes Secret with PEM file\nkubectl create secret generic haproxy-tls-certs -n ha \\\n  --from-file=haproxy_combined.pem=./haproxy_combined.pem\n\n# Install referencing existing secret\nhelm install my-ha-cluster mosquitto-3.1-platform-3.1-kubernetes-cluster.tgz -n ha \\\n  --set licenseKey=<your-license-key> \\\n  --set nameserver=10.0.0.10 \\\n  --set haproxy.tls.enabled=true \\\n  --set haproxy.tls.secretName=haproxy-tls-certs\n")),(0,n.kt)("h3",p({},{id:"what-happens-under-the-hood-1"}),"What Happens Under the Hood"),(0,n.kt)("p",null,"When you enable HAProxy TLS, the Helm chart automatically:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Creates a Kubernetes Secret (",(0,n.kt)("inlineCode",{parentName:"li"},"haproxy-tls-certs"),") with your PEM certificate"),(0,n.kt)("li",{parentName:"ol"},"Mounts the Secret as a volume in the HAProxy Deployment at ",(0,n.kt)("inlineCode",{parentName:"li"},"/etc/haproxy/certs")),(0,n.kt)("li",{parentName:"ol"},"Updates HAProxy configuration to add a secure frontend:",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",p({parentName:"pre"},{}),"frontend mqtt_frontend_secure\n    bind *:8883 ssl crt /etc/haproxy/certs/haproxy_combined.pem\n    mode tcp\n    maxconn 10000\n    default_backend mqtt_backend\n    timeout client 10m\n"))),(0,n.kt)("li",{parentName:"ol"},"Exposes port 8883 on the HAProxy LoadBalancer service"),(0,n.kt)("li",{parentName:"ol"},"Routes secure traffic to Mosquitto brokers (non-TLS communication between HAProxy and brokers)")),(0,n.kt)("h3",p({},{id:"verify-haproxy-tls-configuration"}),"Verify HAProxy TLS Configuration"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),"# Check HAProxy service ports (should show both 1883 and 8883)\nkubectl get svc haproxy -n ha\n\n# Test TLS connection through HAProxy\nmosquitto_sub -h <haproxy-external-ip> -p 8883 --cafile ca.crt -u <username> -P <password> -t '#'\n")),(0,n.kt)("h3",p({},{id:"end-to-end-encryption-optional"}),"End-to-End Encryption (Optional)"),(0,n.kt)("p",null,"If you require encryption ",(0,n.kt)("strong",{parentName:"p"},"between HAProxy and Mosquitto brokers")," (end-to-end encryption), you can enable TLS on both:"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),'helm install my-ha-cluster mosquitto-3.1-platform-3.1-kubernetes-cluster.tgz -n ha \\\n  --set licenseKey=<your-license-key> \\\n  --set nameserver=10.0.0.10 \\\n  --set haproxy.tls.enabled=true \\\n  --set haproxy.tls.pemContent="$HAPROXY_PEM_CONTENT" \\\n  --set mosquitto.config.enableTls=true \\\n  --set mosquitto.tls.enabled=true \\\n  --set mosquitto.tls.certContent="$MOSQUITTO_CERT_CONTENT" \\\n  --set mosquitto.tls.keyContent="$MOSQUITTO_KEY_CONTENT"\n')),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Note"),": This is typically ",(0,n.kt)("strong",{parentName:"p"},"not required")," for most deployments, as communication between HAProxy and Mosquitto occurs within the Kubernetes cluster network."),(0,n.kt)("hr",null),(0,n.kt)("h2",p({},{id:"updating-tls-configuration"}),"Updating TLS Configuration"),(0,n.kt)("p",null,"To update certificates after initial deployment:"),(0,n.kt)("h3",p({},{id:"single-node"}),"Single Node"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),'# Update with new certificates\nhelm upgrade my-mosquitto mosquitto-3.1-platform-3.1-kubernetes-sn.tgz -n singlenode \\\n  --reuse-values \\\n  --set mosquitto.tls.certContent="$NEW_CERT_CONTENT" \\\n  --set mosquitto.tls.keyContent="$NEW_KEY_CONTENT"\n')),(0,n.kt)("h3",p({},{id:"ha-cluster"}),"HA Cluster"),(0,n.kt)("pre",null,(0,n.kt)("code",p({parentName:"pre"},{className:"language-bash"}),'# Update HAProxy certificates\nhelm upgrade my-ha-cluster mosquitto-3.1-platform-3.1-kubernetes-cluster.tgz -n ha \\\n  --reuse-values \\\n  --set haproxy.tls.pemContent="$NEW_PEM_CONTENT"\n')),(0,n.kt)("hr",null),(0,n.kt)("h2",p({},{id:"troubleshooting"}),"Troubleshooting"),(0,n.kt)("h3",p({},{id:"single-node-issues"}),"Single Node Issues"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Connection Refused on Port 8883")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Verify ",(0,n.kt)("inlineCode",{parentName:"li"},"mosquitto.config.enableTls=true")," is set"),(0,n.kt)("li",{parentName:"ul"},"Check service exposes port 8883: ",(0,n.kt)("inlineCode",{parentName:"li"},"kubectl get svc mosquitto-loadbalancer -n singlenode")),(0,n.kt)("li",{parentName:"ul"},"Verify certificates are mounted: ",(0,n.kt)("inlineCode",{parentName:"li"},"kubectl exec mosquitto-0 -n singlenode -- ls -la /mosquitto/certs"))),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Certificate Validation Errors")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Ensure certificate matches the hostname/IP you're connecting to"),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"--cafile")," flag to provide CA certificate if not in system trust store")),(0,n.kt)("h3",p({},{id:"ha-cluster-issues"}),"HA Cluster Issues"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Connection Refused on Port 8883 (HAProxy)")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Verify ",(0,n.kt)("inlineCode",{parentName:"li"},"haproxy.tls.enabled=true")," is set"),(0,n.kt)("li",{parentName:"ul"},"Check HAProxy service exposes port 8883: ",(0,n.kt)("inlineCode",{parentName:"li"},"kubectl get svc haproxy -n ha")),(0,n.kt)("li",{parentName:"ul"},"Verify PEM file is mounted: ",(0,n.kt)("inlineCode",{parentName:"li"},"kubectl exec <haproxy-pod> -n ha -- ls -la /etc/haproxy/certs"))),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Invalid PEM Format")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Ensure certificate and key are combined in correct order: certificate first, then key"),(0,n.kt)("li",{parentName:"ul"},"Verify base64 encoding is correct: ",(0,n.kt)("inlineCode",{parentName:"li"},'echo "$PEM_CONTENT" | base64 -d | openssl x509 -text'))),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"HAProxy Not Starting")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Check HAProxy logs: ",(0,n.kt)("inlineCode",{parentName:"li"},"kubectl logs <haproxy-pod> -n ha")),(0,n.kt)("li",{parentName:"ul"},"Common issue: Missing or incorrectly formatted PEM file")),(0,n.kt)("hr",null),(0,n.kt)("h2",p({},{id:"security-best-practices"}),"Security Best Practices"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Use Strong Certificates"),": Use certificates from a trusted CA or properly configured self-signed certificates"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Secure Private Keys"),": Never commit private keys to version control"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Rotate Certificates Regularly"),": Update certificates before expiration"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Use Kubernetes Secrets"),": Store certificates in Kubernetes Secrets, not in plain text"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Restrict Secret Access"),": Use Kubernetes RBAC to limit who can access certificate Secrets"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Monitor Certificate Expiration"),": Set up alerts for certificate expiration"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"For HA"),": Always use HAProxy TLS termination instead of individual broker TLS for easier management")))}y.isMDXComponent=!0}}]);